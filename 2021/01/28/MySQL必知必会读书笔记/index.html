<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="MySQL必知必会读书笔记"><meta name="keywords" content="数据库,读书笔记"><meta name="author" content="恒若时光"><meta name="copyright" content="恒若时光"><title>MySQL必知必会读书笔记 | 恒若时光のblog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E8%A1%A5%E5%85%85"><span class="toc-text">内容补充</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E4%BA%86%E8%A7%A3SQL"><span class="toc-text">1.了解SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-MySQL%E7%AE%80%E4%BB%8B"><span class="toc-text">2.MySQL简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8MySQL"><span class="toc-text">3.使用MySQL</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE"><span class="toc-text">4.检索数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%8E%92%E5%BA%8F%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE"><span class="toc-text">5.排序检索数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE"><span class="toc-text">6.过滤数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%BC%BA%E7%89%88"><span class="toc-text">7.过滤数据加强版</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4"><span class="toc-text">8.用通配符进行过滤</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2"><span class="toc-text">9.用正则表达式进行搜索</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5"><span class="toc-text">10.创建计算字段</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-text">11.使用数据处理函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE"><span class="toc-text">12.汇总数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE"><span class="toc-text">13.分组数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-text">14.使用子查询</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-%E8%81%94%E6%8E%A5%E8%A1%A8"><span class="toc-text">15.联接表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93"><span class="toc-text">16.创建高级联结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17-%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="toc-text">17.组合查询</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18-%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2-%E4%BA%86%E8%A7%A3"><span class="toc-text">18.全文本搜索(了解)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-text">19.插入数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20-%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-text">20.更新与删除数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21-%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8"><span class="toc-text">21.创建和操纵表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#22-%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE"><span class="toc-text">22.使用视图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">23.使用存储过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#24-%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87"><span class="toc-text">24.使用游标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#25-%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-text">25.使用触发器</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1115959009,3928225272&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">恒若时光</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">3</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">4</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://desk-fd.zol-img.com.cn/t_s1024x768c5/g5/M00/0A/0C/ChMkJlkml26ISdS6AASb0-G7sfUAAcmwwO6rFEABJvr18.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">恒若时光のblog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">类别</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">MySQL必知必会读书笔记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-28</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">13.9k</span><span class="post-meta__separator">|</span><span>阅读时长: 45 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="内容补充"><a href="#内容补充" class="headerlink" title="内容补充"></a>内容补充</h1><p>补一个MySQL语句的执行顺序</p>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210130001805602.png" class>

<h1 id="1-了解SQL"><a href="#1-了解SQL" class="headerlink" title="1.了解SQL"></a>1.了解SQL</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>数据库和数据库软件：数据库是<strong>存放一组</strong>按某种组织方式组织起来的<strong>数据</strong>的<strong>容器</strong>，而这里说的容器是概念性的，这个容器的物理构成是可以多样的，但一般是以计算机中的文件的形式存在(存放在外存之中)。而数据库软件(比如MySQL),他其实是DBMS，它来负责直接对物理数据库进行操作，包括修改、添加(添加则说明DBMS是创建这个数据库容器的软件)、删除数据库。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主键和表</span><br><span class="line">	表：关系数据库中的数据以表的方式组织起来存放的。表中的每一列代表一个属性，每一个属性在创建时都要给定数据类型。</span><br><span class="line">	主键：一般在创建一张表时，默认情况下要指定某一列或某些列为主键。主键是用来区分同一张表中不同的行的，特点是：</span><br><span class="line">	<span class="number">1.</span>不同行的主键的值不相同，主键值必须唯一(若是一组列，允许某一列值相同，但是不同出现完全相同的组合方式)</span><br><span class="line">	<span class="number">2.</span>主键值不能为空</span><br></pre></td></tr></table></figure>
<p>SQL也称为结构化查询语言，是用来让DBMS识别其语义，来向数据库发出对应操作的一种语言。SQL由标准委员会制定，大部分DBMS都能识别，但是在实现上会有不同，并且不是完全可移植的，也就是不同的DBMS支持SQL会有不同点。</p>
<a id="more"></a>

<h1 id="2-MySQL简介"><a href="#2-MySQL简介" class="headerlink" title="2.MySQL简介"></a>2.MySQL简介</h1><ul>
<li><code>MySQL</code>是一种基于客户服务器的DBMS，服务器端软件来直接访问和处理数据，一般运行在一个专门的服务器上。而这个服务器端软件也就是我们的DBMS本体，比如<code>MySQL</code>这个软件。DBMS处理数据的请求一半来自于客户端软件，客户端软件包括能连接DBMS的程序设计语言编写的软件等。<strong>当然这个客户端的软件和DBMS也可以部署到同一台机器上</strong></li>
<li><code>MySQL</code>的命令行的命令后面要加上<code>;</code>才能执行</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p <span class="comment">//连接数据库</span></span><br><span class="line">quit;            <span class="comment">//退出数据库连接</span></span><br></pre></td></tr></table></figure>


<h1 id="3-使用MySQL"><a href="#3-使用MySQL" class="headerlink" title="3.使用MySQL"></a>3.使用MySQL</h1><p>使用<code>MySQL</code>之前必须要连接上<code>MySQL</code>,连接时需要提供账户和密码，<code>MySQL</code>内部会存有用户的权限等信息，不同的用户对数据库的操作权限也不同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">常见命令</span><br><span class="line">show databases;</span><br><span class="line">show tables;</span><br><span class="line">use name; <span class="comment">//使用某个数据库之前要use一样，这个命令相当于切换当前工作数据库</span></span><br><span class="line">show columns from table_name;<span class="comment">//查看表的所有列的属性等</span></span><br><span class="line">describe course_info;<span class="comment">//和上面一样</span></span><br></pre></td></tr></table></figure>
<h1 id="4-检索数据"><a href="#4-检索数据" class="headerlink" title="4.检索数据"></a>4.检索数据</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">select column_name from table; <span class="comment">//查询表中某一列的所有数据，注意返回的不一定是有序的</span></span><br><span class="line"></span><br><span class="line">select c_id,c_name,c_teacher from course_info;<span class="comment">//从一张表中检索多列，都好隔开</span></span><br><span class="line"></span><br><span class="line">select * from course_info;<span class="comment">//查看所有列</span></span><br><span class="line"></span><br><span class="line">select distinct c_score from course_info;<span class="comment">//c_score可能有重复值，distinct修饰符会去重只展示不重复的值</span></span><br><span class="line"></span><br><span class="line">select distinct c_score,department_id from course_info;<span class="comment">//error,对多列去重不可以</span></span><br><span class="line"></span><br><span class="line">select c_teacher from course_info limit <span class="number">5</span>;<span class="comment">//limit接一个数，表述输出从第一行开始的5行</span></span><br><span class="line"></span><br><span class="line">select c_teacher from course_info limit <span class="number">4</span>,<span class="number">5</span>;<span class="comment">//limit接两个数，表示输出从第5行(我试了一下，给的是4，实际结果是从第5行开始算的 )开始的5行</span></span><br><span class="line"></span><br><span class="line">select course_info.c_score from manage_sys.course_info;<span class="comment">//.符号的语法，到指定表找指定列，只不过这里.相当于给出了所属关系。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="5-排序检索数据"><a href="#5-排序检索数据" class="headerlink" title="5.排序检索数据"></a>5.排序检索数据</h1>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SQL语句都是由子句构成的，order by和from where都是子句</span><br><span class="line">  </span><br><span class="line">select c_remain from course_info order by c_remain;<span class="comment">//是这样的，他先把一个表中的所有记录按c_remain这个属性排序，排序完之后再展示排序之后的记录中的c_remain这一项。先逻辑操作，再显示</span></span><br><span class="line"><span class="string">&quot;先运算————order by,再投影Select&quot;</span></span><br><span class="line">  </span><br><span class="line">select c_remain,c_name,c_score from course_info order by c_remain,c_score;<span class="comment">//输出多列;先按c_remain对表中所有记录排序，然后对按c_remain排序时相等的记录(也仅对相等的记录)再按c_score排序。两次排序之后再展示排序后记录中的c_remain,c_name,c_score这三列</span></span><br><span class="line">  </span><br><span class="line">select c_remain,c_name,c_score from course_info order by c_remain desc,c_score;<span class="comment">//先对所有记录按c_remain降序排序，然后对c_remain排序时相等的那些记录按c_score按c_score升序排序，desc只影响他最接近的那个熟悉</span></span><br><span class="line">  </span><br><span class="line">select c_remain from course_info order by c_remain desc limit <span class="number">1</span>;<span class="comment">//组合技，输出结果最大值</span></span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210125144002097.png" class>

<h1 id="6-过滤数据"><a href="#6-过滤数据" class="headerlink" title="6.过滤数据"></a>6.过滤数据</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select c_score,c_name from course_info where c_score = <span class="number">3</span>;<span class="comment">//where进行过滤数据</span></span><br><span class="line">select c_score,c_name from course_info where c_department = &#x27;软件学院&#x27;;//如果是字符串用&#x27;&#x27;括起来</span><br><span class="line"></span><br><span class="line">select c_score,c_name from course_info where c_score = <span class="number">3</span> order by c_remain;<span class="comment">//order by和where结合时，应该先过滤然后再排序，否则会出错</span></span><br><span class="line"></span><br><span class="line">where筛选的逻辑有 = &gt; &lt; != &gt;= &lt;= between</span><br><span class="line"></span><br><span class="line">select c_remain from course_info where c_remain between <span class="number">90</span> <span class="keyword">and</span> <span class="number">100</span>;<span class="comment">//筛选范围，注意必须是范围的低端点和高端点。</span></span><br><span class="line"></span><br><span class="line">select c_id from course_info where c_remain is <span class="literal">NULL</span>;<span class="comment">//查询是否有空值，如果某一行的c_remain有空值，就返回</span></span><br></pre></td></tr></table></figure>
<h1 id="7-过滤数据加强版"><a href="#7-过滤数据加强版" class="headerlink" title="7.过滤数据加强版"></a>7.过滤数据加强版</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span>操作符</span><br><span class="line">select c_id from course_info where c_score = 3 and department_id = &#x27;001&#x27;;//where的筛选条件用and逻辑操作符连接</span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span>操作符</span><br><span class="line">select c_id from course_info where c_score = 3 or department_id = &#x27;001&#x27;;//找到所有c_score = 3或者department_id = ‘001’的记录，并返回这些记录中的c_id。其实过程也应该就是在不满足一个条件的记录中再去找那些满足第二个条件的那些记录</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210125152646309.png" class>

<p>由于SQL语句设定的and操作符计算次序优先级比or要高，所以上面的语句会被解析为3 or (1 and 2)</p>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210125152921378.png" class>

<p>消除歧义的方法就是使用括号提升优先级。使用and 和 or组合时，尽量使用()来明确条件的组合。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">select c_remain from course_info where c_remain <span class="title">in</span> <span class="params">(<span class="number">80</span>,<span class="number">88</span>,<span class="number">95</span>)</span></span>;<span class="comment">//()除了提升优先级之外还可以圈出一个集合，比如上面就圈出了一个数量集合，集合中有80 88 95三个元素，和in操作符结合。这个where条件就是找所有剩余数量为80 88 95的记录</span></span><br><span class="line">用in圈定范围比用<span class="keyword">or</span>一个一个连接要好，因为in比<span class="keyword">or</span>快。</span><br><span class="line">    </span><br><span class="line"><span class="function">select c_remain from course_info where c_remain <span class="keyword">not</span> <span class="title">in</span> <span class="params">(<span class="number">80</span>,<span class="number">88</span>,<span class="number">95</span>)</span></span>;<span class="comment">//用not取个反</span></span><br></pre></td></tr></table></figure>
<h1 id="8-用通配符进行过滤"><a href="#8-用通配符进行过滤" class="headerlink" title="8.用通配符进行过滤"></a>8.用通配符进行过滤</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">select c_teacher from course_info where c_department like &#x27;%学院&#x27;;</span><br><span class="line">上面是使用%通配符，他代表任意字符出现任意次数(包括<span class="number">0</span> <span class="number">1</span> ...n)组成的字符串(说人话就可以表示任意的字符，包括空)，这里就是找所有记录的department中，以...学院结尾的记录。</span><br><span class="line"><span class="number">1.</span>上面的 %学院称为搜索模式;</span><br><span class="line"><span class="number">2.</span>搜索语句中使用模式必须加上like操作符(like可做操作符也可以做谓词);</span><br><span class="line">3.通配符可以有多个，也可以出现在搜索模式的任意位置，比如&#x27;%han%&#x27;就是代表所有存在han文本的属性</span><br><span class="line"><span class="number">4.</span>通配符也匹配不了<span class="literal">NULL</span>，检查<span class="literal">NULL</span>值只能用is <span class="literal">NULL</span>;你<span class="string">&#x27;%&#x27;</span>也不能匹配<span class="literal">NULL</span></span><br><span class="line">5.有的MySQL匹配时设置了大小写敏感，那么你&#x27;%H&#x27;是搜索不到&#x27;%h&#x27;的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x27;_ello&#x27;: -通配符只能匹配一个字，不能多也不能少，即不能出现0次</span><br><span class="line">select c_teacher from course_info where c_department like &#x27;_软件学院&#x27;;//这样就是什么也搜不到</span><br><span class="line"></span><br><span class="line">通配符注意事项</span><br><span class="line"><span class="number">1.</span>尽量少用通配符搜索，比较慢</span><br><span class="line"><span class="number">2.</span>如果要用，尽量避免把通配符放在开头，放在开头搜索是最慢的</span><br></pre></td></tr></table></figure>


<h1 id="9-用正则表达式进行搜索"><a href="#9-用正则表达式进行搜索" class="headerlink" title="9.用正则表达式进行搜索"></a>9.用正则表达式进行搜索</h1><ul>
<li>正则表达式也是一种模式，where语句可以根据这个模式来匹配文本</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.正则表达式匹配及其特点</span></span><br><span class="line">select c_teacher from course_info where c_department regexp &#x27;科学&#x27;;//正则表达式匹配，他会查找所有记录的c_department,检查其文本中是否有&#x27;科学&#x27;这个模式，即是否有&#x27;科学&#x27;这个文本，有的话就返回。即查看属性值中是否有这个正则表达式模式的文本，用的关键字是regexp</span><br><span class="line">1.&#x27;科学&#x27;：这个同样也叫做模式</span><br><span class="line">2.&#x27;.科学&#x27;：这个.是正则表达式支持的符号，代表任意一个字符，和&#x27;-&#x27;通配符一样，仅能且必须要代表一个符号，不能空。</span><br><span class="line"><span class="number">3.</span>正则表达式的匹配默认不大小写敏感，如果要明确区分大小写，加上binary关键字。</span><br><span class="line">select c_teacher from course_info where c_name regexp binary &#x27;WuHanyi&#x27;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.通配符模式匹配的特点(比较着看)</span></span><br><span class="line">select c_teacher from course_info where c_department like &#x27;科学&#x27;;//而这个是查找所有记录，查看他们的属性值是否为&#x27;科学&#x27;。即用like就是看属性值是否和我这个模式匹配</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.or连接符</span></span><br><span class="line">select c_teacher from course_info where c_department regexp &#x27;科学 | 学院 | 软件&#x27;;// |表示或运算，连接</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.[]符号</span></span><br><span class="line">select c_teacher from course_info where c_department regexp &#x27;[软件科学]学院&#x27;;//这个[软件科学]的意思是  [软件|科学]，[]括起来的字符也是一种或逻辑，这里让找的c_department中出现&#x27;软件学院&#x27; | &#x27;科学学院&#x27;的文本。</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.[]和 |的对比</span></span><br><span class="line">select c_teacher from course_info where c_department regexp &#x27;软件 | 科学学院&#x27;;//如果这样写,意思就是查找出现&#x27;软件&#x27; | &#x27;科学学院&#x27; 文本的记录</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.[]里面的^符号</span></span><br><span class="line">&#x27;[^软件科学]学院&#x27;:这个就是找除&#x27;软件学院&#x27;和&#x27;科学学院&#x27;以外的所有文本</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.范围匹配</span></span><br><span class="line">&#x27;[1-5] hello&#x27;:范围匹配，也就是&#x27;[12345] hello&#x27;这个模式的简写</span><br><span class="line">&#x27;[a-p]&#x27; hello&#x27; :同范围匹配</span><br><span class="line">&#x27;[1-5\\.]&#x27;:范围匹配，也就是&#x27;[12345\\.] hello&#x27;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.匹配特殊字符</span></span><br><span class="line">如果要匹配有.符号的文本，用&#x27;.&#x27;不行，因为他代表所有字符。所以匹配特殊字符需要加上转义符号&#x27;\\&#x27;，转义符号可以原本有特殊意义的符号变为他字符层面的意思。所以匹配的模式是&#x27;\\.&#x27;  ;一般语言的转移符号都是一个\，但是mysql需要2个</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210128165926938.png" class>

<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210128165951012.png" class>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上面都是正则表达式定义的特殊符号，举个例子</span><br><span class="line">select name from student_info where id regexp &#x27;[:alnum:]&#123;4&#125;&#x27;</span><br><span class="line">这个[:alnum:]就是任意数字或字母，而&#123;4&#125;就是指定匹配4次，所以这个意思就是匹配任意数字或字母重复出现4次的文本，比如&#x27;1111&#x27;,&#x27;aaaa&#x27;都是</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210128171243689.png" class>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">上面都是定位符，前面说的都是从属性值的任意位置开始匹配，如果想从指定位置开始匹配就要使用上面的定位符</span><br><span class="line">select name from s_info where id regexp &#x27;^[1-5//.] hello&#x27;;</span><br><span class="line">这个就是在属性的开头，检查有没有&#x27;[1-5//.] hello&#x27;的文本</span><br><span class="line">    ^在[]里面和外面有不同的涵义</span><br><span class="line">    </span><br><span class="line"><span class="comment">//正则表达式的测试，也就是不依赖数据库单纯测试表达式是否可行</span></span><br><span class="line">    select &#x27;hello world&#x27; regexp &#x27;d&#x27;</span><br><span class="line">    这个测试式子只会返回<span class="number">0</span>或<span class="number">1</span>，有就<span class="number">1</span>，无<span class="number">0</span>,上面式子返回的就是<span class="number">1</span></span><br></pre></td></tr></table></figure>


<h1 id="10-创建计算字段"><a href="#10-创建计算字段" class="headerlink" title="10.创建计算字段"></a>10.创建计算字段</h1><ul>
<li>所谓计算字段就是本身并不存在于数组库中(即数据库中本没有这一列)，是由DBMS按照输入的SQL语句(应该说是MySQL支持的特殊的SQL语句)来将数据库中的数据进行拼接等逻辑操作处理后返回的特殊数据(特殊处理后的数据)。</li>
<li>使用计算字段就是因为大多数情况下，并不是直接获取数据库中的数据。比如数据库中有商家店名、商店地址这两列，我想要获得店名(商店地址)这样的一种数据，数据库中没有，这时候就需要DBMS将数据库中的数据特殊处理后生成符合我们要求的数据，也就是计算字段。</li>
<li><strong>综上，用函数处理的一堆数据称为计算字段</strong></li>
<li>其实我们也可以在客户端对数据进行组合处理，但是肯定没有DBMS干这事快。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Concat函数拼接生成计算字段</span></span><br><span class="line">select Concat(s_name,&#x27;的&#x27;,c_name,&#x27;成绩为&#x27;,grade) from grade_info;</span><br><span class="line">结果就是返回<span class="string">&quot;s_name的c_name成绩为grade&quot;</span>这样一种数据</span><br><span class="line"></span><br><span class="line"><span class="comment">//Trim函数，来去除某一列数据的空格</span></span><br><span class="line">select Concat(RTrim(s_name),&#x27;的&#x27;,c_name,&#x27;成绩为&#x27;,grade) from grade_info;//比如这个就是去掉了s_name右边的空格。以此类推还有LTrim,Trim(两边的空格都去掉)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用as关键字给计算字段取个别名</span></span><br><span class="line">select Concat(s_name,&#x27;的&#x27;,c_name,&#x27;成绩为&#x27;,grade) as info from grade_info;//给这一串数据取名为info，目前不知道有啥用</span><br><span class="line"></span><br><span class="line"><span class="comment">//真&quot;计算&quot;字段，支持+-*/，可以用()来区分优先级</span></span><br><span class="line">select c_score*c_remain as score from course_info;</span><br></pre></td></tr></table></figure>
<h1 id="11-使用数据处理函数"><a href="#11-使用数据处理函数" class="headerlink" title="11.使用数据处理函数"></a>11.使用数据处理函数</h1><p>本章只要知道有这么个东西，真正用再来查</p>
<p>大多数的DBMS都支持下列三类函数</p>
<ol>
<li>文本处理函数</li>
<li>日期和时间处理函数</li>
<li>数值处理函数</li>
</ol>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210128182110172.png" class>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这里面注意的就是Soundex(),有点邪乎，他是找发音匹配的数据</span><br><span class="line">比如数据库有个人名为Steve，但是你输入成Stev是找不到的，但是Soundex(Stev)就能找到Steve,感觉没啥用</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210128182641137.png" class>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">举一个例子，比如数据库中有一列是日期这一项，但是日期是年/月/日 时/分/秒 格式来存放的，你要查找时，完全不记得时/分/秒，你只记得，是几号。那么查找就可以用Data()函数</span><br><span class="line">select ord_num,ord_id from order where Data(order_date) = &#x27;2020/1/27&#x27;;//这个感觉很有用</span><br><span class="line"></span><br><span class="line">select ord_num,ord_id from order where Year(order_date) = &#x27;2020&#x27; and Month(order_date) = 9;//查询2020年9月的所有订单，组合技，也挺有用的</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210128184022029.png" class>

<p>上面是常见的数值处理函数，各大DBMS这个函数好像是一致的</p>
<h1 id="12-汇总数据"><a href="#12-汇总数据" class="headerlink" title="12.汇总数据"></a>12.汇总数据</h1><img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210128191736465.png" class>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AVG返回列的平均值</span></span><br><span class="line">select AVG(grade) from grade_info where s_id = &#x27;sa20225068&#x27;;//返回特定用户的在grade这一列的平均成绩</span><br><span class="line">AVG忽略值为<span class="literal">NULL</span>的列</span><br><span class="line"></span><br><span class="line"><span class="comment">//Count()确定表中行的数目或者符合特定条件的行的数目</span></span><br><span class="line"><span class="number">1.</span>Count(*):返回表的行数，不管表值是否为<span class="literal">NULL</span>,即*时不忽略<span class="literal">NULL</span></span><br><span class="line"><span class="number">2.</span>Count(column):返回特定列不为<span class="literal">NULL</span>的行数</span><br><span class="line"></span><br><span class="line"><span class="comment">//MAX(column),MIN(column),SUM(column)的用法都是相同的</span></span><br><span class="line"><span class="function">select <span class="title">MAX</span><span class="params">(c_score*c_remain)</span> from course_info</span>;<span class="comment">//处理普通用法之外还可以这么用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//聚集不同的值，对于SUM,AVG,Count来说有用</span></span><br><span class="line">select AVG(distinct grade) from grade_info where s_id = &#x27;sa20225068&#x27;;//返回特定条件的grade中，不重复的值的平均值</span><br><span class="line">Count只能Count(distinct column),不能Count(distinct *);</span><br><span class="line">SUM(distinct c_score*c_remain);这种也是可以的</span><br><span class="line"></span><br><span class="line"><span class="comment">//这些聚集函数还能一起用</span></span><br><span class="line">select AVG(grade) as s_avg,</span><br><span class="line">	   SUM(grade) as s_grd,</span><br><span class="line">from grade_info where s_id = &#x27;sa20225068&#x27;;//列属性之间加上,号，而不是换行加,</span><br></pre></td></tr></table></figure>


<h1 id="13-分组数据"><a href="#13-分组数据" class="headerlink" title="13.分组数据"></a>13.分组数据</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建分组</span></span><br><span class="line">select c_name,s_id,Count(s_id) as &#x27;学生成绩条数&#x27; from grade_info group by s_id;</span><br><span class="line">上面意思是将所以记录按照s_id进行分组，s_id有几个不重复的，就分几组。记录分组之后，他给你返回的数据都是按组进行返回的。分组后的Count(s_id)也是由系统自动按组计数的</span><br><span class="line">    如下图所示，按s_id分组之后只有两组，所有返回的数据都是两行。虽然每一组c_name的取值也有多个，但是按组返回，返回的就是每一组s_id的第一个c_name(这个应该是随机的，我也只是看到现象)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//2.注意点</span></span><br><span class="line"><span class="number">1.</span>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</span><br><span class="line"><span class="number">2.</span>如果分组列中具有<span class="literal">NULL</span>值，则<span class="literal">NULL</span>将作为一个分组返回。如果列中有多行<span class="literal">NULL</span>值，它们将分为一组。</span><br><span class="line"><span class="number">3.</span>除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。(那我下面截图中的示例语句是错的)正确应该是</span><br><span class="line">    select c_name,s_id,Count(s_id) as &#x27;学生成绩条数&#x27; from grade_info group by s_id,c_name;</span><br><span class="line">	我是按s_id分组的，所以最后每个s_id就可以代表一个分组，最后投影投的是分组，也就是s_id</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210128204853697.png" class>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.过滤分组，MySQL使用having子句过滤分组；where子句处理不了分组，只能过滤行</span></span><br><span class="line">select s_id,Count(s_id) from grade_info where grade &gt; <span class="number">10</span> <span class="function">group by s_id having <span class="title">Count</span><span class="params">(s_id)</span> &gt; 3</span>;</span><br><span class="line">这个筛选顺序是这样的：先去找出所有grade大于<span class="number">10</span>的行，然后再把找出的这些行按s_id分组，然后计算count(s_id),此时Count(s_id)就是每个分组的s_id数目了，最后再筛选出分组中(s_id)个数大于<span class="number">2</span>的分组，最后再提取分组的s_id，计算字段。(再提醒一句，select子句的列除了计算字段外其他都要是group子句中的列)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.group by和order by结合</span></span><br><span class="line">select s_id,AVG(grade) <span class="function">as a_grd from grade_info group by s_id having <span class="title">Count</span><span class="params">(s_id)</span> &gt; 1 order by a_grd</span>;</span><br><span class="line">先按s_id分组，然后按分组，然后计算分组的Count(s_id)之后筛选，最后再将筛选出来的分组按照计算字段a_grd排序，最后投影。<span class="string">&quot;注意这里面排序貌似可以不用select子句后面的属性，但是把，你是输出这些玩意，肯定要按你投影的某个属性来排序，所以这里是按出现在select子句后面的计算字段来排序的&quot;</span></span><br><span class="line">注：还有一点，我终于知道了给计算字段取别名有啥用了</span><br></pre></td></tr></table></figure>
<p>最后再总结一下select子句的各个关键字：</p>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210128214816717.png" class>

<h1 id="14-使用子查询"><a href="#14-使用子查询" class="headerlink" title="14.使用子查询"></a>14.使用子查询</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.利用子查询进行过滤</span></span><br><span class="line">假设订单号和订单物品的关系存储在表A中，用户和订单号的关系存储在表B中，我现在有这么个需求：我要查询所有买过商品&#x27;TNT_2&#x27;的用户的u_id,为完成这个功能，我们可以分两步来做</span><br><span class="line">1.根据prod_id = &#x27;TNT_2&#x27;在表A中筛选出订单号order_id</span><br><span class="line"><span class="number">2.</span>在B中根据<span class="number">1</span>筛选出来的订单号来筛选u_id</span><br><span class="line">但是上面的功能可以使用嵌套子查询来完成</span><br><span class="line">select u_id from B where order_id in (select order_id from A where prod_id = &#x27;TNT_2&#x27;);</span><br><span class="line"><span class="number">1.</span>子查询语句是从内向外执行的，也就是嵌套在最里面的()中的select语句先执行，然后逐渐到外层。</span><br><span class="line"><span class="number">2.</span>子查询一般和in搭配使用，当然也可以用 = !=等逻辑</span><br><span class="line"><span class="number">3.</span>()套着的查询语句称为子查询语句</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.子查询替代计算字段</span></span><br><span class="line">select c_department,(select Count(*) from course_info where department_id = &#x27;001&#x27;) as course_num from course_info;</span><br><span class="line">也就是计算字段也可以用子查询语句代替</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.相关子查询————涉及外部查询的子查询</span></span><br><span class="line">select cust_name,cust_state,</span><br><span class="line">	(select Count(*) from orders where orders.cust_id = customers.cust_id) as orders from coustomers;</span><br><span class="line">orders.cust_id = customers.cust_id这个用到了全限定命名，原因是不加全限定，他会认为cust_id都是orders表的，即orders.cust_id = orders.cust_id;</span><br><span class="line">	用了全限定命名之后就称为相关子查询了，当然逻辑是因为你涉及外部查询-&gt;不得不提全命名限定</span><br><span class="line">	在customers表中cust_id是唯一的，所以orders.cust_id = customers.cust_id就是用customers的cust_id去订单表匹配cust_id相同的记录</span><br></pre></td></tr></table></figure>


<h1 id="15-联接表"><a href="#15-联接表" class="headerlink" title="15.联接表"></a>15.联接表</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.关系数据库的设计优点</span></span><br><span class="line">现在我想存储商品信息还有商品的供应商信息，如果存在一张表中会造成冗余即大量的空间浪费，我们用一张表只存商品信息，另一张存供应商信息，这个时候我们需要建立这两张表之间的联系，此时我们可以设立外键来建立两张表之间的联系。</span><br><span class="line">我们把供应商id作为供应商表的主键，然后在商品表中设立一列，这一列存放这个商品的供应商id，那么对于商品表来说，供应商id就是他的外键。这样供应商的信息改变只需要需改供应商表就可以的，对与他有关系的其他表没有影响。</span><br><span class="line"><span class="string">&quot;外键&quot;</span>：是表的一列，这一列是数据库中其他表的外键，通过外键来构建表之间的联系</span><br><span class="line">关系数据库优点：关系数据库的可伸缩性比较好，即能适应不断增加的工作量而不失效。</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建联结</span></span><br><span class="line">如下图所示的语句，select子句的列来自于不同的表，from子句之后也是跟着两个要联结的表的表名，两个表根据where的条件进行联结。如果不使用where子句来联结，输出的结果就是两张表的笛卡尔积(表A的每一行都和表B的所有行拼接，生成的结果有很多是没意义且不需要的)。</span><br><span class="line">这里的where条件就是将表vendors的vend_id值和表products的vend_id值相等的行拼接起来(以表的形式看就是生成了一张新表，这个新表每一行= vendors表一行+products表的一行 这种形式),在vendors中vend_id是主键，唯一。</span><br><span class="line"><span class="number">1.</span><span class="string">&quot;联结也不是数据库存在的东西，他们DBMS根据逻辑计算出来的结果&quot;</span></span><br><span class="line"><span class="number">2.</span>这里where条件创建的都是等值联结，根据两个表的值相等建立连接;也称为内部联结</span><br><span class="line"><span class="number">3.</span>还有一种特殊写法也能完成下面图片的同样功能，是inner join语法的</span><br><span class="line">    select vend_name,prod_name,prod_price from vendors inner join products on vendors.vend_id = products.vend_id;</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210129200253411.png" class>

<p>同时还可以联结多个表，如下图所示</p>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210129202119584.png" class>

<p>注意products.vend_id = vendors.vend_id 和后面的那一句才是等值联结的条件，order num = 20005这个是筛选条件，筛选出前两个等值联结条件建立的联接表的行</p>
<h1 id="16-创建高级联结"><a href="#16-创建高级联结" class="headerlink" title="16.创建高级联结"></a>16.创建高级联结</h1><p>除了可以给列、计算字段取别名外，还可以给表取别名，如下图所示</p>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210129205201038.png" class>

<p>使用不同的类型联结：自联结、自然联结、外部链接(上一章是内部联结)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.自联结，如下图所示</span></span><br><span class="line"><span class="number">1.</span>在from子句后面取的别名在前面的select子句就可以用</span><br><span class="line"><span class="number">2.</span>自联结就是两张相同的表联结，因此必须要是使用全限定命名</span><br><span class="line"><span class="number">3.</span>他的速度有时候比一般的子查询速度要快</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210129210601757.png" class>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.自然联结</span></span><br><span class="line">两张表联结的基础就表中存在相同的列，那么普通的等值连接生成联接表中会有多个相同的列,自然联结就是生成的联接表中相同的列只出现一次。但是现在的内部联结基本都是自然联结，也就是把重复列合并了，我们也不要考虑(....😔)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//3.外部联结，见下图</span></span><br><span class="line">内部联结时，表A和表B中相同列值的行联结到一起，但是有时候也想把某张表不相同的行也包含进来，此时就需要外部联结。加入我把A B联结，时把A中列值不相等的行也并入到联接表中，那么在联接表中自然没有与之对应的B表的行的信息，所以在联接表中对应的值就是<span class="literal">NULL</span></span><br><span class="line">    外部联结和内部联结语法相似outer join，但是要加上left或者right，他表示把outer join子句左边的表的列值不相等行加入联接表还是右边。比如下图，左边就是customers表，右边就是orders表</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210129215147411.png" class>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.联结中使用聚集函数，如下图</span></span><br><span class="line">先内部联结生成联接表，然后再对生成的联接表分组，最后再对分组投影计算字段</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210129220059279.png" class>



<h1 id="17-组合查询"><a href="#17-组合查询" class="headerlink" title="17.组合查询"></a>17.组合查询</h1><p>组合查询就是将多条select语句的输出结果结合起来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.使用union关键字创建组合查询</span></span><br><span class="line"><span class="number">1.</span>看情况使用(目前没实战，不清楚)，下面这个例子其实在where条件中用或连接起来也可以</span><br><span class="line"><span class="number">2.</span>两个select语句的结果集是合并到一起输出的(前提是两条语句输出的列是一致的，不然也没意义)，如果两条语句的结果有重复，MYSQL会自动合并，如果不想合并重复就在<span class="class"><span class="keyword">union</span>后面加<span class="title">all</span></span></span><br><span class="line"><span class="class">3.如果要对组合查询结果集排序，那么<span class="title">order</span> <span class="title">by</span>子句应该放在最后一个<span class="title">select</span>语句的后面，也就是只能出现一次。但是放在最后不代表只对最后一个<span class="title">select</span>语句的结果排序，他是回对所有<span class="title">select</span>语句组合到一起的结果排序</span></span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210129221129478.png" class>

<h1 id="18-全文本搜索-了解"><a href="#18-全文本搜索-了解" class="headerlink" title="18.全文本搜索(了解)"></a>18.全文本搜索(了解)</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.理解全文本搜索</span></span><br><span class="line"><span class="number">1.</span>MySQL支持多种数据库引擎，并非所有引擎都支持全文本搜索，Innodb不支持，MyISAM支持。</span><br><span class="line"><span class="number">2.</span>全文本搜索相比于前面说的通配符匹配、正则表达式搜索有以下好处：</span><br><span class="line">	<span class="number">1.</span>通配符匹配和正则表达式搜索需要检索所有的行，所以比较耗时，全文本搜索不需要</span><br><span class="line">	<span class="number">2.</span>通配符匹配和正则表达式搜索很难指定匹配什么，不匹配什么，他们只有和每一行都匹配一下才知道匹不匹配</span><br><span class="line">	<span class="number">3.</span>通配符匹配和正则表达式搜索搜索一个词时，会返回所有含该词的行，而不区分只含一次的行和含多次的行(即多次出现)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.使用全文本搜索</span></span><br><span class="line"><span class="number">1.</span>为了进行全文本搜索，必须对被搜索的列添加索引，而且要随着数据的改变不断地重新索引。在对表列进行适当设计后，MySQL会自动进行所有的索引和重新索引。在索引之后，SELECT可与Match()和Against()一起使用以实际执行搜索。</span><br><span class="line"><span class="number">2.</span>下图是建表时创建索引，在fulltext()语句添加被索引的列，多行用,隔开。</span><br><span class="line"><span class="number">3.</span>可以在创建表时指定FULLTEXT，或者在稍后指定（在这种情况下所有已有数据必须立即索引————目前不懂啥意思）。</span><br><span class="line"><span class="number">4.</span>不要在导入数据时使用FULLTEXT，应该首先导入所有数据，然后再修改表，定义FULLTEXT，这样有助于更快地导入数据</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210130165743603.png" class>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5.在索引之后，使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。如下图，Match(note_text)指示MySQL针对指定的列进行搜索，Against(&#x27;rabbit&#x27;)指定词rabbit作为搜索文本。注意以下几点</span><br><span class="line">	<span class="number">1.</span>搜索文本为中文时多半会失败</span><br><span class="line">	<span class="number">2.</span>传递给Match()的值必须与FULLTEXT()定义中的相同。如果指定多个列，则必须列出它们（而且次序正确）。</span><br><span class="line">	<span class="number">3.</span>搜索不区分大小写 除非使用BINARY方式（本章中没有介绍），否则全文本搜索不区分大小写</span><br><span class="line">	<span class="number">4.</span>全文本搜索的会对结果排序(如果是通配符like匹配，不用order by是不会给你排序的)。具有较高等级的行先返回，而这个等级rank由MySQL根据行中词的数目、唯一词的数目、整个索引中词的总数以及包含该词的行的数目计算出来。。</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210130170234265.png" class>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.使用查询扩展，例子如下图</span></span><br><span class="line">❑ 首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有行；下图就是找出所有包含&#x27;anvils&#x27;的行</span><br><span class="line">❑ 其次，MySQL检查这些匹配行并选择所有有用的词（这个靠mysql发挥）。</span><br><span class="line">❑ 再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还使用上面检索到的所有有用的词来搜索。</span><br><span class="line"></span><br><span class="line">书上的例子：</span><br><span class="line">第一个记录包含词anvils，因此等级最高。第二个记录与anvils无关，但因为它包含第一行中的两个词（customer和recommend），所以也被检索出来(这个就是mysql认为有用的词)。第<span class="number">3</span>行也包含这两个相同的词，但它们在文本中的位置更靠后且分开得更远，因此也包含这一行，但等级为第三。第三行确实也没有涉及anvils（按它们的产品名）。</span><br><span class="line">	查询扩展用来设法放宽所返回的全文本搜索结果的范围。说白了就是返回更多可能的结果而不是只返回和查找文本匹配的结果,但是这些可能的结果不一定有用</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210130175013504.png" class>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.使用布尔文本搜索</span></span><br><span class="line"><span class="number">1.</span> 使用布尔文本搜索可以提供的线索有以下</span><br><span class="line">    ❑ 要匹配的词；</span><br><span class="line">    ❑ 要排斥的词（如果某行包含这个词，则不返回该行，即使它包含其他指定的词也是如此）；</span><br><span class="line">    ❑ 排列提示（指定某些词比其他词更重要，更重要的词等级更高）;</span><br><span class="line">    ❑ 表达式分组；</span><br><span class="line"><span class="number">2.</span> 布尔方式不同于迄今为止使用的全文本搜索语法的地方在于，即使没有定义FULLTEXT索引，也可以使用它。但这是一种非常缓慢的操作（其性能将随着数据量的增加而降低）。</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210130181439859.png" class>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span> 上图就是布尔方式的所有操作符，在下面展示他们的用法</span><br><span class="line">	1. &#x27;heavy -rope*&#x27; :就是匹配所有包含heavy但是不包含任意以repo开头的词(如repos)的行,*是通配符，替代任意多个词</span><br><span class="line">	<span class="number">2.</span> 匹配包含词rabbit和bait的行，两个都必须有。</span><br><span class="line">	<span class="number">3.</span> 没有指定操作符，这个搜索匹配包含rabbit和bait中的至少一个词的行(搜索得到的集合大于加+操作符的)。所以只有一个单词的话加不加+都是无所谓的，不加+他也没得选</span><br><span class="line">	<span class="number">4.</span> 搜索匹配短语rabbit bait而不是匹配两个词rabbit和bait。</span><br><span class="line">	<span class="number">5.</span> 匹配rabbit和carrot，增加前者的等级，降低后者的等级。</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210130181639037.png" class>

<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210130182242164.png" class>

<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210130192639731.png" class>

<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210130193150140.png" class>

<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210130193230814.png" class>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.使用说明</span></span><br><span class="line">❑ 在索引全文本数据时，短词被忽略且从索引中排除。短词定义为那些具有<span class="number">3</span>个或<span class="number">3</span>个以下字符的词（如果需要，这个数目可以更改）。</span><br><span class="line">❑ 许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。因此，MySQL规定了一条<span class="number">50</span>%规则，如果一个词出现在<span class="number">50</span>%以上的行中，则将它作为一个非用词忽略。<span class="number">50</span>%规则不用于IN BOOLEAN MODE。</span><br><span class="line">❑ 如果表中的行数少于<span class="number">3</span>行，则全文本搜索不返回结果（因为每个词或者不出现，或者至少出现在<span class="number">50</span>%的行中）。</span><br><span class="line">❑ 忽略词中的单引号。例如，don<span class="number">&#x27;</span>t索引为dont。</span><br><span class="line">❑ 不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果。</span><br><span class="line">❑ 如前所述，仅在MyISAM数据库引擎中支持全文本搜索。</span><br></pre></td></tr></table></figure>
<h1 id="19-插入数据"><a href="#19-插入数据" class="headerlink" title="19.插入数据"></a>19.插入数据</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.数据插入</span></span><br><span class="line"><span class="number">1.</span>INSERT是用来插入（或添加）行到数据库表的。插入可以用几种方式使用：</span><br><span class="line">	❑ 插入完整的行；</span><br><span class="line">	❑ 插入行的一部分(某些列)；</span><br><span class="line">	❑ 插入多行；</span><br><span class="line">	❑ 插入某些查询的结果。</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.插入一行</span></span><br><span class="line">	insert into grade_info values(&#x27;202000008&#x27;,&#x27;test1&#x27;,&#x27;ios&#x27;,&#x27;74&#x27;,&#x27;12345678&#x27;);//这种方式是使用默认的表中列的定义次序，但是表列的次序可能改变，所以这是不安全的。并且这种方式下除非所有列都可以不填，只有一个列必须要填值，那么你就不能在values里面省去可以不填值的列的值。</span><br><span class="line">	<span class="function">create table <span class="title">test</span><span class="params">(id <span class="keyword">int</span> <span class="keyword">not</span> null auto_increment,name <span class="keyword">char</span>(<span class="number">50</span>) null,primary key(id))</span></span>;</span><br><span class="line">	insert into test values(&#x27;hello&#x27;);//错误，因为按照表列的定义次序，他是有两列的，你这里只给出一列值，不行</span><br><span class="line">	insert into test(name) values(&#x27;hello2&#x27;);//此时只能用第二种方式</span><br><span class="line">	但是如果是所有列都可以不填值，比如下面这张表</span><br><span class="line">	create table test1(id int not null auto_increment,name char(50) not null default &#x27;haha&#x27;,primary key(id))engine = InnoDB;</span><br><span class="line">	<span class="function">insert into test1 <span class="title">values</span><span class="params">()</span></span>;<span class="comment">//此时第一种方式写也可以</span></span><br><span class="line"></span><br><span class="line">	insert into grade_info(score_id,s_name,c_name,grade,s_id)  values(&#x27;202000008&#x27;,&#x27;test1&#x27;,&#x27;ios&#x27;,&#x27;74&#x27;,&#x27;12345678&#x27;);//这样的写法才是安全的，提供了列名，VALUES必须以其指定的次序匹配指定的列名，不一定按各个列出现在实际表中的次序。其优点是，即使表的结构改变，此INSERT语句仍然能正确工作。</span><br><span class="line">	</span><br><span class="line">	如果score_id设置为自增或者允许NULL还可以像下面这样，自增的那一列省略掉，&#x27;所以这个就是插入行的一部分&#x27;</span><br><span class="line">	insert into grade_info(s_name,c_name,grade,s_id)  values(&#x27;test1&#x27;,&#x27;ios&#x27;,&#x27;74&#x27;,&#x27;12345678&#x27;);</span><br><span class="line">	</span><br><span class="line">	插入行时指定列但是又省区了某些列，省去的列要满足以下要求：</span><br><span class="line">	❑ 该列定义为允许<span class="literal">NULL</span>值（<span class="literal">NULL</span>即无值或空值）。</span><br><span class="line">	❑ 在表定义中给出默认值(比如自增)。这表示如果不给出值，将使用默认值。如果对表中不允许<span class="literal">NULL</span>值且没有默认值的列不给出值，则MySQL将产生一条错误消息，并且相应的行插入不成功。</span><br><span class="line">	</span><br><span class="line">	数据库经常被多个客户访问，对处理什么请求以及用什么次序处理是MySQL的任务。INSERT操作可能很耗时（特别是有很多索引需要更新时），而且它可能降低等待处理的SELECT语句的性能。如果数据检索是最重要的（通常是这样），则你可以通过在INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL降低INSERT语句的优先级，insert low_priority into,这也适用于下一章介绍的UPDATE和DELETE语句。</span><br><span class="line">	</span><br><span class="line"><span class="comment">//3.插入多行</span></span><br><span class="line">	可以连着使用多条上面的插入单行的语句组合完成，也可以像下面这样,values后面接多组值，多组值用,隔开</span><br><span class="line">	<span class="function">insert into <span class="title">grade_info</span><span class="params">(s_name,c_name,grade,s_id)</span> </span></span><br><span class="line">	values(&#x27;test1&#x27;,&#x27;ios&#x27;,&#x27;74&#x27;,&#x27;12345678&#x27;)，</span><br><span class="line">	values(&#x27;test2&#x27;,&#x27;ios1&#x27;,&#x27;76&#x27;,&#x27;123456789&#x27;); //这个方式比连续使用多条快</span><br><span class="line">	</span><br><span class="line"><span class="comment">//4.insert与select语句结合</span></span><br><span class="line">	如下图所示，将表Aselect的结果插入到表B中.</span><br><span class="line">    INSERT SELECT中的列名:这个例子在INSERT和SELECT语句中使用了相同的列名。但是，不一定要求列名匹配。事实上，MySQL甚至不关心SELECT返回的列名。它使用的是列的位置，因此SELECT中的第一列（不管其列名）将用来填充表列中指定的第一个列，第二列将用来填充表列中指定的第二个列，如此等等。这对于从使用不同列名的表中导入数据是非常有用的。&#x27;他们抄的列的数量应该要是相同的&#x27;</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210130201755467.png" class>

<h1 id="20-更新与删除数据"><a href="#20-更新与删除数据" class="headerlink" title="20.更新与删除数据"></a>20.更新与删除数据</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.更新数据</span></span><br><span class="line">	<span class="number">1.</span>使用UPDATE语句，用两种方式使用UPDATE：❑ 更新表中特定行；❑ 更新表中所有行。</span><br><span class="line">	<span class="number">2.</span>使用update语句时不要省略WHERE子句,因为稍不注意，就会更新表中所有行。</span><br><span class="line">	<span class="number">3.</span>基本的UPDATE语句由<span class="number">3</span>部分组成，分别是：</span><br><span class="line">		❑ 要更新的表；</span><br><span class="line">		❑ 列名和它们的新值；</span><br><span class="line">		❑ 确定要更新行的过滤条件。</span><br><span class="line">	4.update grade_info set s_name = &#x27;test2&#x27; where s_id = &#x27;1&#x27; and grade = 86;//如果不用where选定行，他会更新所有行的s_name	</span><br><span class="line">     5.update grade_info set s_name = &#x27;test3&#x27;,c_name = &#x27;azhe&#x27; where s_id = &#x27;1&#x27; and grade = 86;//更新多列，用,隔开</span><br><span class="line">     <span class="number">6.U</span>PDATE语句中可以使用子查询，使得能用SELECT语句检索出的数据更新列数据。</span><br><span class="line">     <span class="number">7.</span>为了删除某个列的值，可设置它为<span class="literal">NULL</span>（假如表定义允许<span class="literal">NULL</span>值），如下面这个</span><br><span class="line">     	update grade_info <span class="built_in">set</span> grade = <span class="literal">NULL</span> where grade = <span class="number">82</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.删除数据</span></span><br><span class="line">	<span class="number">1.</span>使用DELETE语句删除行有两种方式：❑ 删除特定行；❑ 删除所有行。</span><br><span class="line">	<span class="number">2.</span><span class="keyword">delete</span>也不要省略where子句，除非你要删所有行。但是如果想从表中删除所有行，不要使用DELETE。可使用TRUNCATE TABLE语句，它完成相同的工作，但速度更快（TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据）。</span><br><span class="line">	<span class="number">3.</span>删除列使用update，<span class="keyword">delete</span>只能以行为单位删除</span><br><span class="line">	4.delete from grade_info where s_id = &#x27;12345678&#x27;;</span><br><span class="line">	<span class="number">5.</span>DELETE语句从表中删除行，甚至是删除表中所有行。但是，DELETE不删除表本身，删除表用drop。</span><br></pre></td></tr></table></figure>


<h1 id="21-创建和操纵表"><a href="#21-创建和操纵表" class="headerlink" title="21.创建和操纵表"></a>21.创建和操纵表</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建表，如下图</span></span><br><span class="line">	<span class="number">1.</span><span class="literal">NULL</span>值就是没有值或缺值。允许<span class="literal">NULL</span>值的列可以在插入行时不给出该列的值，那么插入行的这一列就是没有值，展示给用户为<span class="literal">NULL</span>。不允许<span class="literal">NULL</span>值的列在插入或更新行时，必须要明确给出该列的值。</span><br><span class="line">	<span class="number">2.</span><span class="literal">NULL</span>为默认设置，如果不指定NOT <span class="literal">NULL</span>，则默认指定的是<span class="literal">NULL</span>。</span><br><span class="line">	3.NULL和空串有区别的，空串比如&#x27;&#x27;，他表示有值，但是值为空串，所以not null可以有空串。而NULL是没有值</span><br><span class="line">	<span class="number">4.</span>主键是在最后给出，主键为多列时，可以在()中用,隔开</span><br><span class="line">	<span class="number">5.</span>AUTO_INCREMENT标识这一列是自增，也就是插入一行时，系统将这一列的值自增<span class="number">1</span>,并赋值到插入行中</span><br><span class="line">	<span class="number">6.</span>每个表只允许一个AUTO_INCREMENT列，而且它必须被索引（如，通过使它成为主键，可以通过主键索引快速定位到对应行）。</span><br><span class="line">	<span class="number">7.</span>如果一个列被指定为AUTO_INCREMENT，你在在INSERT语句中指定一个值，只要它是唯一的（至今尚未使用过），该值将被用来替代自动生成的值。后续的增量将在该手工插入的值基础上自增。</span><br><span class="line">	<span class="number">8.</span>可使用last_insert_id()函数获得某表最后一个AUTO_INCREMENT值</span><br><span class="line">	9.cust_city char(50) NOT NULL default &#x27;北京&#x27;, //给一列添加默认值，NOT NULL default和NULL default都可以。</span><br><span class="line">	假设我建立下面这张表</span><br><span class="line">	create table test1(id int not null auto_increment,name char(50) not null default &#x27;haha&#x27;,primary key(id))engine = InnoDB;</span><br><span class="line">	那么我<span class="function">insert into test1 <span class="title">values</span><span class="params">()</span></span>;就可以，因为两列一个<span class="keyword">auto</span> increment,一个有默认值，所以可以都不填</span><br><span class="line">	<span class="number">10.</span>不同的数据库引擎</span><br><span class="line">		❑ InnoDB是一个可靠的事务处理引擎，它不支持全文本搜索；</span><br><span class="line">		❑ MEMORY在功能等同于MyISAM，但由于数据存储在内存（不是磁盘）中，速度很快（特别适合于临时表）；</span><br><span class="line">		❑ MyISAM是一个性能极高的引擎，它支持全文本搜索（参见第<span class="number">18</span>章），但不支持事务处理。</span><br><span class="line">		外键不能跨引擎，即使用一个引擎的表的外键不能是不同引擎的表的主键。</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210130220923532.png" class>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.更新表</span></span><br><span class="line">	alter table test1 drop column name;<span class="comment">//给表删除列</span></span><br><span class="line">	alter table test1 add column age <span class="keyword">int</span>;<span class="comment">//给表添加列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.删除表</span></span><br><span class="line">	drop table test1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.更改表名</span></span><br><span class="line">	rename table test to test3;</span><br></pre></td></tr></table></figure>


<h1 id="22-使用视图"><a href="#22-使用视图" class="headerlink" title="22.使用视图"></a>22.使用视图</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.什么是视图？</span></span><br><span class="line">	首先我们考虑一个场景，如果你需要频繁的使用多张表联接之后的结果，比如频繁的select，那么每次select时要写的代码太多了，比较麻烦，此时我们想要一种类似于编程语言函数一样的东西，向外提供接口，可供我们多次调用。其实，视图就类似于一个向外提供接口的函数，这个函数将sql语句封装起来，可以供我们重复调用。————所以视图主要用来简化我们的查询操作的。</span><br><span class="line">	比如下图这个例子，每次先把表联结之后再筛选联接表这样的语句写起来很长很麻烦，我们可以把创建联接表的sql语句封装成一个函数————即视图。然后每次筛选这个视图就可以了。虽然视图只是对sql语句的封装，但是你可以直接在逻辑上把这个视图看成他封装的sql语句执行后的结果，即一张虚拟表。而且也可以把则个视图当作表来操作。</span><br><span class="line">	之所以称他为虚拟表，是因为他最后是他封装的sql语句执行后的结果，是经过计算的，并不是数据库实实在在的表，他是在数据库中存在的基本表的基础上创建的新关系(一个视图可以是一个或多个基本表计算后的结果)。</span><br><span class="line">	比如下下张图，我们把这个联接表的创建sql语句封装成一个名为productcustomers的视图，可以把这个视图当作一个虚拟表来直接使用。</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210201232725146.png" class>

<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210201235605157.png" class>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.视图的规则与限制</span></span><br><span class="line">	<span class="number">1.</span>视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。</span><br><span class="line">	<span class="number">2.</span>对于可以创建的视图数目没有限制。</span><br><span class="line">	<span class="number">3.</span>为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。</span><br><span class="line">	<span class="number">4.</span>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。(但是视图嵌套会降低查询效率)</span><br><span class="line">	<span class="number">5.</span>ORDER BY可以用在视图中，但如果从该视图检索数据的SELECT语句中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。</span><br><span class="line">	<span class="number">6.</span>视图不能索引，也不能有关联的触发器或默认值。</span><br><span class="line">	<span class="number">7.</span>视图可以和表一起使用。比如将视图的表联结到一起。</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.使用视图</span></span><br><span class="line">	<span class="number">1.</span>视图用CREATE VIEW语句来创建。如下图</span><br><span class="line">	<span class="number">2.</span>使用SHOW CREATE VIEW viewname；来查看创建视图的语句(即视图封装的SQL语句)。</span><br><span class="line">	<span class="number">3.</span>用DROP删除视图，其语法为DROP VIEW viewname;</span><br><span class="line">	<span class="number">4.</span>更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。如果要更新的视图不存在，则第<span class="number">2</span>条更新语句会创建一个视图；如果要更新的视图存在，则第<span class="number">2</span>条更新语句会替换原有视图。</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210202183859707.png" class>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.使用视图的一些骚操作</span></span><br><span class="line">	视图搭配计算字段来控制格式化输出，如下图，将创建格式化输出的计算字段语句封装成一个视图，并且我们也在这里看到了取别名的另一个好处，就是可以在创建成视图之后在视图之外也可以直接使用。</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210202184608371.png" class>

<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210202200651178.png" class>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.更新视图</span></span><br><span class="line">	视图是可以更新的，修改视图会导致最终其关联的基表的值也被改变(同理对基表的修改也会呈现到视图中来)。但是有些情况不能更新视图，情况很多，但是更新视图很少，更多还是用视图来检索数据，所以就不记了。</span><br></pre></td></tr></table></figure>
<h1 id="23-使用存储过程"><a href="#23-使用存储过程" class="headerlink" title="23.使用存储过程"></a>23.使用存储过程</h1><p>mysql命令行创建存储过程实例</p>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210202221606037.png" class>

<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210202221838964.png" class>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.什么是存储过程</span></span><br><span class="line">	当我们做非常复杂的查询时，需要很多条sql语句配合执行，每次键入就很麻烦，所以我们可以将多条sql语句封装成一个函数，以后使用时调用这个函数就可以了，这个函数就称为存储过程。和视图不同的一点就是视图是只用来辅助查询(至少我现在见到的都是这样的)或者说仅包含sql语句，但是存储过程之中可以有多种不同的sql语句以及各种不属于的sq语句的控制流语句。</span><br><span class="line">	</span><br><span class="line"><span class="comment">//2.使用存储过程</span></span><br><span class="line">	因为存储过程是一个函数，所有他和其他编程语言调用函数的方式是相同的。</span><br><span class="line">	<span class="function">call <span class="title">productpricing</span><span class="params">(@low,@high)</span> <span class="comment">//类似于调用函数，同时传递参数，这里相当于传入两个变量进去，函数会对这个变量赋值，但是这里low和high两个变量不需要事先创建，@low这个语句就相当于创建了一个名为low的变量并传入函数。注意就算这个存储过程没有参数，调用时也需要将括号带上，和一般语言的函数调用一样。</span></span></span><br><span class="line"><span class="function">	</span></span><br><span class="line"><span class="function"><span class="comment">//3.创建存储过程</span></span></span><br><span class="line">	如下图所示，begin和end指明了存储过程中包含的sql语句体。在上面的语句还指明了这个存储过程的名字和参数。</span><br><span class="line">	这个存储过程的调用就是<span class="function">call <span class="title">productpricing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span></span><br><span class="line">	还要注意的一点就是如果在mysql的命令行定义存储过程，因为mysql命令行这个程序会存储过程中定义的sql语句的;当成结束分隔符，会导致出现语法错误，所以在命令行定义时要特殊处理。</span><br><span class="line">	delimiter <span class="comment">// 这个delimiter是告诉命令行程序&quot;//&quot;是新的分隔符，当然分隔符可以随便定义，除了\符号</span></span><br><span class="line">	<span class="function">create procedure <span class="title">productpricing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	begin</span></span><br><span class="line"><span class="function">		select <span class="title">Avg</span><span class="params">(pro_price)</span> AS priceaverage from products</span>;</span><br><span class="line">	end <span class="comment">//  这里新定义的分隔符告诉命令行程序存储过程定义到这里结束，之前是使用;作为分隔符的</span></span><br><span class="line">	delimiter ;  这里是将分隔符重新定义为; 因为命令行输入到这里结束，按照惯例还是以;来结束分割</span><br><span class="line">	<span class="string">&quot;这个上面演示的代码不是全部输入在一行的，具体的例子看上面的黑框图，有两种方式&quot;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//4.删除存储过程</span></span><br><span class="line">	和所有的删除一样，drop+类型+存储过程名</span><br><span class="line">     drop procedure productpricing</span><br><span class="line">     注意存储过程和数据库中的表、视图等一样，不能覆盖，只能删了然后重建</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210202205306736.png" class>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.使用参数</span></span><br><span class="line">	如下图所示，我们创建了一个带有参数的存储过程。</span><br><span class="line">    out p1 decimal(8,2)：out定义这个存储过程要传出的一个变量(返回给调用者的返回值)，将来在存储过程的sql语句中可以将select到的结果into到这个变量p1中(相当于在函数内部对返回值取的名字)————总之就是在用out定义了一个变量之后，函数内部就把这个变量名当作一个输出值来看，可以给它赋值。遵循这个参数定义，调用者将变量传进来，存储过程在这里面给它赋值。有点类似于c++的引用传递。decimal(8,2)是指这个结果是一个长度为8位的十进制数，其中小数部分长度为2位。</span><br><span class="line">    <span class="function">call <span class="title">productpricing</span><span class="params">(@low,@high,@avg)</span></span>;对下面定义的这个存储过程调用之后，如果想要使用这些变量可以</span><br><span class="line">    select @low,@high;来直接查看变量的值</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210202211520675.png" class>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如下图，in相当于在函数内部定义了一个输入变量，在函数内部可以直接使用这个输入变量(注意看这个输入变量的类型和out变量类型不相同)。</span><br><span class="line">	比如我们调用函数可以写为<span class="function">call <span class="title">ordertotal</span><span class="params">(<span class="number">2005</span>,@total)</span></span>;</span><br><span class="line">	然后select @total;查看函数处理后的变量值</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210202212653010.png" class>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6.智能存储过程</span></span><br><span class="line">	其实就是在sql语句的基础之上又加入了流程控制语句，如下图</span><br><span class="line">	<span class="number">1.</span>--是存储过程内注释的开头</span><br><span class="line">	<span class="number">2.B</span>OOLEAN就是<span class="keyword">bool</span>类型，非<span class="number">0</span>整数都被当作<span class="literal">true</span></span><br><span class="line">	<span class="number">3.</span>declare也是定义变量，不同于in out是在函数形参中定义的变量，函数体内定义变量就用declare</span><br><span class="line">	<span class="number">4.</span>函数名后面的comment也是注释一样东西，SHOW PROCEDURE STATUS可以看到(这个语句是查看存储过程的所有基本信息)</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.显示存储过程的定义语句</span></span><br><span class="line">     show create procedure ordertotal;<span class="comment">//和查看视图一个样的方式，主要是能看到存储过程的声明和定义体</span></span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210202214213980.png" class>

<h1 id="24-使用游标"><a href="#24-使用游标" class="headerlink" title="24.使用游标"></a>24.使用游标</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.什么是游标cursor</span></span><br><span class="line">	传统的sql语句在检索之后返回的是满足某一条件的结果集，也就是若干行的集合，存放在内存的某一位置。普通的sql语句无法再寻找这若干满足要求的结果集中具体某一行(如果想要操作具体某一行只能根据更多的条件来继续筛选)。这个时候就可以用游标了，他是sql语句返回的结果集(行集)，允许程序对结果集的每一行执行相同或不同的操作，而不是对整个行集合执行同一个操作。</span><br><span class="line">	特点：</span><br><span class="line">	<span class="number">1.</span>不敏感：数据库可以选择不复制结果集</span><br><span class="line">	<span class="number">2.</span>只读</span><br><span class="line">	<span class="number">3.</span>不滚动：游标只能向一方向前进，并且不可以跳过任何一行数据(即只能从第一行开始一行一行的向下寻找)   </span><br><span class="line">	游标的适用场景：</span><br><span class="line">	<span class="number">1.</span>存储过程</span><br><span class="line">	<span class="number">2.</span>函数</span><br><span class="line">	<span class="number">3.</span>触发器</span><br><span class="line">	<span class="number">4.</span>事件</span><br><span class="line">            </span><br><span class="line"><span class="comment">//2.使用游标</span></span><br><span class="line">	使用游标的顺序一般是:声明游标、打开游标、读取数据、关闭游标、删除游标。</span><br><span class="line">	几个注意点</span><br><span class="line">	<span class="number">1.</span>游标定义(声明)之后一定要打开游标来使用(即不能定义着却不用)，当然读取游标的数据之前也需要打开游标</span><br><span class="line">	<span class="number">2.</span>游标定义时其实还没有检索数据</span><br><span class="line">	<span class="number">3.</span>游标结束使用时一定要关闭</span><br><span class="line">	<span class="number">4.</span>mysql的游标只能定义在存储过程里面</span><br><span class="line">	<span class="number">5.</span>游标可以多次打开和关闭</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.创建游标</span></span><br><span class="line">	DECLARE cursor_name CURSOR FOR select_statement  <span class="comment">//在存储过程中除了可以用declare定义变量也可以用declare定义游标。例子如下图</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//4.打开游标</span></span><br><span class="line">	OPEN cursor_name;</span><br><span class="line">	比如OPEN ordernumbers; 打开游标时，会执行游标定义的select语句，并分配内存存放select语句返回的结果</span><br><span class="line">	</span><br><span class="line"><span class="comment">//5.关闭游标</span></span><br><span class="line">	OPEN cursor_name;</span><br><span class="line">	注意如果不主动关闭游标，也会在存储过程的end时系统自动隐含关闭游标，释放游标所占的资源。</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210202225529121.png" class>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6.读取数据</span></span><br><span class="line">	FETCH cursor_name INTO var_name1,var_name2,...;<span class="comment">//从第一行开始读取游标中的行，并写入var_name1,var_name2...中(如果游标中的行有多列)，读完之后游标中的指针指向结果集的下一行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">游标举例</span><br><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> id <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">declare</span> name <span class="type">varchar</span>(<span class="number">100</span>) <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line">    <span class="keyword">declare</span> done <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">-- 声明游标</span></span><br><span class="line">    <span class="keyword">declare</span> mc <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> stuId,stuName <span class="keyword">from</span> student <span class="keyword">where</span> stuAge <span class="operator">&gt;</span><span class="number">19</span>;</span><br><span class="line">    <span class="keyword">declare</span> continue handler <span class="keyword">for</span> <span class="keyword">not</span> found <span class="keyword">set</span> done <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">-- 打开游标</span></span><br><span class="line">    <span class="keyword">open</span> mc;</span><br><span class="line">    <span class="comment">-- 获取结果</span></span><br><span class="line">    <span class="keyword">fetch</span> mc <span class="keyword">into</span> id,name; <span class="comment">--读取第一行的数据到变量中</span></span><br><span class="line">    <span class="comment">-- 这里是为了显示获取结果</span></span><br><span class="line">    <span class="keyword">select</span> id,name;</span><br><span class="line">    <span class="comment">-- 关闭游标</span></span><br><span class="line">    <span class="keyword">close</span> mc;</span><br><span class="line"><span class="keyword">end</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>
<p>更多的例子看 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/oukele/p/10684639.html">https://www.cnblogs.com/oukele/p/10684639.html</a></p>
<h1 id="25-使用触发器"><a href="#25-使用触发器" class="headerlink" title="25.使用触发器"></a>25.使用触发器</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.什么是触发器</span></span><br><span class="line">	<span class="number">1.</span>如果你想要某条SQL语句（或某些语句————比如存储过程）在事件发生时自动执行。比如每当订购一个产品时，都从库存数量中减去订购的数量；此时就需要使用触发器</span><br><span class="line">	<span class="number">2.</span>触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句</span><br><span class="line">	DELETE INSERT；UPDATE。其他MySQL语句不支持触发器。</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建触发器</span></span><br><span class="line">	创建触发器时要给出<span class="number">4</span>点信息：</span><br><span class="line">	<span class="number">1.</span>唯一的触发器名(最好在全数据库范围内使用唯一的触发器名)；</span><br><span class="line">	<span class="number">2.</span>触发器关联的表；</span><br><span class="line">	<span class="number">3.</span>触发器应该响应的活动（DELETE、INSERT或UPDATE）；</span><br><span class="line">	<span class="number">4.</span>触发器何时执行（处理之前或之后————after <span class="keyword">or</span> before）</span><br><span class="line">        </span><br><span class="line">	例子如下:创建一个名为newproduct的触发器，在对products表执行insert事件之后触发，触发器对应的sql语句是select &#x27;Product added&#x27;,即打印一条语句。for each row就说明对每个插入的行都会触发这个触发器</span><br><span class="line">	</span><br><span class="line">	只有表才支持触发器，视图不支持（临时表也不支持）。</span><br><span class="line">     </span><br><span class="line">     创建一个触发器，只能关联一个表(不能和多个表关联)的一个事件，但是after <span class="keyword">delete</span>和before <span class="keyword">delete</span>相当于两个事件,所以每个表最多支持<span class="number">6</span>个触发器（每条INSERT、UPDATE和DELETE的之前和之后）。如果你需要一个对INSERT和UPDATE操作执行的触发器，则应该定义两个触发器.</span><br><span class="line">     </span><br><span class="line">     如果BEFORE触发器失败，则MySQL将不执行请求的操作(触发器包含的sql语句)。此外，如果BEFORE触发器或语句本身失败，MySQL将不执行AFTER触发器（如果有的话）。</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210204182529402.png" class>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.删除触发器</span></span><br><span class="line">	drop trigger newproduct;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//4.使用触发器</span></span><br><span class="line">	关于before和update注意的一点：当你要对某个表要执行某个操作(uodate <span class="keyword">delete</span> insert)，操作执行前DBMS就知道了，也就是DBMS确切知道了将要对这个表执行这个操作。然后他才会在执行这个操作之前触发before触发器(如果有)，在执行这个操作之后触发after触发器。如果压根没有发出相应的操作，before触发器也是不会被触发的(否则他不是一直被触发吗)。</span><br><span class="line">	关于NEW和OLD的注意点：NEW是你insert语句中携带的行数据，OLD是你要更新(更新前)或删除的行的数据。</span><br><span class="line"></span><br><span class="line">	<span class="number">1.</span>insert触发器：</span><br><span class="line">	❑ 在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行；</span><br><span class="line">	❑ 在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值）；</span><br><span class="line">	❑ 对于AUTO_INCREMENT列，NEW在INSERT执行之前包含<span class="number">0</span>，在INSERT执行之后包含新的自动生成值。</span><br><span class="line">	例子如下面第一张图，NEW这个虚表就代表被插入的行，所以这个触发器包含的语句就是选出被插入行的order_num列 </span><br><span class="line">	通常，将BEFORE用于数据验证插入行之前验证数据（目的是保证插入表中的数据确实是需要的数据）。</span><br><span class="line">	</span><br><span class="line">	<span class="number">2.</span><span class="keyword">delete</span>触发器</span><br><span class="line">	❑ 在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表(和NEW类似)，访问被删除的行；</span><br><span class="line">	❑ OLD中的值全都是只读的，不能更新。</span><br><span class="line">	OLD就代表要被删除的行，所以OLD.order_num就是被删除行的对应列，表中任意行被删除前都要执行这个存储过程</span><br><span class="line">	</span><br><span class="line">	<span class="number">3.u</span>pdate触发器</span><br><span class="line">	❑ 在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值；</span><br><span class="line">	❑ 在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）；</span><br><span class="line">	❑ OLD中的值全都是只读的，不能更新。</span><br><span class="line">	下面的例子保证州名缩写总是大写（不管UPDATE语句中给出的是大写还是小写）;</span><br><span class="line">	具体的含义就是，若你将来会对vendors表执行一条update语句，那么在DBMS收到请求之后、执行这个语句之前，会触发before update触发器，这个触发器会将要插入的数据中的vend_state设置为大写，也就是直接修改了待插入的数据，然后再插入。</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210204184412987.png" class>

<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210204185007312.png" class>

<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210204185836887.png" class>

</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">恒若时光</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/01/28/MySQL必知必会读书笔记/">http://example.com/2021/01/28/MySQL必知必会读书笔记/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">恒若时光のblog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><a class="post-meta__tags" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2021/01/27/2021%E6%AF%8F%E6%97%A5%E8%AE%A1%E5%88%92/"><span>2021每日计划</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '152ddcae291378830dfc',
  clientSecret: '303f9a5f5325e6d1dabb9819aac27403b6d03001',
  repo: 'wuhanyi1.github.io',
  owner: 'wuhanyi1',
  admin: 'wuhanyi1',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://desk-fd.zol-img.com.cn/t_s1024x768c5/g5/M00/0A/0C/ChMkJlkml26ISdS6AASb0-G7sfUAAcmwwO6rFEABJvr18.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 By 恒若时光</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>