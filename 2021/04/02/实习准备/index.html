<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="实习准备"><meta name="keywords" content=""><meta name="author" content="恒若时光"><meta name="copyright" content="恒若时光"><title>实习准备 | 恒若时光のblog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E8%AF%AD%E6%B3%95"><span class="toc-text">C++语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">C++11新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Override%E5%92%8Cfinal"><span class="toc-text">Override和final</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Move%E8%AF%AD%E4%B9%89%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-text">Move语义和右值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#auto-ptr"><span class="toc-text">auto_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unique-ptr"><span class="toc-text">unique_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-ptr"><span class="toc-text">shared_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#weak-ptr"><span class="toc-text">weak_ptr</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">lambda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">constexpr常量表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-constexpr%E5%92%8C%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">一. constexpr和常量表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C-constexpr%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88"><span class="toc-text">二.constexpr修饰指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89-constexpr%E4%BF%AE%E9%A5%B0%E5%87%BD%E6%95%B0"><span class="toc-text">三.constexpr修饰函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">常见的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">new和malloc的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-text">内存泄漏和内存溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll%E3%80%81select%E3%80%81poll%EF%BC%88%E4%BC%98%E7%82%B9%E3%80%81%E7%BC%BA%E7%82%B9%E3%80%81%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-text">epoll、select、poll（优点、缺点、实现）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#http"><span class="toc-text">http</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#URI%E5%92%8CURL%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">URI和URL的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E7%BB%AD%E4%B8%8E%E9%9D%9E%E6%8C%81%E7%BB%AD%E8%BF%9E%E6%8E%A5"><span class="toc-text">持续与非持续连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E6%8A%A5%E6%96%87%E7%BB%84%E6%88%90"><span class="toc-text">HTTP报文组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-text">常见请求方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E5%93%8D%E5%BA%94%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">http响应响应状态码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#https"><span class="toc-text">https</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-text">对称加密与非对称加密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E5%8A%A0%E5%AF%86%EF%BC%88%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E8%A2%AB%E7%AA%83%E5%8F%96%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-text">通信加密（解决数据被窃取问题）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%EF%BC%88%E8%A7%A3%E5%86%B3%E8%BA%AB%E4%BB%BD%E4%BC%AA%E8%A3%85%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-text">数字证书（解决身份伪装问题）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%EF%BC%88%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E7%AF%A1%E6%94%B9%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-text">数字签名（解决数据篡改问题）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">HTTPS通信流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%91%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82"><span class="toc-text">第一步：客户端向服务端发起请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%91%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E9%80%81%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="toc-text">第二步：服务器向客户端发送数字证书</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%AA%8C%E8%AF%81%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E3%80%82"><span class="toc-text">第三步：客户端验证数字证书。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BE%97%E5%88%B0%E4%BC%9A%E8%AF%9D%E5%AF%86%E9%92%A5"><span class="toc-text">第四步：服务器得到会话密钥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E6%AD%A5%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86%E4%BC%9A%E8%AF%9D"><span class="toc-text">第五步：客户端与服务端进行加密会话</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http2-0"><span class="toc-text">http2.0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5URL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">输入URL发生了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-UDP"><span class="toc-text">TCP&#x2F;UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98"><span class="toc-text">TCP的若干问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B"><span class="toc-text">Linux服务器编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E6%8C%87%E4%BB%A4%E6%93%8D%E4%BD%9C"><span class="toc-text">Linux指令操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-text">项目遇到的一些问题</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1115959009,3928225272&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">恒若时光</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">4</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">4</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://desk-fd.zol-img.com.cn/t_s1024x768c5/g5/M00/0A/0C/ChMkJlkml26ISdS6AASb0-G7sfUAAcmwwO6rFEABJvr18.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">恒若时光のblog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">类别</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">实习准备</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-02</time><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">13.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 44 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="C-语法"><a href="#C-语法" class="headerlink" title="C++语法"></a>C++语法</h1><h2 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h2><h3 id="Override和final"><a href="#Override和final" class="headerlink" title="Override和final"></a>Override和final</h3><p><strong>首先了解c++中的隐藏、重载、覆盖（重写）的区别</strong></p>
<p><strong>成员函数</strong>被重载的特征：</p>
<ol>
<li><strong>相同的范围，在同一个作用域中，且处于同一级作用域</strong>（这里就是在同一个类中）</li>
<li>函数名字相同；</li>
<li>参数不同；</li>
<li>virtual关键字可有可无。(<strong>同一个类中，virtual不是重载依据</strong>)</li>
</ol>
<a id="more"></a>

<p>成员函数被覆盖是指<strong>派生类函数覆盖基类函数</strong>，特征是：</p>
<ol>
<li>不同的范围（分别位于派生类与基类）；</li>
<li>函数名字相同；</li>
<li>父子类函数参数相同；</li>
<li><strong>基类函数必须有virtual关键字。</strong></li>
</ol>
<p><strong>覆盖是针对虚函数来说的。父类有一个虚函数，子类继承时定义一个和父类虚函数同名且同参数的函数(可以不带static)，此时我们称子类覆盖了基类函数</strong></p>
<p>成员函数被隐藏的特征：</p>
<ol>
<li><p>如果派生类的函数与基类的函数同名，但是<strong>参数不同</strong>。此时，<strong>不论有无virtual关键字</strong>，基类的所有同名函数都将被隐藏（注意别与重载混淆）。</p>
</li>
<li><p>如果派生类的函数与基类的函数同名，并且<strong>参数也相同</strong>，但是基类函数<strong>没有virtual关键字</strong>。此时，基类的函数被隐藏（注意别与覆盖混淆）。</p>
</li>
</ol>
<p>final：可以用来修饰<strong>虚函数</strong>或者类，分别表示派生类不应当覆盖(重写)父类被final修饰的虚函数、被final修饰的类不可被继承。**(非虚函数不能用final标识符修饰)**</p>
<p><strong>类被final修饰，该类不能被继承</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> <span class="keyword">final</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> :</span> A1 &#123; &#125;; <span class="comment">// “B1”: 无法从“A1”继承，因为它已被声明为“final”</span></span><br></pre></td></tr></table></figure>
<p><strong>父类虚函数被final修饰，子类不能重写父类对应的虚函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">final</span> </span>&#123;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> :</span> A1</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//“A1::func”: 声明为“final”的函数无法被“B1::func”重写</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>override：当子类中的虚函数被override修饰时，表示子类应当覆盖(重写)基类中的虚函数。这个可以让编译器帮忙确认父类是否有和”子类中被override修饰的虚函数”相同的函数签名(<strong>virtual不算在函数签名中，所以子类被override修饰的虚函数没有virtual也可以</strong>)，没有相同签名说明子类没有重写父类的虚函数(<strong>即函数参数或名字写错了</strong>)。可以防止因疏忽把本来的想重写的基类的虚函数在派生类中声明为隐藏。(<strong>override也不可以修饰非虚函数</strong>)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">double</span> b, <span class="keyword">bool</span> c)</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">double</span> b, <span class="keyword">bool</span> c)</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">bool</span> z)</span> <span class="keyword">override</span></span>&#123;&#125;;<span class="comment">//错误，父类没有找到相同的函数签名</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    Derived d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Move语义和右值引用"><a href="#Move语义和右值引用" class="headerlink" title="Move语义和右值引用"></a>Move语义和右值引用</h3><p>Move语义就是类中实现了偷取右值对象内容的一种成员函数</p>
<p><strong>左值、右值：</strong></p>
<p>​        在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为<strong>纯右值</strong>、<strong>将亡值</strong>。在c++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。举个例子，int a = b+c, a 就是左值，其有变量名为a，通过&amp;a可以获取该变量的地址；<strong>表达式</strong>b+c、<strong>函数</strong>int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。</p>
<p><strong>纯右值、将亡值：</strong></p>
<p>​        在理解C++11的右值前，先看看C++98中右值的概念：C++98中右值是纯右值，纯右值指的是临时变量值、不跟对象关联的字面量值。临时变量指的是<strong>非引用返回</strong>的函数返回值、表达式(<strong>由类对象组成的表达式也是右值</strong>)等(<strong>其实类的临时对象应该是属于临时变量的，当右值，但是编译器会把它当作左值，所以这里我们不要考虑类的临时对象</strong>)，例如函数int func()的返回值，表达式a+b；不跟对象关联的字面量值，例如true，2，”C”等。</p>
<p>​        C++11对C++98中的右值进行了扩充。在C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）。其中纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和不跟对象关联的字面量值；将亡值则是C++11新增的<strong>跟右值引用相关的表达式</strong>，这样表达式通常是将要被移动的对象（移为他用），比如返回<strong>右值引用T&amp;&amp;的函数返回值</strong>、<strong>std::move的返回值</strong>，或者转换为T&amp;&amp;的类型转换函数的返回值。</p>
<p>​        将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值(<strong>盗取即让对方和其关联的内存断开联系，然后我来和这块内存建立联系</strong>)。但是必须确保其他变量不再被使用、或即将被销毁时(<strong>也可以用std::move(左值)将变量强制转换为右值，告诉编译器这个左值变量不再被使用</strong>)，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。</p>
<p><strong>左值引用、右值引用：</strong></p>
<p>​        左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值对象(<strong>纯右值或将亡值</strong>)进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。</p>
<p>​        右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存(<strong>引用不会被分配内存</strong>)，只是该对象的一个别名。左值引用是<strong>具名变量</strong>的别名，而右值引用则是<strong>不具名（匿名）变量</strong>的别名。</p>
<p>​        左值引用不能绑定到右值对象上，右值引用也不能绑定到左值对象上。<br>​    <strong>例外</strong>：如果<strong>左值引用</strong>是const类型的，则其可以绑定到右值对象上。</p>
<p>​        左值引用通常也不能绑定到右值，但<strong>常量左值引用是个“万能”的引用类型</strong>。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值引用只能接受非常量左值对其进行初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;a = <span class="number">2</span>;       # 左值引用绑定到右值，编译失败</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;        # 非常量左值</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;c = b; # 常量左值引用绑定到非常量左值，编译通过</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> d = <span class="number">2</span>;  # 常量左值</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;e = c; # 常量左值引用绑定到常量左值，编译通过</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;b =<span class="number">2</span>;  # 常量左值引用绑定到右值，编程通过</span><br></pre></td></tr></table></figure>
<p>​        右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，需要**std::move()**将左值强制转换为右值，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r1 = c;             <span class="comment">// 编译失败</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r2 = <span class="built_in">std</span>::move(a);  <span class="comment">// 编译通过</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r3 = <span class="number">3</span>;             <span class="comment">// 编译通过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; b = a;</span><br><span class="line"><span class="keyword">int</span>&amp; c = a;<span class="comment">//左值引用可以指向左值引用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​        右值引用变量是个左值，而右值引用只能指向右值对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; k = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; c = k; <span class="comment">//error，右值引用不能指向右值引用变量(右值引用变量是个左指)，只能指向右值对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int&amp; &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int&amp;&amp; &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;</span><br><span class="line">	func(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">2</span>; </span><br><span class="line">	<span class="keyword">int</span>&amp;&amp; b = <span class="number">2</span>;<span class="comment">//b这个右值引用变量是个左值</span></span><br><span class="line">	func(a);<span class="comment">//int&amp; </span></span><br><span class="line">	func(b);<span class="comment">//int&amp; ,因为右值引用变量是个左指</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        由于右值引用只能绑定到右值对象上，而右值对象又是短暂的、即将销毁的。也就是说右值引用有一个重要性质：只能绑定到即将销毁的对象上。只要能够绑定右值的引用类型，都能够延长右值的生命期。</p>
<p><strong>右值引用一般和移动拷贝构造函数、移动赋值函数搭配在一起使用，主要是解决部分容器扩张时的效能问题，比如vector会动态增长，当获得一片新的内存时，要把原先内存的值拷贝过去，如果调用拷贝构造函数开销会比较大。而用移动拷贝构造函数，只需要修改指针，开销比较小。还有就是deque如果在中间插入这种情况，移动拷贝构造也能减小开销。其他的容器不会涉及到容器元素挪动，性能上影响不太大</strong></p>
<p>在C++11中，拷贝/移动构造函数实际上有以下3个版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type(T &amp;)</span><br><span class="line">type(<span class="keyword">const</span> T &amp;)</span><br><span class="line">type(T&amp;&amp;)<span class="comment">//移动拷贝构造不能是const的，否则他无法偷取内存</span></span><br></pre></td></tr></table></figure>
<p>举例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> CCtor;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init_data</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">		data = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">memcpy</span>(data, s, len);</span><br><span class="line">		data[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	MyString(<span class="keyword">const</span> <span class="keyword">char</span>* str):len(<span class="built_in">strlen</span>(str)) &#123;</span><br><span class="line">		init_data(str);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//左值引用拷贝构造函数,深拷贝</span></span><br><span class="line">	MyString(<span class="keyword">const</span> MyString&amp; str):len(str.len) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Ctor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		init_data(str.data);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//右值引用拷贝构造函数,偷右值的内容。也称为移动构造函数</span></span><br><span class="line">	MyString(MyString&amp;&amp; str)<span class="keyword">noexcept</span> :len(str.len) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Move Ctor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		data = str.data;</span><br><span class="line">		str.len = <span class="number">0</span>;</span><br><span class="line">		str.data = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~MyString() &#123;</span><br><span class="line">		<span class="comment">//右值引用拷贝构造函数会将临时对象的指针断开，把指针置为空，所以临时对象析构时要检查指针是否已为空</span></span><br><span class="line">		<span class="keyword">if</span> (data != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span>[] data;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span>* data;</span><br><span class="line">	<span class="keyword">size_t</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">MyString <span class="title">str</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">	MyString s1 = MyString(str);<span class="comment">//类的临时对象比较特殊，被编译器当作左值处理的，一般不需要考虑</span></span><br><span class="line">	MyString s2 = <span class="built_in">std</span>::move(str);<span class="comment">//将左值转换为右值，调用移动构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>完美转发</strong></p>
<p><strong>forward的作用</strong></p>
<p>std::forward被称为<strong>完美转发</strong>，它的作用是保持原来的<code>值</code>属性不变。啥意思呢？通俗的讲就是，如果原来的值是左值，经std::forward处理后该值还是左值；如果原来的值是右值，经std::forward处理后它还是右值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int&amp; &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int&amp;&amp; &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;</span><br><span class="line">	func(i);<span class="comment">//调用的的是int&amp;，因为右值引用变量i是个左值，而我们原本想转发的变量是个右值，所以这是个不完美转发。我们想调用的是int&amp;&amp;版本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;</span><br><span class="line">	func(<span class="built_in">std</span>::forward&lt;<span class="keyword">int</span>&gt;(i));<span class="comment">//使用std::forward&lt;T&gt;(variable)，这个就是将变量完美转发，保持原有变量的属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">	func(a);<span class="comment">//int&amp;</span></span><br><span class="line">	func(<span class="number">1</span>);<span class="comment">//int&amp;&amp;</span></span><br><span class="line">	forward(<span class="number">2</span>);<span class="comment">//int&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p><a target="_blank" rel="noopener" href="https://avdancedu.com/9683d88/">https://avdancedu.com/9683d88/</a>  </p>
<h4 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h4><p>​        C++98的auto_ptr，不支持多个auto_ptr指向同一块堆区空间。当将一个auto_ptr赋值给另一个auto_ptr时，让原来的auto_ptr(赋值者)指向空地址（nullptr)，新的auto_ptr指向堆空间。</p>
<h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><p>​        unique_ptr为了解决auto_ptr的问题，阻止了指针对于堆区空间的传递性。它将其拷贝构造函数及赋值操作符全部隐藏起来，即不允许智能指针之间的拷贝或者赋值，这样就不会有auto_ptr的问题了。</p>
<p>​        但是unique_ptr可以对右值进行转移，即提供了<strong>但提供了移动语义</strong>。即允许将声明为右值的unique_ptr的数据移动到当前unique_ptr中。</p>
<h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><p>​        共享智能指针的特点就是有一个指向引用计数器变量的指针，当对智能指针进行拷贝或者赋值时，会对引用计数进行修改。只有当智能指针的引用计数变为0时，才允许对堆区空间进行释放。</p>
<p>智能指针类将一个计数器类与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。</p>
<ol>
<li>每次创建指针类的新对象时，初始化指针并将引用计数置为1；</li>
<li>当指针对象初始化另一个指针对象时，拷贝构造函数拷贝指针并增加与之相应的引用计数；</li>
<li>对一个指针对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；</li>
<li>调用指针析构函数时，减少引用计数（如果引用计数减至0，则删除所指基础对象）。</li>
</ol>
<p>​        下面是自定义的共享智能指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">share_ptr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//即使是空指针，引用计数也为1。为了以后析构不出问题</span></span><br><span class="line">	share_ptr(T* ptr = <span class="literal">nullptr</span>) :_ptr(ptr),count(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	share_ptr(share_ptr&lt;T&gt;&amp; p):_ptr(p._ptr),count(p.count) &#123;</span><br><span class="line">		(*count)++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T* <span class="keyword">operator</span>-&gt; () &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">		<span class="keyword">return</span> *_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝赋值函数</span></span><br><span class="line">	share_ptr&amp; <span class="keyword">operator</span>=(share_ptr&lt;T&gt;&amp; p) &#123;</span><br><span class="line">		<span class="comment">//1.断开原有连接</span></span><br><span class="line">		--(*count);</span><br><span class="line">		release();</span><br><span class="line">		<span class="comment">//2.和新的指针建立连接</span></span><br><span class="line">		count = p.count;</span><br><span class="line">		(*count)++;</span><br><span class="line">		_ptr = p._ptr;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放只能指针指向的堆区空间和引用计数指向的堆区空间</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (*count == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;堆区空间被释放&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">delete</span> count;</span><br><span class="line">			<span class="keyword">delete</span> _ptr;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前指针引用计数为：&quot;</span> &lt;&lt; *count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~share_ptr() &#123;</span><br><span class="line">		<span class="comment">//如果引用计数为0，则释放堆区空间</span></span><br><span class="line">		--(*count);</span><br><span class="line">		release();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span>* count;</span><br><span class="line">	T* _ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>共享智能指针存在的问题：当场景为<strong>循环引用</strong>时，会存在内存泄漏问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;B&gt; p_b;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;A&gt; p_a;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">share_ptr&lt;A&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line">		<span class="function">share_ptr&lt;B&gt; <span class="title">b</span><span class="params">(<span class="keyword">new</span> B)</span></span>;</span><br><span class="line">		a-&gt;p_b = b;<span class="comment">//b的引用计数变为2，b中的p_a原先指向的空间已经被析构</span></span><br><span class="line">		b-&gt;p_a = a;<span class="comment">//a的引用计数为2，a中的p_b原先指向的空间已经被析构</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当程序结束时，b先析构，b析构时会将引用计数-1，此时b的引用计数变为1，所以此时不会去释放b指向的那块堆区内存空间，而b指向的那块堆区内存空间中存放的是一个B类对象，这个B类对象有一个智能指针p_a。他的智能指针指向的是变量a的堆区内存空间。所以如果b指向的这块堆区空间不释放就会导致a的堆区引用计数至少为1.所以a的堆区得不到释放。同理a的堆区得不到释放，就会还有一个只能指针指向b的堆区，所以b的堆区也永远不会被释放。</span></span><br></pre></td></tr></table></figure>


<h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><p>​        weak_ptr就是专门为了解决这个问题而出现的。实际上weak_ptr不能单独称为一个智能指针，它必须与一个shared_ptr关联然后一起使用，起到辅助share_ptr的作用，不能直接指向一个堆区对象。辅助类weak_ptr的数据成员是一个<strong>计数器类指针</strong>和一个<strong>基础对象指针</strong>。</p>
<p>​        我们分析一下问题：上面shared_ptr的内存泄漏是因为两个指针的引用计数都为2。所以我们只需要让每个a和b这两个指针的引用计数都是1就可以了。这样就能正常释放堆区空间，但是b中的p_a也指向了a所指向的堆区内存空间，我们的原本循环引用的目的是想也可以通过b中的p_a访问a堆区的内存空间。</p>
<p>​        所以我们总结需求就是在b-&gt;p_a = a的同时又不想增加a堆区的引用计数，因此我们提出了weak_ptr，引出weak_ptr之后，每个shared_ptr对象将记录两个引用，一个是原本的shared_ptr引用，我们也称为强引用，还有一个就是新提出的weak_ptr引用，也称为弱引用。将p_a定义为weak_ptr类型，<code>weak_ptr&lt;A&gt; p_a</code> ;b-&gt;p_a = a时不会增加a的强引用计数，但是会增加a的弱引用计数。弱引用计数对shared_ptr管理的堆区释放没有影响。</p>
<p>​        当我们想通过弱指针访问他关联的强指针堆区时，可以通过lock函数将其转换为强指针来访问。</p>
<p><strong>说白了弱指针就是提供了另一种可以访问强指针管理的堆区的方法，同时还不会影响共享强指针管理空间的计数。比如说堆区空间是个房子，强指针就是进出这个房子的钥匙，多个强指针就是多个不同的钥匙，他们都可以进入这个房子。而弱指针就是配了一把假钥匙，也可以访问房子。但是统计局不会记录假钥匙，当一个强指针被析构，真钥匙就销毁一把，当统计局记录到真钥匙全部被销毁时，直接炸了房子，根本不管假钥匙。所以假钥匙要访问房子时还是检查房子是否被炸了，也就是用expired检查房子还在不在。所以我么感觉weak_ptr的计数没什么用</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Counter():s(<span class="number">0</span>),w(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> s; <span class="comment">//存放share_ptr引用计数，称为强指针引用计数</span></span><br><span class="line">        <span class="keyword">int</span> w; <span class="comment">//存放weak_ptr引用计数，称为弱指针引用计数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">WeakPtr</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SharedPtr &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//friend class WeakPtr&lt;T&gt;;</span></span><br><span class="line">        <span class="keyword">void</span> _release()&#123;</span><br><span class="line">            _cnt-&gt;s--;</span><br><span class="line">            <span class="comment">//还是根据shared_ptr计数决定是否释放堆区空间，我认为这里可以直接由强指针把堆区的计数对象给释放了，弱指针脱离强指针就没什么用了。</span></span><br><span class="line">            <span class="keyword">if</span>(_cnt-&gt;s &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">                <span class="keyword">if</span>(_cnt-&gt;w &lt;<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">delete</span> _cnt;</span><br><span class="line">                    _cnt=<span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T * _ptr;</span><br><span class="line">        Counter * _cnt;<span class="comment">//两个引用计数，一个指向强指针，一个指向弱指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakPtr</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        WeakPtr():_ptr(<span class="literal">nullptr</span>), _cnt(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        ~WeakPtr()&#123;</span><br><span class="line">            _release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakPtr(WeakPtr&lt;T&gt; &amp; weakptr):_ptr(weakptr._ptr), _cnt(weakptr._cnt)&#123;</span><br><span class="line">            _cnt-&gt;w++;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">/*强指针拷贝构造弱指针，同样是指向相同的堆区空间，但是不增加shared_ptr的引用计数*/</span></span><br><span class="line">        WeakPtr(SharedPtr&lt;T&gt; &amp; sharedptr):_ptr(sharedptr._ptr), _cnt(sharedptr._cnt)&#123;</span><br><span class="line">            _cnt-&gt;w++;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//弱指针赋值给weak_ptr，不增加shared_ptr引用计数</span></span><br><span class="line">        WeakPtr &amp; <span class="keyword">operator</span>=(WeakPtr&lt;T&gt; &amp; weakptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;weakptr)&#123;</span><br><span class="line">                _release();</span><br><span class="line">                _ptr = weakptr._ptr;</span><br><span class="line">                _cnt = weakptr._cnt;</span><br><span class="line">                _cnt-&gt;w++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//强指针赋值给weak_ptr，不增加shared_ptr计数</span></span><br><span class="line">        WeakPtr &amp; <span class="keyword">operator</span>=(SharedPtr&lt;T&gt; &amp; sharedptr)&#123;</span><br><span class="line">            _release();</span><br><span class="line">            _ptr = sharedptr._ptr;</span><br><span class="line">            _cnt = sharedptr._cnt;</span><br><span class="line">            _cnt-&gt;w++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//弱指针提升为shared_ptr</span></span><br><span class="line">        <span class="function">SharedPtr&lt;T&gt; <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> SharedPtr&lt;T&gt;(*<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//判断该指针是否为空，即检测对象空间是否被释放</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">expired</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(_cnt &amp;&amp; _cnt-&gt;s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;empty &quot;</span>&lt;&lt;_cnt-&gt;s&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//friend class SharedPtr&lt;T&gt;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">void</span> _release()&#123;</span><br><span class="line">            <span class="keyword">if</span>(_cnt)&#123;</span><br><span class="line">                _cnt-&gt;w--;<span class="comment">//析构时weak_ptr计数-1</span></span><br><span class="line">                <span class="keyword">if</span>(_cnt-&gt;w &lt; <span class="number">1</span> &amp;&amp; _cnt-&gt;s &lt;<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">delete</span> cnt;</span><br><span class="line">                        _cnt=<span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T * _ptr;</span><br><span class="line">        Counter * _cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    WeakPtr&lt;Node&gt; _prev;</span><br><span class="line">    WeakPtr&lt;Node&gt; _next;</span><br><span class="line"></span><br><span class="line">    ~Node()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;delete :&quot;</span> &lt;&lt;<span class="keyword">this</span>&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">SharedPtr&lt;Node&gt; <span class="title">cur</span><span class="params">(<span class="keyword">new</span>(Node))</span></span>;</span><br><span class="line">    <span class="function">SharedPtr&lt;Node&gt; <span class="title">next</span><span class="params">(<span class="keyword">new</span>(Node))</span></span>;</span><br><span class="line">    cur-&gt;_next = next;<span class="comment">//next堆区空间的shared_ptr计数仍为1，weak_ptr计数也为1</span></span><br><span class="line">    next-&gt;_prev = cur;<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shared_ptr的代码主要做出了如下修改</p>
<ol>
<li>以前只有一个计数变量，然在变成了两个(成了一个计数器)，一个是SharedPtr本身的计数，另一个是WeakPtr的计数；</li>
<li><code>_ptr</code>和<code>_cnt</code>的释放都是在SharedPtr中完成的，WeakPtr不做具体的释放工作。</li>
</ol>
<p>​        当一个weak_ptr所观察的shared_ptr要释放它的资源时，它会把相关的weak_ptr的指针设置为空，防止weak_ptr持有悬空的指针。</p>
<p>​        weak_ptr并不拥有资源的所有权，所以不能直接使用资源。</p>
<p>​        weak_ptr并没有重载-&gt; 和 * 操作符，所以我们不能通过他来直接使用资源，我们可以通过lock来获得一个shared_ptr对象来对资源进行使用，如果引用的资源已经释放，lock()函数将返回一个存储空指针的shared_ptr。 所以我们要在使用前用expired函数用来判断资源是否失效。    </p>
<p>​        另外在WeakPtr中仅会对Counter对象的w字段操作，也就是说多个weak_ptr指向同一个堆空间时，<strong>仅操作Counter中的w字段。</strong></p>
<ol>
<li>weak_ptr虽然是一个模板类，但是不能用来直接创建指向堆区的对象。即不能单独使用</li>
<li>weak_ptr设计之初就是为了服务于shared_ptr的，所以不增加shared_ptr引用计数就是它的核心功能。</li>
<li>不允许weak_ptr到shared_ptr的转换</li>
<li>由于不知道什么之后weak_ptr所指向的对象就会被析构掉，所以使用之前请先使用expired函数检测一下。</li>
</ol>
<p><strong>一句话总结，weak_ptr这个辅助类就是专门为解决循环引用提出的，循环引用是想通过引用指针也可以访问shared_ptr记录的堆区空间，但是又不会增加shared_ptr的引用计数。</strong></p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>lambad其实就是一种匿名函数类型,基本形式如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture <span class="built_in">list</span>](parameter <span class="built_in">list</span>) <span class="keyword">mutable</span>-&gt; <span class="keyword">return</span> type &#123;statement&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>[capture list]：捕捉列表。捕捉列表总是出现在lambda函数的开始处。事实上，**[]是lambda引出符<strong>。编译器根据该引出符判断接下来的代码是否是lambda函数(**所以[]不可省略</strong>)。捕捉列表能够捕捉上下文中的变量以供lambda函数使用。</li>
<li>(parameters list)：参数列表。与普通函数的参数列表一致。如果不需要参数传递，则<strong>可以连同括号()一起省略。</strong></li>
<li>mutable：默认情况下，lambda函数总是一个const函数，即不能对其捕获的上下文变量修改，无论是值传递方式捕获还是引用传递方式捕获。mutable可以取消其常量性。在使用该修饰符时，**参数列表不可省略，即使参数为空，也要加()**，里面可以不写参数。</li>
<li><code>-&gt;return type</code>：返回类型。用追踪返回类型形式声明函数的返回类型。出于方便，<strong>不需要返回值的时候也可以连同符号-&gt;一起省略。</strong>此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。</li>
<li>{statement}：函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。不能省略</li>
</ul>
<p>语法上，<strong>捕捉列表由多个捕捉项组成</strong>，并以逗号分割。捕捉列表有如下几种形式：</p>
<p>❑ [var]表示值传递方式捕捉变量var。</p>
<p>❑ [=]表示值传递方式捕捉所有父作用域的变量（包括this）。</p>
<p>❑ [&amp;var]表示引用传递捕捉变量var。</p>
<p>❑ [&amp;]表示引用传递捕捉所有父作用域的变量（包括this）。</p>
<p>❑ [this]表示值传递方式捕捉当前的this指针。</p>
<p>通过一些组合，捕捉列表可以表示更复杂的意思。比如：</p>
<p>❑ [=, &amp;a, &amp;b]表示以引用传递的方式捕捉变量a和b，值传递方式捕捉其他所有变量。</p>
<p>❑ [&amp;, a, this]表示以值传递的方式捕捉变量a和this，引用传递方式捕捉其他所有变量。</p>
<p><strong>但是不可以对一个变量进行两次相同方式的捕获，如下</strong></p>
<p>❑ [=, a]这里=已经以值传递方式捕捉了所有变量，捕捉a重复。</p>
<p>❑ [&amp;, &amp;this]这里&amp;已经以引用传递方式捕捉了所有变量，再捕捉this也是一种重复。</p>
<p>下面是几个例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[]&#123;&#125;;  <span class="comment">//最简单的表达式</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	[a]()<span class="keyword">mutable</span> &#123;<span class="comment">//值传递捕获不会对捕获的母值修改</span></span><br><span class="line">		a++;<span class="comment">//有mutable才能对捕获的值进行修改</span></span><br><span class="line">	&#125;();<span class="comment">//这是个函数类型，如果想直接调用就可以在类型后面直接加参数就可以了 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">auto</span> f = [=]()<span class="keyword">mutable</span> -&gt;<span class="keyword">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;;<span class="comment">//自动推导出匿名函数类型</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; f() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        必须指出的是，依照现行C++11标准，在块作用域({}括住的就是块作用域)以外(比如全局作用域)的lambda函数<strong>捕捉列表必须为空</strong>，并且不能只以匿名函数形式存在(不能在全局作用域光秃秃的写一个lambda表达式)，一般需要auto func = lambda表达式。</p>
<p>​        而在块作用域中的lambda函数仅能捕捉父作用域中的自动变量，捕捉任何非父作用域或者是非自动变量（如静态变量等）都会导致编译器报错。在现行C++11标准中，捕捉列表仅能捕捉父作用域的自动变量，而对超出这个范围的变量，是不能被捕捉的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	[a] &#123;&#125;;<span class="comment">//error，不能捕获静态变量</span></span><br></pre></td></tr></table></figure>
<p>​        所有<strong>lambda在声明时就确定了初始状态，即声明时就将捕获的变量确定了，且拷贝的值不可被更改。之后的每次调用相同的lambda表达式时，他们的初始状态都是相同的。这一点主要针对值传递捕获</strong>，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> f1 = [a]&#123;<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;&#125;;<span class="comment">//值传递，声明时确定了a的值就是1，所以lambda表达式初始状态a = 1</span></span><br><span class="line">	<span class="keyword">auto</span> f2 = [&amp;a]&#123;<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">	a += <span class="number">1</span>;</span><br><span class="line">	f1();<span class="comment">//1，因为lambda初始状态已被确定</span></span><br><span class="line">	f2();<span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两点需要程序员注意之外，还有一点就是拷贝本身。这点跟函数参数按值方式传递是一样的，如果不想带来过大的传递开销的话，可以<strong>采用引用传递的方式传递参数。</strong></p>
<p>lambda函数可以看成仿函数的一种语法糖，而lambda的捕获列表就类似于仿函数类中成员变量。一般编译器会把lambda表达式转换成一个仿函数对象</p>
<h3 id="constexpr常量表达式"><a href="#constexpr常量表达式" class="headerlink" title="constexpr常量表达式"></a>constexpr常量表达式</h3><p><strong>所有constexpr对象都是const的，但是不是所有的const对象都是constexpr的。比如有const的类对象，但是const的类对象不是常量表达式</strong></p>
<h4 id="一-constexpr和常量表达式"><a href="#一-constexpr和常量表达式" class="headerlink" title="一. constexpr和常量表达式"></a>一. constexpr和常量表达式</h4><p>　　常量表达式（const expression）是指<strong>值不会改变</strong>并且在<strong>编译过程就能得到计算结果的表达式</strong>。显然，字面值属于常量表达式，用<strong>常量表达式初始化的const对象也是常量表达式。</strong></p>
<p>　　一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_files = <span class="number">20</span>;       <span class="comment">// max_files是常量表达式  </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> limit = max_files + <span class="number">1</span>;    <span class="comment">// limit是常量表达式  </span></span><br><span class="line"><span class="keyword">int</span> staff_size = <span class="number">27</span>;                <span class="comment">// staff_size不是常量表达式  </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sz = get_size();      <span class="comment">// sz不是常量表达式 </span></span><br></pre></td></tr></table></figure>

<p>　　尽管staff_size的初始值是个字面值常量，但由于它的数据类型只是一个普通int而非const int，所以它不属于常量表达式。另一方面，尽管sz本身是一个常量，但它的具体值直到运行时才能获取到，所以也不是常量表达式。</p>
<p>　　C++11新标准引出了关键字constexpr，constexpr可以用来修饰变量、函数、构造函数，这些我们都称为表达式。constexpr修饰一个表达式相当于告诉编译器这个表达式就是一个<strong>常量表达式(值不可修改)**，表达式的值编译期间就可以算出来，给编译器自信去优化，在编译期间计算出值。当然，</strong>常量表达式的值也确实要是编译期间能算出来的值。**</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf = <span class="number">20</span>;          <span class="comment">// 20是常量表达式  </span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> limit = mf + <span class="number">1</span>;   <span class="comment">// mf + 1是常量表达式  </span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sz = size();      <span class="comment">// 只有当size是一个constexpr函数时才是一条正确的声明语句 </span></span><br></pre></td></tr></table></figure>
<p>​        <strong>被constexpr修饰的变量类型必须有所限制</strong>，因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为”字面值类型”（literal type）。到目前为止接触过的数据类型中， 内置数据类型、引用和指针都属于字面值类型。自定义类Sales_item、IO库、string类型则不属于字面值类型，<strong>也就不能被定义成constexpr</strong>。</p>
<h4 id="二-constexpr修饰指针"><a href="#二-constexpr修饰指针" class="headerlink" title="二.constexpr修饰指针"></a>二.constexpr修饰指针</h4><p>​        尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。</p>
<p>　　值得一提的是，函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针。同样，允许函数定义一类有效范围超出函数本身的变量（即局部静态变量），这类变量和定义在函数体之外的变量一样也有固定地址。因此，constexpr引用能绑定到这样的变量上，constexpr指针也能指向这样的变量。</p>
<p>​        指针和constexpr必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">nullptr</span>;         <span class="comment">// p是常量的指针  </span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *q = <span class="literal">nullptr</span>;     <span class="comment">// q指针本身是个常量表达式，也就是指向不能改变</span></span><br></pre></td></tr></table></figure>

<p>　　p和q的类型相差甚远，p是一个指向常量的指针，而q是一个常量指针，其中的关键在于constexpr把它所定义的对象置为了顶层const。</p>
<p>​        与其他常量指针类似，constexpr指针既可以指向常量也可以指向一个非常量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *np = <span class="literal">nullptr</span>;    <span class="comment">// np是一个指向整数的常量指针，其值为空  </span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> i = <span class="number">42</span>;       <span class="comment">// i的类型是整型常量  </span></span><br><span class="line"><span class="comment">// i和j都必须定义在函数体之外  </span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;i;    <span class="comment">// p 是常量指针，指向整型常量i  </span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *p1 = &amp;j;         <span class="comment">// p1是常量指针，指向整数j </span></span><br></pre></td></tr></table></figure>
<h4 id="三-constexpr修饰函数"><a href="#三-constexpr修饰函数" class="headerlink" title="三.constexpr修饰函数"></a>三.constexpr修饰函数</h4><p>​        constexpr修饰的函数，简单的来说，如果其传入的参数可以在编译时期计算出来，那么这个函数就会产生编译时期的值，此时这个函数是<strong>常量表达式</strong>。但是，传入的参数如果不能在编译时期计算出来，那么constexpr修饰的函数就和普通函数一样了，此时不是常量表达式。所以constexpr修饰的函数可以是常量表达式，也可以不是。取决于你传入的值是否为常量表达式。(<strong>但是constexpr函数一定要有返回值</strong>)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> <span class="title">scale</span><span class="params">(<span class="keyword">size_t</span> cnt)</span></span>&#123;<span class="keyword">return</span> new_sz() * cnt;&#125;</span><br><span class="line"></span><br><span class="line">当形参cnt传递过来的是一个常量时，scale函数才会返回一个常量表达式。</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[scale(<span class="number">2</span>)];<span class="comment">//正确，返回的是一个常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">2</span>; <span class="keyword">int</span> a2[scale(i)];<span class="comment">//错误，传递的是非常量，所以函数也就不是常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> z =  scale(i);        <span class="comment">// error,传递的是非常量，所以函数是非常量表达式，而z是常量表达式，只能用常量表达式初始化</span></span><br></pre></td></tr></table></figure>
<p>​        constexpr函数在编译的过程中被隐式的指定为内联函数。</p>
<h2 id="常见的问题"><a href="#常见的问题" class="headerlink" title="常见的问题"></a>常见的问题</h2><h3 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h3><ul>
<li>new是C++关键字(new既是关键字也是运算符)，需要编译器支持，可以被重载；malloc是库函数</li>
<li>malloc需要指定分配内存块的大小，new不需要，直接指定分配元素的类型即可。</li>
<li>new做两件事，分别是分配内存(一般调用malloc)和调用类的构造函数，而malloc只是分配内存。</li>
<li>new返回的是所分配对象类型的指针，无需强制转换。而malloc返回的是void*类型的指针</li>
</ul>
<h3 id="内存泄漏和内存溢出"><a href="#内存泄漏和内存溢出" class="headerlink" title="内存泄漏和内存溢出"></a>内存泄漏和内存溢出</h3><ul>
<li>内存泄漏：是指程序在申请内存后，没有释放已申请的内存空间，那么这段内存无法再被使用，长此以往，内存将会被分配殆尽，造成内存溢出——即没有内存可被分配。</li>
<li>内存溢出：指程序申请内存时，没有足够的内存供申请者使用</li>
</ul>
<p><strong>所以内存泄漏的堆积最终会导致内存溢出</strong></p>
<h3 id="epoll、select、poll（优点、缺点、实现）"><a href="#epoll、select、poll（优点、缺点、实现）" class="headerlink" title="epoll、select、poll（优点、缺点、实现）"></a>epoll、select、poll（优点、缺点、实现）</h3><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>http协议相当于web应用沟通的一种方式。传输的数据和沟通用的http报文都是以ASCII码格式的文件(明文传递)通过TCP作为传输层协议传输过去的，但是沟通用的http报文是有固定格式的。</p>
<p>1.HTTP协议主要用于web应用，是<strong>应用层协议</strong> 。HTTP协议一般用于B/S架构。浏览器作为HTTP客户端通过<strong>URL</strong>向HTTP服务端即WEB服务器发送所有请求。</p>
<p>2.HTTP是一个基于TCP协议来传递数据的协议(事先要建立TCP链接)。</p>
<p>3.WEB服务器与本地浏览器传输的文件称为web页面，web页面由对象组成。对象可以是<strong>HTML</strong>文件、图片、视频、音频文件。一般web页面包含一个基本的HTML文件，这个基本的HTML文件会引用其他对象，比如图片，文件。</p>
<p>4.http协议是无状态的</p>
<h3 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h3><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</p>
<ul>
<li>URI：Uniform Resource Identifier 统一资源<strong>标识</strong>符</li>
<li>URL：Uniform Resource Location 统一资源<strong>定位</strong>符</li>
</ul>
<p>URI 是用来<strong>标示</strong> 一个具体的资源的，我们可以通过 URI 知道一个资源是什么。 </p>
<p>URL 则是用来<strong>定位</strong>具体的资源的，标示了一个具体的资源位置。互联网上的每个文件都有一个唯一的URL。<code>URL</code>（统一资源定位符）是一种特殊种类的<code>URI</code>，包含了用于查找的资源的足够的信息，我们一般常用的就是<code>URL</code>，</p>
<h3 id="持续与非持续连接"><a href="#持续与非持续连接" class="headerlink" title="持续与非持续连接"></a><strong>持续与非持续连接</strong></h3><ol>
<li><p>非持续连接：每次建立TCP连接之后只通过http协议传递一个对象，传完就断开连接。所以多个对象需要建立多次连接</p>
</li>
<li><p>持续连接：建立一次TCP连接，可以传输多个对象</p>
<p>​        带流水线：收到一个对象之后才能才能发送下一个请求。</p>
<p>​        不带流水线：每遇到一个引用之后就立刻发出http请求，可以连续发出多个请求，服务器端也可以连续发送多个对象。</p>
</li>
</ol>
<p><strong>HTTP/1.1的默认模式使用带流水线的持久连接。</strong></p>
<h3 id="HTTP报文组成"><a href="#HTTP报文组成" class="headerlink" title="HTTP报文组成"></a><strong>HTTP报文组成</strong></h3><p><strong>请求报文构成</strong></p>
<ol>
<li>请求行：包括请求方法、URL、协议及版本</li>
<li>请求头，比如cookie，请求主机域名等信息。</li>
<li>请求正文(请求体)，可以发送用户登录用户名，密码等信息。</li>
</ol>
<p><strong>响应报文构成</strong></p>
<ol>
<li>状态行：协议及版本、状态码、短语</li>
<li>响应头</li>
<li>响应正文</li>
</ol>
<h3 id="常见请求方法"><a href="#常见请求方法" class="headerlink" title="常见请求方法"></a>常见请求方法</h3><ul>
<li>GET:请求指定的页面信息，返回页面实体。</li>
<li>POST:POST表示可能修改变服务器上的资源的请求 （例如提交表单或者上传文件）。数据被包含在请求体中。</li>
<li>PUT:从客户端向服务器传送的数据取代指定的文档的内容。</li>
<li>DELETE:请求服务器删除指定的页面。</li>
</ul>
<p><strong>post和get的区别：</strong></p>
<ul>
<li>都包含请求头请求行，get请求体为空，post请求body是要提交的内容。</li>
<li>get多用来查询，请求参数放在url中，不会对服务器上的内容产生作用。post用来提交，如把账号密码放入请求body中。</li>
<li>GET是直接添加到URL后面的，直接就可以在URL中看到内容，而POST是放在报文内部的，用户无法直接看到。</li>
<li>GET提交的数据长度是有限制的，因为URL长度有限制，具体的长度限制视浏览器而定。而POST没有。</li>
</ul>
<h3 id="http响应响应状态码"><a href="#http响应响应状态码" class="headerlink" title="http响应响应状态码"></a>http响应响应状态码</h3><p><strong>状态码分类</strong>：</p>
<ul>
<li>1XX- 信息型，表示服务器收到请求，需要请求者继续操作。</li>
<li>2XX- 成功型，表示请求成功收到，理解并处理。</li>
<li>3XX - 重定向，需要进一步的操作以完成请求。</li>
<li>4XX - 客户端错误，请求包含语法错误或无法完成请求。</li>
<li>5XX - 服务器错误，服务器在处理请求的过程中发生了错误。</li>
</ul>
<p><strong>常见状态码</strong>：</p>
<ul>
<li>200 OK - 客户端请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL，新的URL会放在响应报文的首部行中。</li>
<li>302 - 临时跳转</li>
<li>400 Bad Request - 客户端请求有语法错误，不能被服务器所理解</li>
<li>404 - 请求资源不存在，可能是输入了错误的URL。</li>
<li>500 - Internal Server Error：服务器内部发生错误，无法完成请求</li>
<li>503 Server Unavailable - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常。</li>
</ul>
<h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>http使用明文传输数据，很容易被抓包获取信息。所以引出了https</p>
<p>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL或TLS，通过 SSL证书来<strong>验证服务器的身份</strong>，<strong>并为</strong>浏览器和服务器之间的<strong>通信进行加密</strong>。</p>
<p>TLS和SSL的关系：并列关系。</p>
<p>SSL（Secure Socket Layer，安全套接字层）：SSL 协议位于传输层协议与各种应用层协议之间，为数据通讯提供安全支持。</p>
<p>TLS（Transport Layer Security，传输层安全）：其前身是 SSL，TLS是更为安全的升级版 SSL。由于 SSL 这一术语更为常用，因此我们仍然将我们的安全证书称作 SSL。</p>
<img src="/2021/04/02/%E5%AE%9E%E4%B9%A0%E5%87%86%E5%A4%87/image-20210401151301825.png" alt="image-20210401151301825" style="zoom:50%;">

<h3 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h3><p>​        <strong>对称加密</strong>：特点是文件加密和解密使用相同的密钥，运用对称加密有一个前提就是在发送信息前双方都必须知道加密的规则。</p>
<p>​        <strong>非对称加密：</strong>非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果将其中任意一把向外发布，那么这把就是公有密钥，为发布的就是私有密钥。用共有密钥加密的数据只能用对应的私有密钥解密。</p>
<p>​        非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。甲方只能用其专用密钥解密由其公用密钥加密后的任何信息。</p>
<p>​        对称加密解密的速度比较快，适合数据比较长时的使用。非对称加密和解密花费的时间长、速度相对较慢，只适合对少量数据的使用。</p>
<h3 id="通信加密（解决数据被窃取问题）"><a href="#通信加密（解决数据被窃取问题）" class="headerlink" title="通信加密（解决数据被窃取问题）"></a><strong>通信加密（解决数据被窃取问题）</strong></h3><p>​        因为HTTP不对通信内容进行加密处理，所以衍生了SSL加密技术协议，SSL采用<strong>混合加密</strong>（同时使用非对称加密和对称加密）的方式建立起安全的HTTP通信，经过加密后的内容即使被窃听了，窃听的人也无法解密对应的数据。</p>
<h3 id="数字证书（解决身份伪装问题）"><a href="#数字证书（解决身份伪装问题）" class="headerlink" title="数字证书（解决身份伪装问题）"></a><strong>数字证书（解决身份伪装问题）</strong></h3><p>​        HTTP不会对通信的双方进行进行身份的验证所以身份有可能被伪装造成安全问题，所以为了解决这个问题所以产生了数字证书，数字证书的使用流程大概如下：</p>
<p>1、服务器首先向一个大家都信任的第三方机构申请一个身份证书。</p>
<p>2、客户端向服务器建立通信之前首先向服务器请求获得服务器的证书。</p>
<p>3、服务器收到请求后把数字证书发送给客户端。</p>
<p>4、客户端获得服务器的证书之后，然后与可信任的第三方机构证书进行验证，验证通过后则进行正常的内容通信。</p>
<h3 id="数字签名（解决数据篡改问题）"><a href="#数字签名（解决数据篡改问题）" class="headerlink" title="数字签名（解决数据篡改问题）"></a><strong>数字签名（解决数据篡改问题）</strong></h3><p>Http不会对数据的完整性进行验证，这样会造成就算通信的过程中数据被别人恶意篡改了</p>
<p>，通信的双方也没办法知道，所以就有了数字签名技术。</p>
<p>数字签名主要有两个作用，一是验证数据是否为意料中的对象所发出的，二是对数据的完整性进行验证，验证数据是否被篡改过：</p>
<p>1、对需要发送的数据进行摘要</p>
<p>对数据进行摘要主要目的是确认数据的完整性，发送方首先根据约定的哈希算法把数据进行哈希，得到一个哈希值，因为两个数据有任何一点不相同都会得出不同的哈希值，所以把对数据内容进行哈希得到哈希值作为数据的摘要发给对方；</p>
<p>然后对方收到数据后，首先自己也按照约定的哈希算法把接收到的数据内容进行哈希得到一个哈希值，然后把自己的哈希值与发送过来的摘要信息进行比对，根据哈希值是否一致来确认数据的完整性。</p>
<p>2、对摘要信息进行签名</p>
<p>对摘要进行签名的目的主要是对确认数据发送人的身份，签名技术是使用非对称加密的原理，</p>
<p>非对称加密是使用一个密钥对（一个公钥，一个私钥），公钥加密只能由私钥解密，私钥加密只能由公钥解密； 公钥是公布出来的密钥，私钥由自己安全保管不外泄，所以在私钥不泄漏情况下，我们通过私钥其实就可以确认发送数据方的身份。</p>
<p>那么我们想要对A发送过来的数据进行身份验证，那么我们只需要用A的公钥对数据进行解密即可（如果可以解密，那么就说明该数据是A用自己的私钥进行加密过的，而A的私钥又只有A自己拥有）</p>
<h3 id="HTTPS通信流程"><a href="#HTTPS通信流程" class="headerlink" title="HTTPS通信流程"></a><strong>HTTPS通信流程</strong></h3><p>HTTPS通信主要包括几个节点，发起请求、验证身份、协商秘钥、加密会话</p>
<p>1、客户端向服务端发起建立HTTPS请求。</p>
<p>2、服务器向客户端发送数字证书。</p>
<p>3、客户端验证数字证书，证书验证通过后客户端生成会话密钥（双向验证则此处客户端也会向服务器发送证书）。</p>
<p>4、服务器生成会话密钥（双向验证此处服务端也会对客户端的证书验证）。</p>
<p>5、客户端与服务端开始进行加密会话。</p>
<h4 id="第一步：客户端向服务端发起请求"><a href="#第一步：客户端向服务端发起请求" class="headerlink" title="第一步：客户端向服务端发起请求"></a><strong>第一步：客户端向服务端发起请求</strong></h4><p>（1）客户端生成随机数R1 发送给服务端；</p>
<p>（2）告诉服务端自己支持哪些加密算法；</p>
<h4 id="第二步：服务器向客户端发送数字证书"><a href="#第二步：服务器向客户端发送数字证书" class="headerlink" title="第二步：服务器向客户端发送数字证书"></a><strong>第二步：服务器向客户端发送数字证书</strong></h4><p>（1）服务端生成随机数R2;</p>
<p>（2）从客户端支持的加密算法中选择一种双方都支持的加密算法（此算法用于后面的会话密钥生成）;</p>
<p>（3）服务端生成把证书、随机数R2、会话密钥生成算法，一同发给客户端;</p>
<h4 id="第三步：客户端验证数字证书。"><a href="#第三步：客户端验证数字证书。" class="headerlink" title="第三步：客户端验证数字证书。"></a><strong>第三步：客户端验证数字证书。</strong></h4><p>（1）验证证书的可靠性，先用CA的公钥解密被加密过后的证书,能解密则说明证书没有问题，然后通过证书里提供的摘要算法进行对数据进行摘要，然后通过自己生成的摘要与服务端发送的摘要比对。</p>
<p>（2）验证证书合法性，包括证书是否吊销、是否到期、域名是否匹配，通过后则进行后面的流程</p>
<p>（3）获得证书的公钥、会话密钥生成算法、随机数R2</p>
<p>（4）生成一个随机数R3。</p>
<p>（5）根据会话秘钥算法使用R1、R2、R3生成会话秘钥。</p>
<p>（6）用服务端证书的公钥加密随机数R3并发送给服务端。</p>
<h4 id="第四步：服务器得到会话密钥"><a href="#第四步：服务器得到会话密钥" class="headerlink" title="第四步：服务器得到会话密钥"></a><strong>第四步：服务器得到会话密钥</strong></h4><p>（1）服务器用私钥解密客户端发过来的随机数R3</p>
<p>（2）根据会话秘钥算法使用R1、R2、R3生成会话秘钥</p>
<h4 id="第五步：客户端与服务端进行加密会话"><a href="#第五步：客户端与服务端进行加密会话" class="headerlink" title="第五步：客户端与服务端进行加密会话"></a><strong>第五步：客户端与服务端进行加密会话</strong></h4><p>（1）客户端发送加密数据给服务端</p>
<p>发送加密数据：客户端加密数据后发送给服务端。</p>
<p>（2）服务端响应客户端</p>
<p>解密接收数据：服务端用会话密钥解密客户端发送的数据；</p>
<p>加密响应数据：用会话密钥把响应的数据加密发送给客户端。</p>
<p>（3）客户端解密服务端响应的数据</p>
<p>解密数据：客户端用会话密钥解密响应数据；</p>
<h2 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h2><p>暂时看不进去，不看了</p>
<h2 id="输入URL发生了什么"><a href="#输入URL发生了什么" class="headerlink" title="输入URL发生了什么"></a>输入URL发生了什么</h2><p>当用户在浏览器中输入域名并按下回车键后</p>
<ol>
<li>浏览器会解析URL获得主机名、端口号、协议类型、资源路径等，确定是HTTP协议之后准备利用解析出来得信息依次生成http请求报文和TCP同步报文段。</li>
<li>根据域名获取ip地址。浏览器会检查缓存中有没有这个域名对应的解析过的IP地址，如果有，这个解析过程就结束了，直接拿到IP进行访问。这个浏览器缓存域名是有限制的，除了缓存大小有限制，缓存的时间也有限制，通常情况下由TTL属性来设置。</li>
<li>如果用户浏览器缓存中没有，浏览器会查找操作系统中是否有这个域名对应的DNS解析结果。windows中c:/windows/system32/drivers/etc/hosts文件设置，linux中/etc/hosts文件中设置。当解析到这个配置文件中的某个域名时，操作系统会在缓存中缓存这个解析结果。（修改文件后不立即生效的原因）</li>
<li>当前面两步都不能解析时，操作系统会把这个域名发送给设置的DNS服务器（简称LDNS）-local缩写，一般是本地区的域名服务器也可以是自己设置的域名服务器地址，如果命中，那解析就此结束并返回IP并标记为<strong>非权威服务器的应答</strong>。如是学校的互联网，那么你的DNS服务器肯定在你的学校，如果你是一个小区接入互联网，那这个DNS就是提供给你接入互联网的应用供应商，即电信或联通。windows中能用ipconfig查看DNS服务器地址，linux中cat /etc/resolv.conf查看DNS Server。<strong>这个过程都是调用解析器函数，如gethostbyname完成得。</strong></li>
<li>如果LDNS没有命中，LDNS就会向Root Server域名服务器请求解析。LDNS会从<strong>配置文件</strong>里面读取13个根域名服务器的地址（这些地址是不变的，直接在BIND的配置文件中），然后像其中一台发起请求。</li>
<li>根服务器拿到这个请求后，知道他是com.这个顶级域名下的，所以就会返回com.域中的NS记录，一般来说是13台主机名和IP（主域名服务器地址即gTLD-国际顶级域名服务器地址），返回给本地域名服务器即LDNS，</li>
<li>LDNS再向上一步返回的其中一台gTLD服务器发送请求。com.域的服务器（gTLD）发现你这请求是baidu.com这个域的，一查发现了这个域的NS（一般就是你注册的域名服务器），那就返回给你，你再去查。</li>
<li>LDNS接受gTLD返回的域服务器地址（即域名服务提供商的域服务器）并向其中一台再次发起请求，在baidu.com的域下面查了下有www的这台主机，就把这个IP返回给你了。</li>
<li>LDNS接受返回的IP和TLL值</li>
<li>LDNS缓存这个域名和IP的对应关系，缓存时间有TLL控制</li>
<li>LDNS把解析的结果返回给用户，用户根据TLL值缓存在本地系统缓存中，域名解析结束。</li>
<li>根据解析出来的IP地址创建将TCP同步报文段封装成IP数据报。</li>
<li>根据目的IP地址查询本地路由表获得下一跳IP地址</li>
<li>根据下一跳IP地址查找ARP缓存获得下一跳主机的MAC地址。如果ARP缓存没有，则使用ARP协议根据下一跳设备的IP地址来获取对应的MAC地址</li>
<li>然后封装成帧发送出去。</li>
<li>最终同步报文段会发送到服务器端，然后开始剩下的两次握手，建立TCP连接。</li>
<li>发送HTTP请求报文请求数据</li>
<li>服务器端发送http响应报文，然后再发送请求的web文件。</li>
<li>接着通信</li>
<li>通信完四次挥手断开TCP连接</li>
</ol>
<h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h2><p><strong>连接方面区别</strong></p>
<ul>
<li><strong>TCP</strong>:有连接，提供可靠传输服务，保证传输的数据无差错，不丢失，不重复，且按序到达。</li>
<li><strong>UDP</strong>：无连接，尽最大努力交付，即不保证可靠交付。</li>
</ul>
<p><strong>传输效率的区别</strong></p>
<ul>
<li>TCP传输效率相对较低。</li>
<li>UDP传输效率高。</li>
</ul>
<p><strong>连接对象数量的区别</strong></p>
<ul>
<li>TCP连接只能是点到点、一对一的。</li>
<li>UDP支持一对一，一对多，多对一和多对多的交互通信。</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>UDP：<strong>面向报文</strong>，适用于对实时性有较高的通信；eg: 实时视频会议等。</li>
<li>TCP: <strong>面向字节</strong>，对数据准确性要求高，速度可以相对较慢的。eg: 文件传输、邮件的发送与接收等。</li>
</ul>
<p>TCP首部20B，UDP首部8B</p>
<h3 id="TCP的若干问题"><a href="#TCP的若干问题" class="headerlink" title="TCP的若干问题"></a>TCP的若干问题</h3><p>TCP保证可靠传输</p>
<p><strong>TCP协议保证数据传输可靠性的方式主要有：</strong></p>
<ul>
<li>校验和</li>
<li>确认应答与序列号</li>
<li>超时重传:发送一个报文段就为这个报文段创建一个定时器，如果定时器超时就重传该数据。</li>
<li>流量控制:发送方发送速率过快时，接收方可以在确认报文段中填入接收窗口大小来限制发送发发送速率。</li>
<li>拥塞控制：</li>
</ul>
<p>1.慢开始加拥塞避免<br>        每过一个RTT，就将拥塞窗口变为以前的两倍，直到拥塞窗口变为threshold，开始加法增大(这个阶段叫拥塞避免)。直到超时发生拥塞，将拥塞窗口变为1，设置新threshold为发生拥塞时拥塞窗口的一半。然后继续慢开始算法</p>
<p>2.快重传和快恢复<br>        前面也是慢开始+加法增大，快重传是指当连续收到3个重复确认报文段时，认为拥塞发生。设置新threshold为发生拥塞时拥塞窗口的一半，快恢复是把拥塞窗口也设置为原先threshold的一半， 然后执行拥塞避免算法(加法增大)，使拥塞窗口缓慢增大。</p>
<p>服务器端为什么需要<code>TIME__WAIT</code>状态？</p>
<ol>
<li>客户端关闭之后，就可以把原先客户端的端口号再分配出去了，但是新的客户端进程用了这个端口号会接收到原先连接的客户端发来的信息(比如因为网络延迟比服务器端FIN报文段晚到的携带数据的报文段)。新的连接肯定无法处理。为了防止这种情况，我们需要<code>TIME__WAIT</code>状态，这个状态客户端的端口号不能再被分配出去，也就是不能被占用。</li>
<li><code>TIME__WAIT</code>状态的时间时2MSL，2MSL之后网络上绝对没有原先连接的任何报文段数据了。所以新的连接不用担心有原先连接的报文段数据发过来了</li>
</ol>
<h1 id="Linux服务器编程"><a href="#Linux服务器编程" class="headerlink" title="Linux服务器编程"></a>Linux服务器编程</h1><h2 id="Linux指令操作"><a href="#Linux指令操作" class="headerlink" title="Linux指令操作"></a>Linux指令操作</h2><p>1.Linux中查看cpu和内存的占用率怎么看？使用top命令</p>
<p><img src="/2021/04/02/%E5%AE%9E%E4%B9%A0%E5%87%86%E5%A4%87/image-20210401235508373.png" alt="image-20210401235508373"></p>
<p>2.Linux中ps -aux是什么意思？</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>显示所有进程（包括其他用户的进程）</td>
</tr>
<tr>
<td>u</td>
<td>用户以及其他详细信息</td>
</tr>
<tr>
<td>x</td>
<td>显示没有控制终端的进程</td>
</tr>
</tbody></table>
<p>3.</p>
<h1 id="项目遇到的一些问题"><a href="#项目遇到的一些问题" class="headerlink" title="项目遇到的一些问题"></a>项目遇到的一些问题</h1><ol>
<li>显存写数据清空所有字符导致光标不亮</li>
<li>C++和nasm符号不一致</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">恒若时光</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/04/02/实习准备/">http://example.com/2021/04/02/实习准备/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">恒若时光のblog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="next-post pull-right"><a href="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span>MySQL必知必会读书笔记</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '152ddcae291378830dfc',
  clientSecret: '303f9a5f5325e6d1dabb9819aac27403b6d03001',
  repo: 'wuhanyi1.github.io',
  owner: 'wuhanyi1',
  admin: 'wuhanyi1',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://desk-fd.zol-img.com.cn/t_s1024x768c5/g5/M00/0A/0C/ChMkJlkml26ISdS6AASb0-G7sfUAAcmwwO6rFEABJvr18.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 By 恒若时光</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>