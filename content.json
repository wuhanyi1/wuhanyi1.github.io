{"meta":{"title":"恒若时光のblog","subtitle":"有毅者,事竟成","description":"","author":"恒若时光","url":"http://example.com","root":"/"},"pages":[{"title":"tags","date":"2018-01-04T16:00:00.000Z","updated":"2021-01-26T09:06:56.251Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-01-04T16:00:00.000Z","updated":"2021-01-26T09:07:51.294Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"2021每日计划","slug":"2021每日计划","date":"2021-01-27T02:40:53.000Z","updated":"2021-01-27T12:47:45.668Z","comments":true,"path":"2021/01/27/2021每日计划/","link":"","permalink":"http://example.com/2021/01/27/2021%E6%AF%8F%E6%97%A5%E8%AE%A1%E5%88%92/","excerpt":"","text":"2021/1/27计划 把leetcode101分治与数学专题刷完；目前已刷197，今天刷题数至少到205，并相应题型做总结 读完MySQL必知必会9~15章,并写全对应读书笔记 俯卧撑100个 完成情况 总算刷到205了，步子太大扯到d了。分治题全用dp做的，连肝4道困难dp，2题类01背包，两题区间，加上几题数学题和总结大概花了7个小时。明天还是少定点，放过自己。","categories":[{"name":"日常生活","slug":"日常生活","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"每日计划","slug":"每日计划","permalink":"http://example.com/tags/%E6%AF%8F%E6%97%A5%E8%AE%A1%E5%88%92/"}]},{"title":"leetcode题型总结","slug":"leetcode题型总结","date":"2021-01-25T15:23:48.000Z","updated":"2021-01-26T09:44:49.094Z","comments":true,"path":"2021/01/25/leetcode题型总结/","link":"","permalink":"http://example.com/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/","excerpt":"双指针​ 目前刷到的双指针题目主要有三种 夹逼型：左右指针初始时分别指向左端点和右端点，然后根据某种条件向中间夹，一般这种情况要求数组有序(无序比如翻转数组) 双指针维护滑动窗口类型：即指针p逐个向后遍历，指针q要按某种条件移动，指针(q,p)就维护了一个区间，这个区间会不断移动，也叫做滑动窗口。这个窗口不一定是有固定长度的，具体要看题目的条件。1.滑动窗口的条件可以用循环不变式来约束，即用集合的思想来思考 2.滑动窗口内必须是连续的(求解的问题必须是连续的)，如果结果可能非连续(比如求最长子序列)，无法用滑动窗口 两个指针指向不同的数组：两个指针指向不同的数组，按照某种条件移动两个指针。这个指针初始化时不一定要指针两个数组的开头，也可以指向两个数组的末尾。常常用来合并数组或者链表 链表题的快慢指针。141 142两题。","text":"双指针​ 目前刷到的双指针题目主要有三种 夹逼型：左右指针初始时分别指向左端点和右端点，然后根据某种条件向中间夹，一般这种情况要求数组有序(无序比如翻转数组) 双指针维护滑动窗口类型：即指针p逐个向后遍历，指针q要按某种条件移动，指针(q,p)就维护了一个区间，这个区间会不断移动，也叫做滑动窗口。这个窗口不一定是有固定长度的，具体要看题目的条件。1.滑动窗口的条件可以用循环不变式来约束，即用集合的思想来思考 2.滑动窗口内必须是连续的(求解的问题必须是连续的)，如果结果可能非连续(比如求最长子序列)，无法用滑动窗口 两个指针指向不同的数组：两个指针指向不同的数组，按照某种条件移动两个指针。这个指针初始化时不一定要指针两个数组的开头，也可以指向两个数组的末尾。常常用来合并数组或者链表 链表题的快慢指针。141 142两题。 夹逼型167:两数之和1234给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数，返回这两个数的下标。输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 有序，自然是左右端点夹逼型 633:平方数之和12345给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c 。实例:输入：c = 5输出：true解释：1 * 1 + 2 * 2 = 5 有序，又是找两个满足某条件的点，自然双指针。这里为了不超时，可以让右指针从sqrt(x)开始。 345.反转元音字符12345输入：&quot;hello&quot;输出：&quot;holle&quot;示例 2：输入：&quot;leetcode&quot;输出：&quot;leotcede&quot; 双指针翻转字符 680.验证回文串12345678给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。示例 1:输入: &quot;aba&quot;输出: True示例 2:输入: &quot;abca&quot;输出: True解释: 你可以删除c字符。 判断回文串自然是夹逼型双指针，重点是我们夹逼到发现两个字符不相等时如何处理，由于只能删除一个，自然可以删除左边也可以删除右边，我们再去测试一下删除字符之后的部分串是否为回文串。所以我们两边都要试一下，有一个是就直接返回。 123456789101112131415161718192021222324class Solution &#123;public: bool test(string s)&#123; int i = 0,j = s.size() - 1; while(i &lt; j)&#123; if(s[i] != s[j]) return false; i++,j--; &#125; return true; &#125; bool validPalindrome(string s) &#123; int i = 0,j = s.size() - 1; while(i &lt; j)&#123; if(s[i] != s[j])&#123; //两边都试一下 if(test(s.substr(i+1,j - i))) return true; if(test(s.substr(i,j - i))) return true; return false; &#125; i++,j--; &#125; return true; &#125;&#125;; 指针指向不同数组型88.归并两个有序数组12345678910给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。说明：初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。输入：nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出：[1,2,2,3,5,6] 指针分别指向两个数组的尾部，按照规则放入nums1数组。这就是双指针不一定非要放头部的反例，提一嘴，这个合并复杂度是o(m+n) 524.通过删除字母匹配到字典里最长单词1234567给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。输入:s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]输出: &quot;apple&quot; 本质上是看能否在串s中找到一个在字典中出现过的子序列串，如果找到且有多个。就会返回最长，如果相等，就返回字典序小的那个 野的方法就是找到串s的所有子序列，然后看他们是否在d中出现，加入一个集合后再筛选。这是从s找到符合d的东西。但是我们可以逆向思维，我们依次遍历d中的串，看他是否是s的子序列，这里判断是否为子序列我们就可以使用第二种类型的双指针了，这里是两个指针分别指向两个字符串的开头。 为了优化，我们可以事先将d排序，按照先长度后字典序的方式排序，那样字典按需遍历时，找到的第一个符合条件的一定就是最终结果 123456789101112131415161718192021class Solution &#123;public: static bool com(string&amp; s1,string&amp; s2)&#123; if(s1.size() != s2.size()) return s1.size() &gt; s2.size(); int i = 0; while(i &lt; s1.size() &amp;&amp; s1[i] == s2[i]) i++; return s1[i] &lt; s2[i]; &#125; string findLongestWord(string s, vector&lt;string&gt;&amp; d) &#123; sort(d.begin(),d.end(),com); for(int i = 0;i &lt; d.size();i++)&#123; int s_cur = 0,d_cur = 0; while(d_cur &lt; d[i].size() &amp;&amp; s_cur &lt; s.size())&#123; if(d[i][d_cur] == s[s_cur]) s_cur++,d_cur++; else s_cur++; &#125; if(d_cur == d[i].size()) return d[i]; &#125; return &quot;&quot;; &#125;&#125;; 21.合并两个有序链表滑动窗口型3.没有重复字符的字长子串12345678给定一个字符串，请你找出其中不含有重复字符的 最长子串 的&quot;长度&quot;。输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 这里我们可以用双指针维护一个滑动窗口，滑动窗口内的字符必然要满足一个条件，我们在移动这个遍历用的指针遍历到新的元素时，必然要考虑到他对这个滑动窗口的影响，也就是对这个集合的影响，是新元素加入窗口、窗口扩大还是剔除窗口左端元素(剔除元素是为了维护窗口内的性质和我们的预期一致)，移动窗口(可以看到移动窗口其实就是对窗口左端点指针移动)，此时就可以用到集合论的思想，即循环不变式 先定义好我们的窗口中的元素(集合)满足的条件：显然是集合中无重复元素，所以循环不变式(集合元素满足的条件)就是窗口中无重复元素。那么我们要使用一种方式记录这个窗口中是否有元素重复，此时我们想到了哈希表，以元素值为key，value标识这个元素出现的次数。当我们遍历用的指针i移动到下一个元素时，将这个元素加入窗口，对应的元素值++，如果发现加了之后hash[i] &gt; 1，说明这个窗口中有和新加入的这个元素一样的元素，我们就要移动窗口的左端点指针j，每移动一个将对应的hash值–，直到hash[i] == 1。在此过程中用窗口大小更新结果。 904.水果成篮1234输入一个数组Tree,数组的编号代表不同的树，Tree[i]的值表示第i棵树上结的水果。问你从任意一棵树开始，自左向右用两个体积无限大的篮子接水果，并且每个篮子只能放一种水果，最后返回你能采摘的水果数的最大数量。输入：[1,2,1]输出：3解释：我们可以收集 [1,2,1]。 这题其实和上面那题一样，就是维护一个滑动窗口，使滑动窗口内只含有两种类型的水果，抽象出来就是让滑动窗口内只包含两种数，并最后求这个滑动窗口最长时的长度 为了维护这个循环不变式，我们可以用哈希表来窗口内水果类型的个数和对应的每种类型水果的个数。自然我们就是要让这个哈希表的元素不超过2个。i移动时，加入一个新的元素使哈希表元素大于两个，我们就要移动j，使这个滑动窗口内完全丢掉一种水果(无论是哪种)，所以此时我们可以根据hash[j]的值是否为0来判断某种水果是否全没了。哪个先没了，把哪种水果从哈希表丢掉。 76.最小覆盖串1234567给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。示例 1：输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;输出：&quot;BANC&quot; **这题也是滑动窗口，这个窗口的性质也即满足的条件是窗口内包含串t的所有字符，不需要顺序。所以我们要记录窗口内有效串的个数，来了一个新元素之后看是否会对我这个窗口有影响 如果当前窗口不包含t的所有字符，来了一个新的之后判断是否能让这个窗口包含t所有字符，如果能，我们想让窗口尽可能小点，移动窗口左端点，移动左端点的终止条件就是窗口内不包含t中的所有字符了。由于最后是要返回串，所以我们要记录最小满足条件的串的左端点和这个串的长度 ** 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string minWindow(string s, string t) &#123; unordered_map&lt;char,int&gt; mp; //记录t串出现的字符和出现的次数 for(int i = 0;i &lt; t.size();i++)&#123; mp[t[i]]++; &#125; //窗口内有t有效字符的个数、最小子串的左边界、最小字串的长度 int cnt = 0,min_l = 0,min_size = INT_MAX; for(int l = 0,r = 0;r &lt; s.size();r++)&#123; if(mp.count(s[r]))&#123; //有效字符个数只有mp[s[r]] &gt; 0时才算,去除重复字符的影响 if(mp[s[r]] &gt; 0) cnt++; mp[s[r]]--; &#125; //获得了以r为右端点且包含t全部有效字符的最短子串 while(cnt == t.size())&#123; if(mp.count(s[l]))&#123; if(++mp[s[l]] &gt; 0) cnt--; &#125; if(r - l + 1 &lt; min_size)&#123; min_l = l; min_size = r - l + 1; &#125; l++; &#125; &#125; return min_size == INT_MAX ? &quot;&quot; : s.substr(min_l,min_size); &#125;&#125;; 二分​ 整数二分就主要使用acwing的模板就可以了，即自左向右找到第一个满足条件的点，自右向左找到第一个满足条件的点。小数二分比较简单。目前尚未总结出题型 ​ 注意二分不一定要求数组有序，只要你能找到一次能排除一般元素的排他性条件就可以了。 123456789101112//左边第一个大于等于x的点，最后一定会停止，但是可能最后结果在逻辑上不满足条件while(i &lt; j)&#123; int mid = i + j &gt;&gt; 1; if(arr[mid] &gt;= x) r = mid; else l = mid + 1;&#125;//从右开始第一个小于等于x的点while(i &lt; j)&#123; int mid = i + j + 1&gt;&gt; 1; if(arr[mid] &lt;= x) l = mid; else r = mid - 1;&#125; 整数二分模板题69.求平方根12345678计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。输入: 4输出: 2输入: 8输出: 2说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 根据题意就是找到自左到右的第一个t，使t^2 &lt;= x；所以我们使用第一个模板，条件就是mid^2 &lt;= x 43.区间查找12345678910111213给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4]示例 2：输入：nums = [5,7,7,8,8,10], target = 6输出：[-1,-1]输入：nums = [], target = 0输出：[-1,-1] 模板题直接套，即找到第一个小于等于target的位置，如果这个位置的值不等于target，说明数组中没这个元素，直接结束。 81.搜索旋转数组123456789假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。示例 1:输入: nums = [2,5,6,0,0,1,2], target = 0输出: true示例 2:输入: nums = [2,5,6,0,0,1,2], target = 3输出: false 这题我们可以采用查找分界点，也就是旋转点，然后根据分界点和target的大小关系选择到分界点的左端还是右端查找。如果旋转了，分界点的特点一定是第一个小于nums[0]的点。但是这题因为有重复元素，所以预处理去重。我们删去数组右端的点，直到右端的点小于nums[0]，接下来就可以二分查找第一个小于nums[0]的分界点了。 540.有序数组的单一元素1234给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。示例 1:输入: [1,1,2,3,3,4,4,8,8]输出: 2 这一题可以用位运算(亦或)来做，但是也可以二分来做。我们找到的二分条件就是如果arr[mid] == arr[mid + 1],那么如果mid处包括之前没有那个只出现一次的元素，这个mid一定是偶数。否则这个只出现一次的数一定出现在mid右边。同理分析 1234567891011121314151617181920class Solution &#123;public: int singleNonDuplicate(vector&lt;int&gt;&amp; nums) &#123; int l = 0, r = nums.size() - 1; while(l &lt; r)&#123; int mid = (l + r)&gt;&gt; 1; //注意边界条件 if(mid + 1 &lt;= r &amp;&amp; nums[mid] == nums[mid+1])&#123; if(!(mid % 2)) l = mid + 2; else r = mid - 1; &#125; else if(mid - 1 &gt;= 0 &amp;&amp; nums[mid] == nums[mid - 1])&#123; if(mid % 2) l = mid + 1; else r = mid - 1; &#125; else return nums[mid]; &#125; return nums[l]; &#125;&#125;; 动态规划​ 目前还没有总结出动态规划的套路，记录一下到目前为止的一些思考 ​ 看了知乎的帖子之后【https://www.zhihu.com/question/291280715/answer/1570410869】，我明白了DP的做题三部曲： 定义好状态，即创建一个多维数组，明确数组中每一个值的意义 确定好某些状态的初始值，即初始化数组中某些元素的值 确定转移方程，这个也是最难的一步，目前为止我觉得主要靠经验 知乎帖子总结青蛙跳台阶1234//一维DP1.dp[i]表示跳到第i层台阶的总次数2.dp[0] = 0,dp[1] = 1,dp[2] = 23.dp[i] = dp[i - 1] + dp[i - 2] 62.不同路径12345一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？ 1234//二维DP1.dp[i][j]:到[i,j]这个位置可以有的路径数(i &gt;= 0,j &gt;= 0)2.dp[0][1...m]都是1，因为只能从左向右一条路走，dp[1...n][0]都是1，只能向下走，一个道理3.dp[i][j] = dp[i - 1][j] + dp[i][j - 1] 64.最小路径和123给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。 1234//思路和上面一题一样，任意(i,j)这个点都只能从(i-1,j)和(i,j-1)来，所以我们只要取这两个之中的最小值即可1.dp[i][j]:从(0,0)到(i,j)所有路径中路径之和最小的值2.第0行和第0列的值都需要初始化3.从(1,1)开始，dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j] 72.编辑距离1234567891011121314给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对一个单词进行如下三种操作：插入一个字符删除一个字符替换一个字符输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)rorse -&gt; rose (删除 &#x27;r&#x27;)rose -&gt; ros (删除 &#x27;e&#x27;) 这一题的转移方程和1143的LCS的思考方式特别像，两题一起看 123451.dp[i][j]:word1的前i个字符组成的子串转换成word2的前j个字符的子串所要的最少操作次数2.dp[0][0...word2.size() - 1]都是当前遍历到的word2的子串的长度(一个长度为0，转过去自然是另一个串的长度),dp[0...word1.size() - 1][0]都是当前遍历到的word2的子串的长度3.对于dp[i][j],如果word1[i] == word2[j],不用转了,那么dp[i][j] = dp[i-1][j-1]如果不等，那我们可以1.删除word1的第i个位置，就是在dp[i-1][j]的基础上又操作了一次;2.删除word2的第j个位置，就是在dp[i][j-1]的基础上又操作了一次 3.将word1的i或者word2的j替换成和对方一样的(或者让其中某一个插入对方的字符)，就是在dp[i-1][j-1]的基础上又操作了一次。&quot;这三种情况都可以，所以我们自然要取其最小值&quot;。所以此时dp[i][j] = min(min(dp[i-1][j]+1,dp[i][j-1]+1),dp[i-1][j-1]+1) 侯卫东 步骤 想转移方程时要考虑最后一步也就是考虑最后问题的解，假设他是最优解，那么最后规模的上一个规模的解也一定是最优解，可以用反证法证明。 这样我们就把原问题的接转换成了求规模更小的子问题的，更精确的说是当且问题的解可以在规模更小的子问题的解的基础上操作得到——想出这个操作就是转移方程(怎么由子问题解推出当前问题的解)。当然当前问题可能由多个子问题的解比较取优得到，不一定是只由一个子问题得到 由多个子问题的最优解比较得到当前问题最优解，这个过程就是转移方程 接下来就是考虑DP数组初始值和边界情况，比如数组越界时怎么处理。比如这里f(0)就是初始，用0个硬币就可以拼出 最后是考虑计算顺序，大部分是自左到右，当然还是要看你退出来的数之间的依赖关系 322.零钱兑换(其实也是背包问题)123456789101112给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。你可以认为每种硬币的数量是无限的。示例 1：输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1示例 2：输入：coins = [2], amount = 3输出：-1 123456789101112131415161718//主要说一下这里初始值和处理边界值的方式，如果某个数量无法用基本硬币组成，也就是数组越界，我们用无穷大表示他，为了方便处理，把除0以外的其他位置都设置成无穷大。class Solution &#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; vector&lt;int&gt; dp(amount+1,0x3f3f3f3f); dp[0] = 0; sort(coins.begin(),coins.end()); for(int i = 1;i &lt;= amount;i++)&#123; for(int j = 0;j &lt; coins.size();j++)&#123; //如果没有越界，则如何处理 if(i - coins[j] &gt;= 0) dp[i] = min(dp[i - coins[j]] + 1,dp[i]); else break; &#125; &#125; if(dp[amount] &lt; 0x3f3f3f) return dp[amount]; return -1; &#125;&#125;; 我的一些感悟123在01背包中，我们把状态f[i,j]称为一个选法集合。我们在思考转移方程时就要考虑当前这个状态可能会由哪些子问题转过来，当我们知道可能会由哪些子问题转过来之后，只需要在这些问题中取最大或最小值就可以了。一般在求f[i,j]时，多半是从f[i-1]过来的，所以我们就可以知道要么是在前i-1个问题选满了j个，第i个放不下， 要么就是前i-1选满了，但是还能放下第i个元素，所以只会由f[i-1,j]和f[i-1,j-v[i]]过来在矩阵联城法中，f[i,j]表示(i,j)这个连乘所有的乘的方式的集合，但是最终都会化为两个矩阵相乘，所以我们只需要考虑(j - i + 1)所有连乘链组成的所有可能的两个矩阵就可以了。 上面的意思就是明确状态表示哪些集合，然后集合可以按照什么样的条件划分为若干类，这个就是做题经验了。每一小类的计算一般会用到子问题的解 线性DP198.打家劫舍123456789你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。//相邻房子不能偷能偷到的最大价值 1234567891011121314//第一种状态的定义方式。偷第i个时，第i-1个不能偷。而dp[i-1]是包括偷第i-1个的，所以我们只能在i-1的基础上偷class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; vector&lt;int&gt; dp(nums.size() + 1,0); dp[1] = nums[0];//防止边界问题，从第2个开始算 for(int i = 2; i &lt;= nums.size();i++)&#123; dp[i] = max(dp[i-2]+nums[i-1],dp[i-1]); &#125; return dp[nums.size()]; &#125;&#125;; 1234567891011121314//使用股票那一题的状态定义方式dp[i][0]:第i个不偷情况下的最大值dp[i][1]:第i个偷情况下的最大值class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; dp(nums.size() + 1,vector&lt;int&gt;(2,0)); for(int i = 1;i &lt;= nums.size();i++)&#123; dp[i][0] = max(dp[i-1][0],dp[i-1][1]); dp[i][1] = dp[i - 1][0] + nums[i - 1]; &#125; return max(dp[nums.size()][0],dp[nums.size()][1]); &#125;&#125;; 213.打家劫舍Ⅱ123456你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。示例 1：输入：nums = [2,3,2]输出：3解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 123//和上一题相比，这一题就是多了环形数组这个条件。怎么解决呢？我们发现如果偷了第一个，那么最后一个一定没法偷。同理偷最后一个第一个一定没法偷。所以根据这一互斥条件，讲原数组分为两个队列，一个包含1...n-1这n-1个元素(即可能偷第一个)，一个包含2...n这n-1个元素(即不会偷第一个)。//第一组可能偷第一个，也就是有可能不偷第一个。那么假设在第一组中，最大值的组合是不偷第一个，最后一个偷的是n-2,那么你是不是会想，此时在第一组要是可以偷第n个，这样价值会更大，而且满足了1 n互斥的关系。其实如果存在描述的这种情况他会在第二组中被检查到，我们函数的功能就是找到某个区域偷盗的最大值。而上面描述的那种情况如果存在，他肯定比第一组最大值大，但是他所扫描的区域实际上是2...n，这是一定会在第二组被找到的。所以这种做法是没问题的。 12345678910111213141516class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; if(nums.size() == 1) return nums[0]; //创建两个DP数组，一个是偷第一个，一个不偷第一个 vector&lt;int&gt; dp1(nums.size()+1,0),dp2 = dp1; //dp1是一定偷第一个(则一定不会偷最后一个)，dp2是不偷第一个 dp1[1] = nums[0],dp2[2] = nums[1]; for(int i = 2;i &lt; nums.size();i++)&#123; dp1[i] = max(dp1[i-1],dp1[i-2]+nums[i-1]); &#125; for(int i = 3;i &lt;= nums.size();i++) dp2[i] = max(dp2[i-1],dp2[i-2]+nums[i-1]); return max(dp1[nums.size()-1],dp2[nums.size()]); &#125;&#125;; 123456789101112131415161718192021//空间优化版本class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; if(nums.size() == 1) return nums[0]; vector&lt;int&gt; dp1(2),dp2(2); dp1[1] = nums[0],dp2[1] = nums[1]; for(int i = 2;i &lt; nums.size();i++)&#123; int tmp = dp1[1]; dp1[1] = max(dp1[1],dp1[0]+nums[i-1]); dp1[0] = tmp; &#125; for(int i = 3;i &lt;= nums.size();i++)&#123; int tmp = dp2[1]; dp2[1] = max(dp2[1],dp2[0]+nums[i-1]); dp2[0] = tmp; &#125; return max(dp1[1],dp2[1]); &#125;&#125;; 413.等差数列划分1234A = [1, 2, 3, 4]返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。//规定连续的长度大于等于3的子数组为等差子数组，求给定数组中等差子数组的个数。 123456789101112class Solution &#123;public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) &#123; if(A.size() &lt; 3) return 0; vector&lt;int&gt; dp(A.size(),0); for(int i = 2;i &lt; A.size();i++)&#123; if(A[i] - A[i - 1] == A[i - 1] - A[i - 2]) dp[i] = dp[i - 1] + 1; else dp[i] = 0; &#125; return accumulate(dp.begin(),dp.end(),0); &#125;&#125;; 746.最小花费爬楼梯12345数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。 12345678910111213141516171819202122232425262728class Solution &#123;public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123; //dp[i]表示能到i号阶梯的所有跳跃方式的集合,但是还没跳上i号阶梯 vector&lt;int&gt; dp(cost.size(),0x3f3f3f3f); dp[0] = 0,dp[1] = 0; for(int i = 2;i &lt; cost.size();i++)&#123; dp[i] = min(dp[i-2] + cost[i-2],dp[i-1] + cost[i-1]); &#125; int n = cost.size() - 1; int res = dp[cost.size() - 1] + cost[cost.size() - 1]; if(n - 1 &gt;= 0) res = min(dp[n-1] + cost[n-1],res); return res; &#125;&#125;;//改进版本class Solution &#123;public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123; int n = cost.size(); vector&lt;int&gt; dp(n + 1); dp[0] = dp[1] = 0; for (int i = 2; i &lt;= n; i++) &#123; dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]); &#125; return dp[n]; &#125;&#125;; 矩阵问题矩阵问题的一个特点就是状态的定义，我目前总结了一下常见的意义 121.dp[i][j]代表以(i,j)为右下角的整个区域内满足某种条件的子集的集合2.dp[i][j]代表在1的基础上，所以子集中必须包含(i,j)这个点的集合，相当于在1的基础上缩小了(即固定住(i,j)这个点)。比如221题 174.地下城游戏 题意就是让你找到一个最小的HP值使你能走到终点，比如这里，第一个格子就要掉2HP，所以至少要3起步。总之就是勇士的血在路过每一个格子之后都不能低于1 这题是罕见的从右下向左上推 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; d) &#123; int n = d.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(d[0].size()+1,0)); dp[n][d[0].size()] = d[n-1][d[0].size()-1] &lt; 0 ? -d[n-1][d[0].size()-1] + 1 : 1; for(int i = d[0].size()-1;i &gt;= 1;i--)&#123; if(d[n - 1][i - 1] &gt;= 0)&#123; if(d[n-1][i-1] &gt;= dp[n][i+1]) dp[n][i] = 1; else dp[n][i] = dp[n][i+1] - d[n-1][i-1]; &#125; else dp[n][i] = dp[n][i+1] - d[n-1][i-1]; &#125; for(int i =n - 1;i &gt;= 1;i--)&#123; if(d[i - 1][d[0].size() - 1] &gt;= 0)&#123; if(d[i-1][d[0].size()-1] &gt;= dp[i+1][d[0].size()]) dp[i][d[0].size()] = 1; else dp[i][d[0].size()] = dp[i+1][d[0].size()] - d[i-1][d[0].size()-1]; &#125; else dp[i][d[0].size()] = dp[i+1][d[0].size()] - d[i-1][d[0].size()-1]; &#125; //上面是处理边界， for(int i = n-1;i &gt;= 1;i--)&#123; for(int j = d[0].size()-1;j &gt;= 1;j--)&#123; if(d[i-1][j-1] &gt;= 0)&#123; int val = min(dp[i+1][j],dp[i][j+1]); if(val &lt;= d[i-1][j-1]) dp[i][j] = 1; else dp[i][j] = val - d[i-1][j-1]; &#125; else&#123; dp[i][j] = min(dp[i+1][j],dp[i][j+1]) - d[i-1][j-1]; &#125; &#125; &#125; return dp[1][1]; &#125;&#125;; 542.01矩阵123456789101112给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。两个相邻元素间的距离为 1 。输入：[[0,0,0], [0,1,0], [0,0,0]]输出：[[0,0,0], [0,1,0], [0,0,0]] 第一种方式就是BFS：不过我们的BFS是初始化时先将所有的值为0的点入队，并更新dist数组，然后把这所有的0点看作一个超级节点，也可以看成树中的根节点，然后以这个根节点开始DFS，那么第一次遇到的所有非0节点，他们距离0的距离就是dist[x] [y] + 1.然后把这些第一次更新的节点加入到队列，中依次再遍历周围找到新的节点。根据BFS的性质，BFS第一次遇到的点的层数一定是这个点到根节点的最短距离 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;vector&lt;int&gt;&gt; dist(matrix.size(),vector&lt;int&gt;(matrix[0].size(),0)); using PII = pair&lt;int,int&gt;; queue&lt;PII&gt; que; for(int i = 0;i &lt; matrix.size();i++)&#123; for(int j = 0;j &lt; matrix[0].size();j++)&#123; if(!matrix[i][j])&#123; que.push(&#123;i,j&#125;); dist[i][j] = 0; &#125; else&#123; dist[i][j] = INT_MAX; &#125; &#125; &#125; int dx[4] = &#123;-1,1,0,0&#125;,dy[4] = &#123;0,0,-1,1&#125;; while(que.size())&#123; auto q = que.front(); que.pop(); for(int i = 0;i &lt; 4;i++)&#123; int x = q.first + dx[i]; int y = q.second + dy[i]; if(x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; matrix.size() &amp;&amp; y &lt; matrix[0].size())&#123; //判断是否入过队列,非INT_MAX一定是访问过的 if(dist[x][y] &amp;&amp; dist[x][y] == INT_MAX)&#123; dist[x][y] = dist[q.first][q.second] + 1; que.push(&#123;x,y&#125;); &#125; &#125; &#125; &#125; return dist; &#125;&#125;; 本题使用DP的话对任意一个状态他的集合要分为4类，但是无论是从上到下还是从下到上最多有两个方向也就是两类在计算这个状态之前被算出来了。所以我们选择从上到下一次，然后从下到上一次。两次更新。这样就更新到了所有方向 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;vector&lt;int&gt;&gt; dp(matrix.size(),vector&lt;int&gt;(matrix[0].size(),0x3f3f3f3f)); int dx[4] = &#123;-1,1,0,0&#125;,dy[4] = &#123;0,0,-1,1&#125;; for(int i = 0;i &lt; matrix.size();i++)&#123; for(int j = 0;j &lt; matrix[0].size();j++)&#123; if(!matrix[i][j])&#123; dp[i][j] = 0; continue; &#125; for(int k = 0;k &lt; 4;k++)&#123; int x = i + dx[k],y = j + dy[k]; if(x &gt;= 0 &amp;&amp; x &lt; matrix.size() &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; matrix[0].size())&#123; dp[i][j] = min(dp[x][y],dp[i][j]); &#125; &#125; dp[i][j] = dp[i][j] + 1; &#125; &#125; for(int i = matrix.size() - 1;i &gt;= 0;i--)&#123; for(int j = matrix[0].size() - 1;j &gt;= 0;j--)&#123; if(!matrix[i][j])&#123; dp[i][j] = 0; continue; &#125; for(int k = 0;k &lt; 4;k++)&#123; int x = i + dx[k],y = j + dy[k]; if(x &gt;= 0 &amp;&amp; x &lt; matrix.size() &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; matrix[0].size())&#123; dp[i][j] = min(dp[x][y],dp[i][j]); &#125; &#125; dp[i][j] = dp[i][j] + 1; &#125; &#125; return dp; &#125;&#125;; 关于动态规划为什么只考虑左上和右下就可以了。 1234_ _ _ 0 __ _ _ _ __ _ 1 _ __ _ _ _ _ 如上图，我们假设某个位置(x,y)离它最近的0只有一个，且是在它的右上角，在它“右1上2”的位置。这意味着距离中心1距离为“3=1+2”的范围内，所有的位置都是1（或者出界，我们暂时不考虑出界的情况，不影响结论）。 所以这张图一定是（不考虑左下方的出界情况，不影响）: 1234567? ? ? ? 1 ? ? ? ?? ? ? 1 1 0 ? ? ?? ? 1 1 1 1 1 ? ?? 1 1 1 &quot;1&quot; 1 1 1 ?? ? 1 1 1 1 1 ? ?? ? ? 1 1 1 ? ? ?? ? ? ? 1 ? ? ? ? 所以我们来考虑它右一处标为X的位置，离这个位置最近的0，一定就是它“上二”方向的0： 1234567? ? ? ? 1 ? ? ? ?? ? ? 1 1 0 ? ? ?? ? 1 1 1 1 1 ? ?? 1 1 1 &quot;1&quot; X 1 1 ?? ? 1 1 1 1 1 ? ?? ? ? 1 1 1 ? ? ?? ? ? ? 1 ? ? ? ? 所以在“考虑左上角的时候”，X处的位置可以记录到目标0的信息，X处的最短距离被正确记录了。 然后在“考虑右下角的时候”，X处的最短信息，正好又能被我们的中心“1”观察到，所以中心1间接地，记录到了目标0的最短距离。 123456789101 1 1 1 1 1 11 1 1 1 0 1 11 1 1 1 1 1 11 1 1 1 1 1 1如图，从左上开始的第一遍会让0为左上角的矩形区域全部记录到1 1 1 1 1 1 11 1 1 1 / 0 1 11 1 1 1 / 1 1 11 1 1 1 / 1 1 1从右下向左上遍历时，右下的区域又会把记录到的最短信息更新给左上半部分的区域 221.最大正方形 题意就是在给定矩形矩阵中找到全由1构成的最大正方形的面积 1&quot;对于矩阵搜索正方形或者长方形的题目，常见的做法是使用dp&quot;。在这种题目里面一般定义dp[i][j]所代表的集合为以(i,j)为右下角的所有全是1的正方形/矩形 1234567891011状态计算令dp[i][j] = kdp[i-1][j] &gt;= k - 1dp[i][j-1] &gt;= k - 1dp[i-1][j-1] &gt;= k - 1如果不满足上面的这个条件，以(i,j)为右下角的长度为k的矩形中绝对不可能全是1又因为dp[i][j]也只能从上说的三个方向的正方形延申过来，所以dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]) + 1 &quot;如果dp[i-1][j],dp[i-1][j-1],dp[i][j-1]至少有一个为0，那么(i,j)的三个方向肯定有一个为0，那么没得大一统了，只能最多为1了。否则，看下图&quot;。 所以两个条件一结合就是这个递推式了 12345678910111213141516171819class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix[0].empty()) return 0; int m = matrix.size(),n = matrix[0].size(); int maxlen = 0; //dp一般从下标1开始，申请多一个方便处理边界，但还是要具体问题具体分析 vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0)); for(int i = 1;i &lt;= m;i++)&#123; for(int j = 1;j &lt;= n;j++)&#123; if(matrix[i-1][j-1] == &#x27;1&#x27;)&#123; dp[i][j] = min(min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1]) + 1; &#125; maxlen = max(maxlen,dp[i][j]); &#125; &#125; return maxlen*maxlen; &#125;&#125;; 1277.全为1的正方形子矩阵123456789101112输入：matrix =[ [0,1,1,1], [1,1,1,1], [0,1,1,1]]输出：15解释： 边长为 1 的正方形有 10 个。边长为 2 的正方形有 4 个。边长为 3 的正方形有 1 个。正方形的总数 = 10 + 4 + 1 = 15. 1这一题我们只需要在221题的基础上修改就可以了。dp[i][j]的值是以(i,j)为右下角的正方形的长，那么它&quot;也可以表示以(i,j)为右下角的正方形的个数&quot;.所以最后我们把dp矩阵累加起来就可以了 1234567891011121314151617class Solution &#123;public: int countSquares(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix[0].empty()) return 0; int m = matrix.size(),n = matrix[0].size(); int res = 0; vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0)); for(int i = 1;i &lt;= m;i++)&#123; for(int j = 1;j &lt;= n;j++)&#123; if(matrix[i-1][j-1]) dp[i][j] = min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1])) + 1; res += dp[i][j]; &#125; &#125; return res; &#125;&#125;; 分割类问题 顾名思义就是把一个数按要求拆分成几个部分，问拆分之后生成的最少部分数是多少。 拆分类的题目都可以用dp来做，思路就和找零钱差不多 279.完全平方数1234给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。输入: n = 12输出: 3 解释: 12 = 4 + 4 + 4. 1234567891011121314//思路和找零钱差不多，dp[i]表示拆分i需要的最少的完全平方数的个数class Solution &#123;public: int numSquares(int n) &#123; vector&lt;int&gt; dp(n+1,0x3f3f3f3f); dp[0] = 0,dp[1] = 1; for(int i = 2;i &lt;= n;i++)&#123; for(int j = sqrt(i);j &gt;= 1;j--)&#123; dp[i] = min(dp[i - j*j] + 1,dp[i]); &#125; &#125; return dp[n]; &#125;&#125;; 91.解码方法12345678910一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：&#x27;A&#x27; -&gt; 1&#x27;B&#x27; -&gt; 2...&#x27;Z&#x27; -&gt; 26输入：s = &quot;226&quot;输出：3解释：它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。//问你数字有多少种解码方式 123456789101112131415161718192021222324252627//dp[i]表示前i个字符的解码方式的个数，我们按照第i个字符是否独立编码划分集合(即是否和i-1结合)，一种是独立编码，另一种是与i-1结合编码。//class Solution &#123;public: int numDecodings(string s) &#123; vector&lt;int&gt; dp(s.size()+1,0); //dp[1]和dp[2]是初始值需要特殊处理 dp[1] = s[0] == &#x27;0&#x27; ? 0 : 1; if(s.size() &gt;= 2)&#123; if(s[1] == &#x27;0&#x27;)&#123; //看这个组成的两位数符不符合标准 if(atoi(s.substr(0,2).c_str()) &lt;= 26) dp[2] = dp[1]; &#125; else if(s[0] != &#x27;0&#x27;)&#123; if(atoi(s.substr(0,2).c_str()) &lt;= 26) dp[2] = 2; else dp[2] = 1; &#125; &#125; for(int i = 3;i &lt;=s.size();i++)&#123; //如果i号字符能单独存在 if(s[i-1] != &#x27;0&#x27;) dp[i] = dp[i-1]; //如果i号字符能和i-1号结合 if(s[i-2] != &#x27;0&#x27; &amp;&amp; atoi(s.substr(i-2,2).c_str()) &lt;= 26) dp[i] += dp[i-2]; &#125; return dp[s.size()]; &#125;&#125;; 139.单词拆分123456789给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。说明：拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot; 1这题也可以用dp，dp[i]的集合表示s的前i+1个字符所有的拼接组合方式，值为这些组合方式中是否存在&quot;所有被拆分的部分都在字典中出现&quot;这种情况。我们跟91一样，根据第i号字符是否和i以前的字符组合来划分集合。 12345678910111213141516171819202122class Solution &#123;public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; unordered_map&lt;string,bool&gt; mp; for(auto&amp; c:wordDict) mp[c] = true; vector&lt;bool&gt; dp(s.size(),false); //0号是初值 if(mp[s.substr(0,1)]) dp[0] = true; for(int i = 1;i &lt; s.size();i++)&#123; //从i开始依次向前结合 for(int j = 1;j &lt;= i+1;j++)&#123; //如果[i-j+1,i]在字典出现，只需要再检查dp[i-j]是否能被成功拆分就可以了，如果 if(mp[s.substr(i-j+1,j)])&#123; if(i &gt;= j) dp[i] = dp[i - j]; else dp[i] = true;//特判j == i+1这种情况 &#125; if(dp[i]) break;//如果为true,说明存在某种拆分方式，直接退出 &#125; &#125; return dp[s.size() - 1]; &#125;&#125;; 背包类问题01背包注意点 未优化的情况下，第二维都要从0开始，如果第i个货物放不下，就等于上一层。优化过后，逆着来，就相当于直接等于上一层，所以到j &gt;= v[i]为止就可以了 416.分割等和子集12345678给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。注意:每个数组中的元素不会超过 100数组的大小不会超过 200示例 1:输入: [1, 5, 11, 5]输出: true解释: 数组可以分割成 [1, 5, 5] 和 [11]. 12这一题用01背包来做，我们定义dp[i][j]为前i个元素可以选出来的所有集合，他的值就是这些集合中是否存在和为j的这种集合。所以言下之意就是我们能否在前i个元素中找到和为j的目标集合k。&quot;我们根据这些子集中是否有第i个元素来将所有集合划分成两大类，然后我们只需要看这两大类子集中是否有和为j的子集就可以了。这两大类子集，第一类就是i-1个元素组成的所有子集，第二类就是就是第一类的所有集合中加入一个i号元素。如果第一大类有，那第二大类就没有，如果第二大类没有只需要检查第二大类，因为第二大类所有集合都有i，所以他们的和都有i号元素，那么对于第二大类只要检查有没有和为j - nums[i]的值就可以了。&quot; 事实上这样划分的集合也是不重不漏的，前i个元素的所有集合是由所有含i号元素的集合和不含i号元素的集合一起构成的 1234567891011121314151617181920class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int sum = accumulate(nums.begin(),nums.end(),0); //奇数不可能 if(sum % 2) return false; int target = sum / 2; vector&lt;vector&lt;bool&gt;&gt; dp(nums.size()+1,vector&lt;bool&gt;(target+1,false)); //初始值，后面的边界值处理需要 for(int i = 0;i &lt;= nums.size();i++) dp[i][0] = true; for(int i = 1;i &lt;= nums.size();i++)&#123; //正规01背包未优化的写法，j应该从0开始 for(int j = 0;j &lt;= target;j++)&#123; dp[i][j] = dp[i-1][j]; if(j &gt;= nums[i-1]) dp[i][j] = dp[i][j] || dp[i-1][j-nums[i-1]]; &#125; &#125; return dp[nums.size()][target]; &#125;&#125;; 12345678910111213141516171819class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int sum = accumulate(nums.begin(),nums.end(),0); //奇数不可能 if(sum % 2) return false; int target = sum / 2; vector&lt;vector&lt;bool&gt;&gt; dp(nums.size()+1,vector&lt;bool&gt;(target+1,false)); //初始值，后面的边界值处理需要 for(int i = 0;i &lt;= nums.size();i++) dp[i][0] = true; for(int i = 1;i &lt;= nums.size();i++)&#123; //这里也是01背包未优化，但是j不是从0开始也是对的，我不知道为什么 for(int j = nums[i-1];j &lt;= target;j++)&#123; dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]]; &#125; &#125; return dp[nums.size()][target]; &#125;&#125;; 1234567891011121314151617//优化为一维，倒着来class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int sum = accumulate(nums.begin(),nums.end(),0); if(sum % 2) return false; int target = sum / 2; vector&lt;bool&gt; dp(target+1,false); dp[0] = true; for(int i = 1;i &lt;= nums.size();i++)&#123; for(int j = target;j &gt;= nums[i-1];j--)&#123; dp[j] = dp[j] || dp[j-nums[i-1]]; &#125; &#125; return dp[target]; &#125;&#125;; 474.1和01234567给你一个二进制字符串数组 strs 和两个整数 m 和 n 。请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。示例 1：输入：strs = [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m = 5, n = 3输出：4解释：最多有 5 个 0 和 3 个 1 的最大子集是 &#123;&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;&#125; ，因此答案是 4 。其他满足题意但较小的子集包括 &#123;&quot;0001&quot;,&quot;1&quot;&#125; 和 &#123;&quot;10&quot;,&quot;1&quot;,&quot;0&quot;&#125; 。&#123;&quot;111001&quot;&#125; 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。 123456789101112131415161718192021222324252601b背包，只不过这次相当于有两个包的限制，所以是多维01背包class Solution &#123;public: int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123; vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(strs.size()+1,vector&lt;vector&lt;int&gt;&gt;(m+1,vector&lt;int&gt;(n+1,0))); vector&lt;int&gt; one(strs.size()+1,0); vector&lt;int&gt; zero(strs.size()+1,0); for(int i = 0;i &lt; strs.size();i++)&#123; for(int k = 0;k &lt; strs[i].size();k++)&#123; if(strs[i][k] == &#x27;1&#x27;) one[i+1]++; else zero[i+1]++; &#125; &#125; for(int i = 1;i &lt;= strs.size();i++)&#123; //01背包未优化都要从0开始 for(int j = 0;j &lt;= m;j++)&#123; for(int k = 0;k &lt;= n;k++)&#123; dp[i][j][k] = dp[i-1][j][k]; if(j &gt;= zero[i] &amp;&amp; k &gt;= one[i]) dp[i][j][k] = max(dp[i-1][j-zero[i]][k-one[i]]+1,dp[i][j][k]); &#125; &#125; &#125; return dp[strs.size()][m][n]; &#125;&#125;; 12345678910111213141516171819202122class Solution &#123;public: int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0)); vector&lt;int&gt; one(strs.size()+1,0); vector&lt;int&gt; zero(strs.size()+1,0); for(int i = 0;i &lt; strs.size();i++)&#123; for(int k = 0;k &lt; strs[i].size();k++)&#123; if(strs[i][k] == &#x27;1&#x27;) one[i+1]++; else zero[i+1]++; &#125; &#125; for(int i = 1;i &lt;= strs.size();i++)&#123; for(int j = m;j &gt;= zero[i];j--)&#123; for(int k = n;k &gt;= one[i];k--)&#123; dp[j][k] = max(dp[j-zero[i]][k-one[i]]+1,dp[j][k]); &#125; &#125; &#125; return dp[m][n]; &#125;&#125;; 字符串编辑 **双字符串题(72 1143 10)**的dp[i] [j]表示第一个字符串的前i个字符和第二个串的前j个字符 72.编辑距离650.只有两个键的键盘12345678910111213最初在一个记事本上只有一个字符 &#x27;A&#x27;。你每次可以对这个记事本进行两种操作：Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。Paste (粘贴) : 你可以粘贴你上一次复制的字符。给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 &#x27;A&#x27;。输出能够打印出 n 个 &#x27;A&#x27; 的最少操作次数。示例 1:输入: 3输出: 3解释:最初, 我们只有一个字符 &#x27;A&#x27;。第 1 步, 我们使用 Copy All 操作。第 2 步, 我们使用 Paste 操作来获得 &#x27;AA&#x27;。第 3 步, 我们使用 Paste 操作来获得 &#x27;AAA&#x27;。 *主要是考虑合数i = ab表示i个A可以由a个b时的状态粘贴过来，也可以由b个a状态粘贴过来，取最小值** 1234567891011121314151617class Solution &#123;public: int minSteps(int n) &#123; vector&lt;int&gt; dp(n+1,0x3f3f3f3f); if(n == 1) return 0; dp[1] = 0,dp[2] = 2; for(int i = 3;i &lt;= n;i++)&#123; for(int j = 2;j &lt;= sqrt(i);j++)&#123; if(i % j == 0)&#123; dp[i] = min(min(dp[i],dp[j] + i / j),dp[i/j]+j); &#125; &#125; if(dp[i] == 0x3f3f3f3f) dp[i] = i; &#125; return dp[n]; &#125;&#125;; 10.正则表达式的匹配123456789给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 &#x27;.&#x27; 和 &#x27;*&#x27; 的正则表达式匹配。&#x27;.&#x27; 匹配任意单个字符&#x27;*&#x27; 匹配零个或多个前面的那一个元素所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。示例 1：输入：s = &quot;aa&quot; p = &quot;a&quot;输出：false解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。 1234567只要是涉及到双串(无论是匹配或者是其他操作)，dp时他们的状态数组都是同一种方式，dp[i][j]这题dp[i][j]还是表示S串的前i个字符和P串的前j个字符是否匹配操作还是类似于LCS，对尾部进行判断 1.P[j] == S[i] || p[j] == &#x27;.&#x27;，那么dp[i][j] = dp[i-1][j-1] 2.P[j] == &#x27;*&#x27; 此时若*前面的字符和S[i]不相等,那么可以把*和其前面的字符一起消掉,即dp[i][j]=dp[i][j]||dp[i][j-2] 如果*前面的字符x和s[i]相等，但是s[i-1],s[i-2]...可能都与x相等，这个时候就要考虑消去p的几个才能匹配了，所以我们要把所有可能要消去的元素都枚举一遍，看看是否能成功。 12345678910111213141516171819202122232425262728class Solution &#123;public: bool isMatch(string s, string p) &#123; vector&lt;vector&lt;bool&gt;&gt; dp(s.size()+1,vector&lt;bool&gt;(p.size()+1,false)); dp[0][0] = true; //这里主要是初始化p串不为空，s为空但是也能匹配的这种特殊情况 for(int i = 1;i &lt; p.size();i+=2)&#123; if(p[i] == &#x27;*&#x27;) dp[0][i+1] = dp[0][i-1]; &#125; for(int i = 1;i &lt;= s.size();i++)&#123; for(int j = 1;j &lt;= p.size();j++)&#123; if(s[i-1] == p[j-1] || p[j-1] == &#x27;.&#x27;) dp[i][j] = dp[i-1][j-1]; else if(p[j-1] == &#x27;*&#x27;)&#123; int k = i; //这里是*前面的元素和S[i]不相等或者相等时却不消去S[i]的情况 dp[i][j] = dp[i][j] || dp[i][j-2]; //下面枚举消去连续相等的1、2、3...个 while(k &gt; 0 &amp;&amp; (s[k-1] == p[j-2] || p[j-2] == &#x27;.&#x27;))&#123; dp[i][j] = dp[i][j] || dp[k-1][j-2]; k--; &#125; &#125; &#125; &#125; return dp[s.size()][p.size()]; &#125;&#125;; 股票买卖 给定一支股票的价格数组，问你怎么买卖这支股票利润最该 一次买入，接着卖出才算一次交易 https://leetcode-cn.com/circle/article/qiAgHn/ 这个非常详细，他介绍的状态模板非常好用 1234567//只有今天买入股票才会减少最大交易次数T[i][k][0] 表示在第 i 天结束时，最多进行 k 次交易且在进行操作后持有 0 份股票的情况下可以获得的最大收益；T[i][k][1] 表示在第 i 天结束时，最多进行 k 次交易且在进行操作后持有 1 份股票的情况下可以获得的最大收益。//今天不持股，1.昨天也不持股，今天啥也不做(那今天允许的最大交易次数为k,昨天允许的最大交易次数也为) 2.昨天持股，今天卖掉，但是不影响最大交易次数(今天允许的最大交易次数为k，今天只是卖掉，所以昨天允许的最大交易次数也为k)。因为只有今天买入才会影响交易次数T[i][k][0] = max(T[i - 1][k][0], T[i - 1][k][1] + prices[i])//今天持股，1.昨天就持股，今天啥也不做(那么你最大交易次数为k,昨天最大交易次数还是3) 2.昨天不持股，今天买入，要花掉一次交易次数。(前i天最大只能交易k次，你第i天交易了一次，那么前i-1天最大只能交易k-1次)T[i][k][1] = max(T[i - 1][k][1], T[i - 1][k - 1][0] - prices[i]) 121.股票买卖最佳时机Ⅰ1234567891011给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你&quot;最多只允许完成一笔交易（即买入和卖出一支股票一次）&quot;，设计一个算法来计算你所能获取的最大利润。注意：你不能在买入股票前卖出股票。示例 1:输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。//注意本题只能买入卖出股票一次，也就是只能交易一次，而每次交易都是从买入开始的，所以买入股票之后才是减少了一次交易，所以交易一次后的状态就是持有股票 123456789这一题是最多只卖买一次推导状态转移方程：dp[i][0]：规定了今天不持股，有以下两种情况：昨天不持股，今天什么都不做；昨天持股，今天卖出股票（现金数增加），dp[i][1]：规定了今天持股，有以下两种情况：昨天持股，今天什么都不做（现金数与昨天一样）；昨天不持股，今天买入股票（注意：只允许交易一次，因此今天买入股票就是第一次也是最后一次买，所以dp[i][1]就是今天股票价格的相反数）。 12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; vector&lt;vector&lt;int&gt;&gt; dp(prices.size()+1,vector&lt;int&gt;(2,0)); dp[1][0] = 0,dp[1][1] = -prices[0]; for(int i = 2;i &lt;= prices.size();i++)&#123; dp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i-1]); //只有一次交易，所以买入股票也是第一次买入，所以获得利润一定是这次股票金额的相反数 dp[i][1] = max(dp[i-1][1],-prices[i-1]); &#125; return dp[prices.size()][0];//肯定是最后天不持股前最多，因为只能买入一次，所以今天还有股票，钱一定是负数，还没卖 &#125;&#125;; 12345678910111213//滚动数组优化class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; vector&lt;int&gt; dp(2,0); dp[0] = 0,dp[1] = -prices[0]; for(int i = 2;i &lt;= prices.size();i++)&#123; dp[0] = max(dp[0],dp[1]+prices[i-1]); dp[1] = max(dp[1],-prices[i-1]); &#125; return dp[0]; &#125;&#125;; 122.股票买卖最佳时机Ⅱ123456789//本题允许多次交易给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。示例 1:输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; vector&lt;vector&lt;int&gt;&gt; dp(prices.size()+1,vector&lt;int&gt;(2,0)); dp[1][0] = 0,dp[1][1] = -prices[0]; for(int i = 2;i &lt;= prices.size();i++)&#123; dp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i-1]); //多次交易和一次交易的区别就在这里，多次交易今天买股票就有可能不是第一次交易了 dp[i][1] = max(dp[i-1][1],dp[i-1][0]-prices[i-1]); &#125; return dp[prices.size()][0];//最后一定是没有钱套在股票里面利润高 &#125;&#125;; 12345678910111213//空间优化class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; vector&lt;int&gt; dp(2,0); dp[0] = 0,dp[1] = -prices[0]; for(int i = 2;i &lt;= prices.size();i++)&#123; dp[0] = max(dp[0],dp[1]+prices[i-1]); dp[1] = max(dp[1],dp[0]-prices[i-1]); &#125; return dp[0]; &#125;&#125;; 123.股票买卖最佳时机Ⅲ123给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 &quot;两笔&quot; 交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 1234567891011121314151617//这里用到的就是k=2时的递推模板class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(prices.size()+1,vector&lt;vector&lt;int&gt;&gt;(3,vector&lt;int&gt;(2,0))); //这个初始化很重要，无论是最大交易次数为几次，第一天 dp[1][1][1] = - prices[0],dp[1][2][1] = -prices[0]; for(int i = 2;i &lt;= prices.size();i++)&#123; //其实这里顺着逆着都可以，因为他用到都是昨天的 for(int j = 2;j &gt;=1;j--)&#123; dp[i][j][0] = max(dp[i-1][j][0],dp[i-1][j][1]+prices[i-1]); dp[i][j][1] = max(dp[i-1][j][1],dp[i-1][j-1][0]-prices[i-1]); &#125;zu &#125; return dp[prices.size()][2][0];//自然是最后没有钱套在里面钱最多 &#125;&#125;; 12345678910111213141516//空间优化class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; vector&lt;vector&lt;int&gt;&gt; dp(3,vector&lt;int&gt;(2,0)); dp[1][1] = - prices[0],dp[2][1] = -prices[0]; for(int i = 2;i &lt;= prices.size();i++)&#123; //因为j=2和j=1是独立的空间，所以从后向前和从前向后都一样 for(int j = 1;j &lt;= 2;j++)&#123; dp[j][0] = max(dp[j][0],dp[j][1]+prices[i-1]); dp[j][1] = max(dp[j][1],dp[j-1][0]-prices[i-1]); &#125; &#125; return dp[2][0]; &#125;&#125;; 188.股票买卖最佳时机Ⅳ123给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 1234567891011121314151617181920212223242526//这一题就是上面可以2次交易的一般推广版，只要注意k=1时要特殊处理就行了.下面是优化过后的代码class Solution &#123;public: int maxProfit1(vector&lt;int&gt;&amp; prices) &#123; vector&lt;int&gt; dp(2,0); dp[0] = 0,dp[1] = -prices[0]; for(int i = 2;i &lt;= prices.size();i++)&#123; dp[0] = max(dp[0],dp[1]+prices[i-1]); dp[1] = max(dp[1],-prices[i-1]); &#125; return dp[0]; &#125; int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) return 0; if(k == 1) return maxProfit1(prices); vector&lt;vector&lt;int&gt;&gt; dp(k+1,vector&lt;int&gt;(2,0)); for(int i = 1;i &lt;= k;i++) dp[i][1] = -prices[0]; for(int i = 2;i &lt;= prices.size();i++)&#123; for(int j = 1;j &lt;= k;j++)&#123; dp[j][0] = max(dp[j][0],dp[j][1]+prices[i-1]); dp[j][1] = max(dp[j][1],dp[j-1][0]-prices[i-1]); &#125; &#125; return dp[k][0]; &#125;&#125;; 309. 最佳买卖股票时机含冷冻期123456789给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。示例:输入: [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]//这题还是官方题解比较清晰 1234567891011121314151617181920212223//关于冷冻期，只有卖出股票之后才是冷冻期，才会影响股票的购入，所以冷冻期一定之和购入股票有关系，而购入股票只有在持有股票这种状态才有，所有我们要到持有股票态dp[i][1]思考class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.empty() || prices.size() == 1) return 0; vector&lt;vector&lt;int&gt;&gt; dp(prices.size()+1,vector&lt;int&gt;(2,0)); dp[1][0] = 0,dp[1][1] = -prices[0]; dp[2][0] = max(dp[1][0],dp[1][1]+prices[1]); dp[2][1] = max(dp[1][1],dp[1][0]-prices[1]); for(int i = 3;i &lt;= prices.size();i++)&#123; dp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i-1]); /*现在考虑的是今天结束后你持有股票 1.昨天结束后你就有股票，今天啥也没干 2.你昨天结束之后没有，但是今天要买(所以昨天结束后一定未持股)，那么昨天要么是冷冻期，要么就是前天就没有然后昨天又没买。是否有冷冻期取决于前天到底是否卖出了股票，你前天卖出去了，昨天冷冻期，导致未持股。前天你本来就没股票，然后你昨天也没股票，昨天又没买。 综上，我们只需要保证前天结束之后你没股票，从这个状态过来就可以，所以对于前天而言，我们只需要这一种决策就可以了。因为你前天结束之后没股票，不管他是怎么没的，在我们的要求下昨天都不会买。所以在i-2天没股票的情况下过来，昨天结束之后没股票的钱是等于前天结束之后没股票的钱的。 */ &quot;最新总结，如果你想第i天买股票，那么i-1天必须没股票，但是如果从i-1天直接过来的话会有问题：因为你i-1天不持股的最大价值dp[i-1][0]可能是由于你第i-1天卖出去导致，也有可能是你第i-1天没股，啥也不动(即i-1天之前就获得了最大值)。如果如果dp[i-1][0]是由于第i-1天卖掉股票得到的，会导致今天冷冻期，结果你还买了，违反了冷冻期。所以我们要让第i天买的时候绝对不是冷冻期，所以冷冻期最多在i-1天。所以如果从i-2天过来就不会有这儿问题。为什么呢？因为i-2天之后就铁没股票的(我们从dp[i-2][0]调过来)，然后第i天要买，不管i-2天是怎么弄得，就算有冷冻期，冷冻期也只在第i-1天，对第i天一定影响都没有。还有就是我们从dp[i-2][0]过来之后，要保证第i买股票，所以i-1天必定没股票，也就是第i-1天什么都不操作。在这两层约束下，dp[i-1][0] = dp[i-2][0]的。所以调过来是没问题的&quot; &quot;保证i天不是冷冻期且第i天能买&quot;-&gt;第i-1天绝对没卖且第i-1天结束后没股票-&gt;那么i-1天开始就没股票-&gt;那么只能从i-2天后没股票这个状态过来，即dp[i-2][0]。 dp[i][1] = max(dp[i-1][1],dp[i-2][0]-prices[i-1]); &#125; return dp[prices.size()][0]; &#125;&#125;; 二叉树124.二叉树的最大路径和123456789给定一个非空二叉树，返回其最大路径和。本题中，路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。输入：[1,2,3] 1 / \\ 2 3输出：6 如图，对这样的一棵一般性的树，根的左右孩子都有两条分支。我们只要求A左子树上包括根节点在内最大单侧分支。A右子树的最大单侧分支。再将他们和根节点加起来得到一个值。这三个值最大值就是我们的结果 我们写一个函数，返回的就是root左孩子两个圈的最大值v1和右孩子两个圈的最大值v2。这样整个树路径最大值。只可能在。v1,v2,v1+v2之间取了。考虑到v1,v2都可能为负数，如果是负数对整个最大路径没有增益，所以可以用0来处理。 123456789101112131415161718class Solution &#123;public: //返回包括root在内的左右斜枝的的路径的最大值 int maxOneSide(TreeNode* root,int &amp;value)&#123; if(!root) return 0; int left = maxOneSide(root-&gt;left,value); int right = maxOneSide(root-&gt;right,value); int lmr = max(0,left) + max(0,right) + root-&gt;val; int ret = max(0,max(left,right)) + root-&gt;val; value = max(value,max(ret,lmr)); return ret; &#125; int maxPathSum(TreeNode* root) &#123; int value =INT_MIN; maxOneSide(root,value); return value; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题","slug":"算法/刷题","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"日常生活","slug":"日常生活","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题","slug":"算法/刷题","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"每日计划","slug":"每日计划","permalink":"http://example.com/tags/%E6%AF%8F%E6%97%A5%E8%AE%A1%E5%88%92/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]}