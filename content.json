{"meta":{"title":"恒若时光のblog","subtitle":"","description":"","author":"恒若时光","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2018-01-04T16:00:00.000Z","updated":"2021-01-26T09:07:51.294Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-01-04T16:00:00.000Z","updated":"2021-01-26T09:06:56.251Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MySQL必知必会读书笔记","slug":"MySQL必知必会读书笔记","date":"2021-01-28T13:55:56.000Z","updated":"2021-02-04T12:02:00.755Z","comments":true,"path":"2021/01/28/MySQL必知必会读书笔记/","link":"","permalink":"http://example.com/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","excerpt":"内容补充补一个MySQL语句的执行顺序 1.了解SQL基本概念数据库和数据库软件：数据库是存放一组按某种组织方式组织起来的数据的容器，而这里说的容器是概念性的，这个容器的物理构成是可以多样的，但一般是以计算机中的文件的形式存在(存放在外存之中)。而数据库软件(比如MySQL),他其实是DBMS，它来负责直接对物理数据库进行操作，包括修改、添加(添加则说明DBMS是创建这个数据库容器的软件)、删除数据库。 12345主键和表 表：关系数据库中的数据以表的方式组织起来存放的。表中的每一列代表一个属性，每一个属性在创建时都要给定数据类型。 主键：一般在创建一张表时，默认情况下要指定某一列或某些列为主键。主键是用来区分同一张表中不同的行的，特点是： 1.不同行的主键的值不相同，主键值必须唯一(若是一组列，允许某一列值相同，但是不同出现完全相同的组合方式) 2.主键值不能为空 SQL也称为结构化查询语言，是用来让DBMS识别其语义，来向数据库发出对应操作的一种语言。SQL由标准委员会制定，大部分DBMS都能识别，但是在实现上会有不同，并且不是完全可移植的，也就是不同的DBMS支持SQL会有不同点。","text":"内容补充补一个MySQL语句的执行顺序 1.了解SQL基本概念数据库和数据库软件：数据库是存放一组按某种组织方式组织起来的数据的容器，而这里说的容器是概念性的，这个容器的物理构成是可以多样的，但一般是以计算机中的文件的形式存在(存放在外存之中)。而数据库软件(比如MySQL),他其实是DBMS，它来负责直接对物理数据库进行操作，包括修改、添加(添加则说明DBMS是创建这个数据库容器的软件)、删除数据库。 12345主键和表 表：关系数据库中的数据以表的方式组织起来存放的。表中的每一列代表一个属性，每一个属性在创建时都要给定数据类型。 主键：一般在创建一张表时，默认情况下要指定某一列或某些列为主键。主键是用来区分同一张表中不同的行的，特点是： 1.不同行的主键的值不相同，主键值必须唯一(若是一组列，允许某一列值相同，但是不同出现完全相同的组合方式) 2.主键值不能为空 SQL也称为结构化查询语言，是用来让DBMS识别其语义，来向数据库发出对应操作的一种语言。SQL由标准委员会制定，大部分DBMS都能识别，但是在实现上会有不同，并且不是完全可移植的，也就是不同的DBMS支持SQL会有不同点。 2.MySQL简介 MySQL是一种基于客户服务器的DBMS，服务器端软件来直接访问和处理数据，一般运行在一个专门的服务器上。而这个服务器端软件也就是我们的DBMS本体，比如MySQL这个软件。DBMS处理数据的请求一半来自于客户端软件，客户端软件包括能连接DBMS的程序设计语言编写的软件等。当然这个客户端的软件和DBMS也可以部署到同一台机器上 MySQL的命令行的命令后面要加上;才能执行 12mysql -u root -p //连接数据库quit; //退出数据库连接 3.使用MySQL使用MySQL之前必须要连接上MySQL,连接时需要提供账户和密码，MySQL内部会存有用户的权限等信息，不同的用户对数据库的操作权限也不同 123456常见命令show databases;show tables;use name; //使用某个数据库之前要use一样，这个命令相当于切换当前工作数据库show columns from table_name;//查看表的所有列的属性等describe course_info;//和上面一样 4.检索数据12345678910111213141516select column_name from table; //查询表中某一列的所有数据，注意返回的不一定是有序的select c_id,c_name,c_teacher from course_info;//从一张表中检索多列，都好隔开select * from course_info;//查看所有列select distinct c_score from course_info;//c_score可能有重复值，distinct修饰符会去重只展示不重复的值select distinct c_score,department_id from course_info;//error,对多列去重不可以select c_teacher from course_info limit 5;//limit接一个数，表述输出从第一行开始的5行select c_teacher from course_info limit 4,5;//limit接两个数，表示输出从第5行(我试了一下，给的是4，实际结果是从第5行开始算的 )开始的5行select course_info.c_score from manage_sys.course_info;//.符号的语法，到指定表找指定列，只不过这里.相当于给出了所属关系。 5.排序检索数据 12345678910SQL语句都是由子句构成的，order by和from where都是子句 select c_remain from course_info order by c_remain;//是这样的，他先把一个表中的所有记录按c_remain这个属性排序，排序完之后再展示排序之后的记录中的c_remain这一项。先逻辑操作，再显示&quot;先运算————order by,再投影Select&quot; select c_remain,c_name,c_score from course_info order by c_remain,c_score;//输出多列;先按c_remain对表中所有记录排序，然后对按c_remain排序时相等的记录(也仅对相等的记录)再按c_score排序。两次排序之后再展示排序后记录中的c_remain,c_name,c_score这三列 select c_remain,c_name,c_score from course_info order by c_remain desc,c_score;//先对所有记录按c_remain降序排序，然后对c_remain排序时相等的那些记录按c_score按c_score升序排序，desc只影响他最接近的那个熟悉 select c_remain from course_info order by c_remain desc limit 1;//组合技，输出结果最大值 6.过滤数据12345678910select c_score,c_name from course_info where c_score = 3;//where进行过滤数据select c_score,c_name from course_info where c_department = &#x27;软件学院&#x27;;//如果是字符串用&#x27;&#x27;括起来select c_score,c_name from course_info where c_score = 3 order by c_remain;//order by和where结合时，应该先过滤然后再排序，否则会出错where筛选的逻辑有 = &gt; &lt; != &gt;= &lt;= betweenselect c_remain from course_info where c_remain between 90 and 100;//筛选范围，注意必须是范围的低端点和高端点。select c_id from course_info where c_remain is NULL;//查询是否有空值，如果某一行的c_remain有空值，就返回 7.过滤数据加强版12345and操作符select c_id from course_info where c_score = 3 and department_id = &#x27;001&#x27;;//where的筛选条件用and逻辑操作符连接or操作符select c_id from course_info where c_score = 3 or department_id = &#x27;001&#x27;;//找到所有c_score = 3或者department_id = ‘001’的记录，并返回这些记录中的c_id。其实过程也应该就是在不满足一个条件的记录中再去找那些满足第二个条件的那些记录 由于SQL语句设定的and操作符计算次序优先级比or要高，所以上面的语句会被解析为3 or (1 and 2) 消除歧义的方法就是使用括号提升优先级。使用and 和 or组合时，尽量使用()来明确条件的组合。 1234select c_remain from course_info where c_remain in (80,88,95);//()除了提升优先级之外还可以圈出一个集合，比如上面就圈出了一个数量集合，集合中有80 88 95三个元素，和in操作符结合。这个where条件就是找所有剩余数量为80 88 95的记录用in圈定范围比用or一个一个连接要好，因为in比or快。 select c_remain from course_info where c_remain not in (80,88,95);//用not取个反 8.用通配符进行过滤123456789101112131415select c_teacher from course_info where c_department like &#x27;%学院&#x27;;上面是使用%通配符，他代表任意字符出现任意次数(包括0 1 ...n)组成的字符串(说人话就可以表示任意的字符，包括空)，这里就是找所有记录的department中，以...学院结尾的记录。1.上面的 %学院称为搜索模式;2.搜索语句中使用模式必须加上like操作符(like可做操作符也可以做谓词);3.通配符可以有多个，也可以出现在搜索模式的任意位置，比如&#x27;%han%&#x27;就是代表所有存在han文本的属性4.通配符也匹配不了NULL，检查NULL值只能用is NULL;你&#x27;%&#x27;也不能匹配NULL5.有的MySQL匹配时设置了大小写敏感，那么你&#x27;%H&#x27;是搜索不到&#x27;%h&#x27;的&#x27;_ello&#x27;: -通配符只能匹配一个字，不能多也不能少，即不能出现0次select c_teacher from course_info where c_department like &#x27;_软件学院&#x27;;//这样就是什么也搜不到通配符注意事项1.尽量少用通配符搜索，比较慢2.如果要用，尽量避免把通配符放在开头，放在开头搜索是最慢的 9.用正则表达式进行搜索 正则表达式也是一种模式，where语句可以根据这个模式来匹配文本 1234567891011121314151617181920212223242526272829//1.正则表达式匹配及其特点select c_teacher from course_info where c_department regexp &#x27;科学&#x27;;//正则表达式匹配，他会查找所有记录的c_department,检查其文本中是否有&#x27;科学&#x27;这个模式，即是否有&#x27;科学&#x27;这个文本，有的话就返回。即查看属性值中是否有这个正则表达式模式的文本，用的关键字是regexp1.&#x27;科学&#x27;：这个同样也叫做模式2.&#x27;.科学&#x27;：这个.是正则表达式支持的符号，代表任意一个字符，和&#x27;-&#x27;通配符一样，仅能且必须要代表一个符号，不能空。3.正则表达式的匹配默认不大小写敏感，如果要明确区分大小写，加上binary关键字。select c_teacher from course_info where c_name regexp binary &#x27;WuHanyi&#x27;;//2.通配符模式匹配的特点(比较着看)select c_teacher from course_info where c_department like &#x27;科学&#x27;;//而这个是查找所有记录，查看他们的属性值是否为&#x27;科学&#x27;。即用like就是看属性值是否和我这个模式匹配//3.or连接符select c_teacher from course_info where c_department regexp &#x27;科学 | 学院 | 软件&#x27;;// |表示或运算，连接//4.[]符号select c_teacher from course_info where c_department regexp &#x27;[软件科学]学院&#x27;;//这个[软件科学]的意思是 [软件|科学]，[]括起来的字符也是一种或逻辑，这里让找的c_department中出现&#x27;软件学院&#x27; | &#x27;科学学院&#x27;的文本。//5.[]和 |的对比select c_teacher from course_info where c_department regexp &#x27;软件 | 科学学院&#x27;;//如果这样写,意思就是查找出现&#x27;软件&#x27; | &#x27;科学学院&#x27; 文本的记录//6.[]里面的^符号&#x27;[^软件科学]学院&#x27;:这个就是找除&#x27;软件学院&#x27;和&#x27;科学学院&#x27;以外的所有文本//7.范围匹配&#x27;[1-5] hello&#x27;:范围匹配，也就是&#x27;[12345] hello&#x27;这个模式的简写&#x27;[a-p]&#x27; hello&#x27; :同范围匹配&#x27;[1-5\\\\.]&#x27;:范围匹配，也就是&#x27;[12345\\\\.] hello&#x27;//8.匹配特殊字符如果要匹配有.符号的文本，用&#x27;.&#x27;不行，因为他代表所有字符。所以匹配特殊字符需要加上转义符号&#x27;\\\\&#x27;，转义符号可以原本有特殊意义的符号变为他字符层面的意思。所以匹配的模式是&#x27;\\\\.&#x27; ;一般语言的转移符号都是一个\\，但是mysql需要2个 123上面都是正则表达式定义的特殊符号，举个例子select name from student_info where id regexp &#x27;[:alnum:]&#123;4&#125;&#x27;这个[:alnum:]就是任意数字或字母，而&#123;4&#125;就是指定匹配4次，所以这个意思就是匹配任意数字或字母重复出现4次的文本，比如&#x27;1111&#x27;,&#x27;aaaa&#x27;都是 12345678上面都是定位符，前面说的都是从属性值的任意位置开始匹配，如果想从指定位置开始匹配就要使用上面的定位符select name from s_info where id regexp &#x27;^[1-5//.] hello&#x27;;这个就是在属性的开头，检查有没有&#x27;[1-5//.] hello&#x27;的文本 ^在[]里面和外面有不同的涵义 //正则表达式的测试，也就是不依赖数据库单纯测试表达式是否可行 select &#x27;hello world&#x27; regexp &#x27;d&#x27; 这个测试式子只会返回0或1，有就1，无0,上面式子返回的就是1 10.创建计算字段 所谓计算字段就是本身并不存在于数组库中(即数据库中本没有这一列)，是由DBMS按照输入的SQL语句(应该说是MySQL支持的特殊的SQL语句)来将数据库中的数据进行拼接等逻辑操作处理后返回的特殊数据(特殊处理后的数据)。 使用计算字段就是因为大多数情况下，并不是直接获取数据库中的数据。比如数据库中有商家店名、商店地址这两列，我想要获得店名(商店地址)这样的一种数据，数据库中没有，这时候就需要DBMS将数据库中的数据特殊处理后生成符合我们要求的数据，也就是计算字段。 综上，用函数处理的一堆数据称为计算字段 其实我们也可以在客户端对数据进行组合处理，但是肯定没有DBMS干这事快。 123456789101112//Concat函数拼接生成计算字段select Concat(s_name,&#x27;的&#x27;,c_name,&#x27;成绩为&#x27;,grade) from grade_info;结果就是返回&quot;s_name的c_name成绩为grade&quot;这样一种数据//Trim函数，来去除某一列数据的空格select Concat(RTrim(s_name),&#x27;的&#x27;,c_name,&#x27;成绩为&#x27;,grade) from grade_info;//比如这个就是去掉了s_name右边的空格。以此类推还有LTrim,Trim(两边的空格都去掉)//使用as关键字给计算字段取个别名select Concat(s_name,&#x27;的&#x27;,c_name,&#x27;成绩为&#x27;,grade) as info from grade_info;//给这一串数据取名为info，目前不知道有啥用//真&quot;计算&quot;字段，支持+-*/，可以用()来区分优先级select c_score*c_remain as score from course_info; 11.使用数据处理函数本章只要知道有这么个东西，真正用再来查 大多数的DBMS都支持下列三类函数 文本处理函数 日期和时间处理函数 数值处理函数 12这里面注意的就是Soundex(),有点邪乎，他是找发音匹配的数据比如数据库有个人名为Steve，但是你输入成Stev是找不到的，但是Soundex(Stev)就能找到Steve,感觉没啥用 1234举一个例子，比如数据库中有一列是日期这一项，但是日期是年/月/日 时/分/秒 格式来存放的，你要查找时，完全不记得时/分/秒，你只记得，是几号。那么查找就可以用Data()函数select ord_num,ord_id from order where Data(order_date) = &#x27;2020/1/27&#x27;;//这个感觉很有用select ord_num,ord_id from order where Year(order_date) = &#x27;2020&#x27; and Month(order_date) = 9;//查询2020年9月的所有订单，组合技，也挺有用的 上面是常见的数值处理函数，各大DBMS这个函数好像是一致的 12.汇总数据 1234567891011121314151617181920//AVG返回列的平均值select AVG(grade) from grade_info where s_id = &#x27;sa20225068&#x27;;//返回特定用户的在grade这一列的平均成绩AVG忽略值为NULL的列//Count()确定表中行的数目或者符合特定条件的行的数目1.Count(*):返回表的行数，不管表值是否为NULL,即*时不忽略NULL2.Count(column):返回特定列不为NULL的行数//MAX(column),MIN(column),SUM(column)的用法都是相同的select MAX(c_score*c_remain) from course_info;//处理普通用法之外还可以这么用//聚集不同的值，对于SUM,AVG,Count来说有用select AVG(distinct grade) from grade_info where s_id = &#x27;sa20225068&#x27;;//返回特定条件的grade中，不重复的值的平均值Count只能Count(distinct column),不能Count(distinct *);SUM(distinct c_score*c_remain);这种也是可以的//这些聚集函数还能一起用select AVG(grade) as s_avg, SUM(grade) as s_grd,from grade_info where s_id = &#x27;sa20225068&#x27;;//列属性之间加上,号，而不是换行加, 13.分组数据1234567891011//1.创建分组select c_name,s_id,Count(s_id) as &#x27;学生成绩条数&#x27; from grade_info group by s_id;上面意思是将所以记录按照s_id进行分组，s_id有几个不重复的，就分几组。记录分组之后，他给你返回的数据都是按组进行返回的。分组后的Count(s_id)也是由系统自动按组计数的 如下图所示，按s_id分组之后只有两组，所有返回的数据都是两行。虽然每一组c_name的取值也有多个，但是按组返回，返回的就是每一组s_id的第一个c_name(这个应该是随机的，我也只是看到现象) //2.注意点1.GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。2.如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。3.除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。(那我下面截图中的示例语句是错的)正确应该是 select c_name,s_id,Count(s_id) as &#x27;学生成绩条数&#x27; from grade_info group by s_id,c_name; 我是按s_id分组的，所以最后每个s_id就可以代表一个分组，最后投影投的是分组，也就是s_id 12345678//3.过滤分组，MySQL使用having子句过滤分组；where子句处理不了分组，只能过滤行select s_id,Count(s_id) from grade_info where grade &gt; 10 group by s_id having Count(s_id) &gt; 3;这个筛选顺序是这样的：先去找出所有grade大于10的行，然后再把找出的这些行按s_id分组，然后计算count(s_id),此时Count(s_id)就是每个分组的s_id数目了，最后再筛选出分组中(s_id)个数大于2的分组，最后再提取分组的s_id，计算字段。(再提醒一句，select子句的列除了计算字段外其他都要是group子句中的列)//4.group by和order by结合select s_id,AVG(grade) as a_grd from grade_info group by s_id having Count(s_id) &gt; 1 order by a_grd;先按s_id分组，然后按分组，然后计算分组的Count(s_id)之后筛选，最后再将筛选出来的分组按照计算字段a_grd排序，最后投影。&quot;注意这里面排序貌似可以不用select子句后面的属性，但是把，你是输出这些玩意，肯定要按你投影的某个属性来排序，所以这里是按出现在select子句后面的计算字段来排序的&quot;注：还有一点，我终于知道了给计算字段取别名有啥用了 最后再总结一下select子句的各个关键字： 14.使用子查询123456789101112131415161718192021//1.利用子查询进行过滤假设订单号和订单物品的关系存储在表A中，用户和订单号的关系存储在表B中，我现在有这么个需求：我要查询所有买过商品&#x27;TNT_2&#x27;的用户的u_id,为完成这个功能，我们可以分两步来做1.根据prod_id = &#x27;TNT_2&#x27;在表A中筛选出订单号order_id2.在B中根据1筛选出来的订单号来筛选u_id但是上面的功能可以使用嵌套子查询来完成select u_id from B where order_id in (select order_id from A where prod_id = &#x27;TNT_2&#x27;);1.子查询语句是从内向外执行的，也就是嵌套在最里面的()中的select语句先执行，然后逐渐到外层。2.子查询一般和in搭配使用，当然也可以用 = !=等逻辑3.()套着的查询语句称为子查询语句//2.子查询替代计算字段select c_department,(select Count(*) from course_info where department_id = &#x27;001&#x27;) as course_num from course_info;也就是计算字段也可以用子查询语句代替//3.相关子查询————涉及外部查询的子查询select cust_name,cust_state, (select Count(*) from orders where orders.cust_id = customers.cust_id) as orders from coustomers;orders.cust_id = customers.cust_id这个用到了全限定命名，原因是不加全限定，他会认为cust_id都是orders表的，即orders.cust_id = orders.cust_id; 用了全限定命名之后就称为相关子查询了，当然逻辑是因为你涉及外部查询-&gt;不得不提全命名限定 在customers表中cust_id是唯一的，所以orders.cust_id = customers.cust_id就是用customers的cust_id去订单表匹配cust_id相同的记录 15.联接表12345678910111213//1.关系数据库的设计优点现在我想存储商品信息还有商品的供应商信息，如果存在一张表中会造成冗余即大量的空间浪费，我们用一张表只存商品信息，另一张存供应商信息，这个时候我们需要建立这两张表之间的联系，此时我们可以设立外键来建立两张表之间的联系。我们把供应商id作为供应商表的主键，然后在商品表中设立一列，这一列存放这个商品的供应商id，那么对于商品表来说，供应商id就是他的外键。这样供应商的信息改变只需要需改供应商表就可以的，对与他有关系的其他表没有影响。&quot;外键&quot;：是表的一列，这一列是数据库中其他表的外键，通过外键来构建表之间的联系关系数据库优点：关系数据库的可伸缩性比较好，即能适应不断增加的工作量而不失效。//2.创建联结如下图所示的语句，select子句的列来自于不同的表，from子句之后也是跟着两个要联结的表的表名，两个表根据where的条件进行联结。如果不使用where子句来联结，输出的结果就是两张表的笛卡尔积(表A的每一行都和表B的所有行拼接，生成的结果有很多是没意义且不需要的)。这里的where条件就是将表vendors的vend_id值和表products的vend_id值相等的行拼接起来(以表的形式看就是生成了一张新表，这个新表每一行= vendors表一行+products表的一行 这种形式),在vendors中vend_id是主键，唯一。1.&quot;联结也不是数据库存在的东西，他们DBMS根据逻辑计算出来的结果&quot;2.这里where条件创建的都是等值联结，根据两个表的值相等建立连接;也称为内部联结3.还有一种特殊写法也能完成下面图片的同样功能，是inner join语法的 select vend_name,prod_name,prod_price from vendors inner join products on vendors.vend_id = products.vend_id; 同时还可以联结多个表，如下图所示 注意products.vend_id = vendors.vend_id 和后面的那一句才是等值联结的条件，order num = 20005这个是筛选条件，筛选出前两个等值联结条件建立的联接表的行 16.创建高级联结除了可以给列、计算字段取别名外，还可以给表取别名，如下图所示 使用不同的类型联结：自联结、自然联结、外部链接(上一章是内部联结) 1234//1.自联结，如下图所示1.在from子句后面取的别名在前面的select子句就可以用2.自联结就是两张相同的表联结，因此必须要是使用全限定命名3.他的速度有时候比一般的子查询速度要快 123456//2.自然联结两张表联结的基础就表中存在相同的列，那么普通的等值连接生成联接表中会有多个相同的列,自然联结就是生成的联接表中相同的列只出现一次。但是现在的内部联结基本都是自然联结，也就是把重复列合并了，我们也不要考虑(....😔) //3.外部联结，见下图内部联结时，表A和表B中相同列值的行联结到一起，但是有时候也想把某张表不相同的行也包含进来，此时就需要外部联结。加入我把A B联结，时把A中列值不相等的行也并入到联接表中，那么在联接表中自然没有与之对应的B表的行的信息，所以在联接表中对应的值就是NULL 外部联结和内部联结语法相似outer join，但是要加上left或者right，他表示把outer join子句左边的表的列值不相等行加入联接表还是右边。比如下图，左边就是customers表，右边就是orders表 12//4.联结中使用聚集函数，如下图先内部联结生成联接表，然后再对生成的联接表分组，最后再对分组投影计算字段 17.组合查询组合查询就是将多条select语句的输出结果结合起来 1234//1.使用union关键字创建组合查询1.看情况使用(目前没实战，不清楚)，下面这个例子其实在where条件中用或连接起来也可以2.两个select语句的结果集是合并到一起输出的(前提是两条语句输出的列是一致的，不然也没意义)，如果两条语句的结果有重复，MYSQL会自动合并，如果不想合并重复就在union后面加all3.如果要对组合查询结果集排序，那么order by子句应该放在最后一个select语句的后面，也就是只能出现一次。但是放在最后不代表只对最后一个select语句的结果排序，他是回对所有select语句组合到一起的结果排序 18.全文本搜索(了解)123456789101112//1.理解全文本搜索1.MySQL支持多种数据库引擎，并非所有引擎都支持全文本搜索，Innodb不支持，MyISAM支持。2.全文本搜索相比于前面说的通配符匹配、正则表达式搜索有以下好处： 1.通配符匹配和正则表达式搜索需要检索所有的行，所以比较耗时，全文本搜索不需要 2.通配符匹配和正则表达式搜索很难指定匹配什么，不匹配什么，他们只有和每一行都匹配一下才知道匹不匹配 3.通配符匹配和正则表达式搜索搜索一个词时，会返回所有含该词的行，而不区分只含一次的行和含多次的行(即多次出现) //2.使用全文本搜索1.为了进行全文本搜索，必须对被搜索的列添加索引，而且要随着数据的改变不断地重新索引。在对表列进行适当设计后，MySQL会自动进行所有的索引和重新索引。在索引之后，SELECT可与Match()和Against()一起使用以实际执行搜索。2.下图是建表时创建索引，在fulltext()语句添加被索引的列，多行用,隔开。3.可以在创建表时指定FULLTEXT，或者在稍后指定（在这种情况下所有已有数据必须立即索引————目前不懂啥意思）。4.不要在导入数据时使用FULLTEXT，应该首先导入所有数据，然后再修改表，定义FULLTEXT，这样有助于更快地导入数据 123455.在索引之后，使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。如下图，Match(note_text)指示MySQL针对指定的列进行搜索，Against(&#x27;rabbit&#x27;)指定词rabbit作为搜索文本。注意以下几点 1.搜索文本为中文时多半会失败 2.传递给Match()的值必须与FULLTEXT()定义中的相同。如果指定多个列，则必须列出它们（而且次序正确）。 3.搜索不区分大小写 除非使用BINARY方式（本章中没有介绍），否则全文本搜索不区分大小写 4.全文本搜索的会对结果排序(如果是通配符like匹配，不用order by是不会给你排序的)。具有较高等级的行先返回，而这个等级rank由MySQL根据行中词的数目、唯一词的数目、整个索引中词的总数以及包含该词的行的数目计算出来。。 12345678//3.使用查询扩展，例子如下图❑ 首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有行；下图就是找出所有包含&#x27;anvils&#x27;的行❑ 其次，MySQL检查这些匹配行并选择所有有用的词（这个靠mysql发挥）。❑ 再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还使用上面检索到的所有有用的词来搜索。书上的例子：第一个记录包含词anvils，因此等级最高。第二个记录与anvils无关，但因为它包含第一行中的两个词（customer和recommend），所以也被检索出来(这个就是mysql认为有用的词)。第3行也包含这两个相同的词，但它们在文本中的位置更靠后且分开得更远，因此也包含这一行，但等级为第三。第三行确实也没有涉及anvils（按它们的产品名）。 查询扩展用来设法放宽所返回的全文本搜索结果的范围。说白了就是返回更多可能的结果而不是只返回和查找文本匹配的结果,但是这些可能的结果不一定有用 1234567//4.使用布尔文本搜索1. 使用布尔文本搜索可以提供的线索有以下 ❑ 要匹配的词； ❑ 要排斥的词（如果某行包含这个词，则不返回该行，即使它包含其他指定的词也是如此）； ❑ 排列提示（指定某些词比其他词更重要，更重要的词等级更高）; ❑ 表达式分组；2. 布尔方式不同于迄今为止使用的全文本搜索语法的地方在于，即使没有定义FULLTEXT索引，也可以使用它。但这是一种非常缓慢的操作（其性能将随着数据量的增加而降低）。 1234563. 上图就是布尔方式的所有操作符，在下面展示他们的用法 1. &#x27;heavy -rope*&#x27; :就是匹配所有包含heavy但是不包含任意以repo开头的词(如repos)的行,*是通配符，替代任意多个词 2. 匹配包含词rabbit和bait的行，两个都必须有。 3. 没有指定操作符，这个搜索匹配包含rabbit和bait中的至少一个词的行(搜索得到的集合大于加+操作符的)。所以只有一个单词的话加不加+都是无所谓的，不加+他也没得选 4. 搜索匹配短语rabbit bait而不是匹配两个词rabbit和bait。 5. 匹配rabbit和carrot，增加前者的等级，降低后者的等级。 1234567//5.使用说明❑ 在索引全文本数据时，短词被忽略且从索引中排除。短词定义为那些具有3个或3个以下字符的词（如果需要，这个数目可以更改）。❑ 许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。因此，MySQL规定了一条50%规则，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略。50%规则不用于IN BOOLEAN MODE。❑ 如果表中的行数少于3行，则全文本搜索不返回结果（因为每个词或者不出现，或者至少出现在50%的行中）。❑ 忽略词中的单引号。例如，don&#x27;t索引为dont。❑ 不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果。❑ 如前所述，仅在MyISAM数据库引擎中支持全文本搜索。 19.插入数据123456789101112131415161718192021222324252627282930313233343536//1.数据插入1.INSERT是用来插入（或添加）行到数据库表的。插入可以用几种方式使用： ❑ 插入完整的行； ❑ 插入行的一部分(某些列)； ❑ 插入多行； ❑ 插入某些查询的结果。//2.插入一行 insert into grade_info values(&#x27;202000008&#x27;,&#x27;test1&#x27;,&#x27;ios&#x27;,&#x27;74&#x27;,&#x27;12345678&#x27;);//这种方式是使用默认的表中列的定义次序，但是表列的次序可能改变，所以这是不安全的。并且这种方式下除非所有列都可以不填，只有一个列必须要填值，那么你就不能在values里面省去可以不填值的列的值。 create table test(id int not null auto_increment,name char(50) null,primary key(id)); insert into test values(&#x27;hello&#x27;);//错误，因为按照表列的定义次序，他是有两列的，你这里只给出一列值，不行 insert into test(name) values(&#x27;hello2&#x27;);//此时只能用第二种方式 但是如果是所有列都可以不填值，比如下面这张表 create table test1(id int not null auto_increment,name char(50) not null default &#x27;haha&#x27;,primary key(id))engine = InnoDB; insert into test1 values();//此时第一种方式写也可以 insert into grade_info(score_id,s_name,c_name,grade,s_id) values(&#x27;202000008&#x27;,&#x27;test1&#x27;,&#x27;ios&#x27;,&#x27;74&#x27;,&#x27;12345678&#x27;);//这样的写法才是安全的，提供了列名，VALUES必须以其指定的次序匹配指定的列名，不一定按各个列出现在实际表中的次序。其优点是，即使表的结构改变，此INSERT语句仍然能正确工作。 如果score_id设置为自增或者允许NULL还可以像下面这样，自增的那一列省略掉，&#x27;所以这个就是插入行的一部分&#x27; insert into grade_info(s_name,c_name,grade,s_id) values(&#x27;test1&#x27;,&#x27;ios&#x27;,&#x27;74&#x27;,&#x27;12345678&#x27;); 插入行时指定列但是又省区了某些列，省去的列要满足以下要求： ❑ 该列定义为允许NULL值（NULL即无值或空值）。 ❑ 在表定义中给出默认值(比如自增)。这表示如果不给出值，将使用默认值。如果对表中不允许NULL值且没有默认值的列不给出值，则MySQL将产生一条错误消息，并且相应的行插入不成功。 数据库经常被多个客户访问，对处理什么请求以及用什么次序处理是MySQL的任务。INSERT操作可能很耗时（特别是有很多索引需要更新时），而且它可能降低等待处理的SELECT语句的性能。如果数据检索是最重要的（通常是这样），则你可以通过在INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL降低INSERT语句的优先级，insert low_priority into,这也适用于下一章介绍的UPDATE和DELETE语句。 //3.插入多行 可以连着使用多条上面的插入单行的语句组合完成，也可以像下面这样,values后面接多组值，多组值用,隔开 insert into grade_info(s_name,c_name,grade,s_id) values(&#x27;test1&#x27;,&#x27;ios&#x27;,&#x27;74&#x27;,&#x27;12345678&#x27;)， values(&#x27;test2&#x27;,&#x27;ios1&#x27;,&#x27;76&#x27;,&#x27;123456789&#x27;); //这个方式比连续使用多条快 //4.insert与select语句结合 如下图所示，将表Aselect的结果插入到表B中. INSERT SELECT中的列名:这个例子在INSERT和SELECT语句中使用了相同的列名。但是，不一定要求列名匹配。事实上，MySQL甚至不关心SELECT返回的列名。它使用的是列的位置，因此SELECT中的第一列（不管其列名）将用来填充表列中指定的第一个列，第二列将用来填充表列中指定的第二个列，如此等等。这对于从使用不同列名的表中导入数据是非常有用的。&#x27;他们抄的列的数量应该要是相同的&#x27; 20.更新与删除数据12345678910111213141516171819//1.更新数据 1.使用UPDATE语句，用两种方式使用UPDATE：❑ 更新表中特定行；❑ 更新表中所有行。 2.使用update语句时不要省略WHERE子句,因为稍不注意，就会更新表中所有行。 3.基本的UPDATE语句由3部分组成，分别是： ❑ 要更新的表； ❑ 列名和它们的新值； ❑ 确定要更新行的过滤条件。 4.update grade_info set s_name = &#x27;test2&#x27; where s_id = &#x27;1&#x27; and grade = 86;//如果不用where选定行，他会更新所有行的s_name 5.update grade_info set s_name = &#x27;test3&#x27;,c_name = &#x27;azhe&#x27; where s_id = &#x27;1&#x27; and grade = 86;//更新多列，用,隔开 6.UPDATE语句中可以使用子查询，使得能用SELECT语句检索出的数据更新列数据。 7.为了删除某个列的值，可设置它为NULL（假如表定义允许NULL值），如下面这个 update grade_info set grade = NULL where grade = 82;//2.删除数据 1.使用DELETE语句删除行有两种方式：❑ 删除特定行；❑ 删除所有行。 2.delete也不要省略where子句，除非你要删所有行。但是如果想从表中删除所有行，不要使用DELETE。可使用TRUNCATE TABLE语句，它完成相同的工作，但速度更快（TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据）。 3.删除列使用update，delete只能以行为单位删除 4.delete from grade_info where s_id = &#x27;12345678&#x27;; 5.DELETE语句从表中删除行，甚至是删除表中所有行。但是，DELETE不删除表本身，删除表用drop。 21.创建和操纵表123456789101112131415161718//1.创建表，如下图 1.NULL值就是没有值或缺值。允许NULL值的列可以在插入行时不给出该列的值，那么插入行的这一列就是没有值，展示给用户为NULL。不允许NULL值的列在插入或更新行时，必须要明确给出该列的值。 2.NULL为默认设置，如果不指定NOT NULL，则默认指定的是NULL。 3.NULL和空串有区别的，空串比如&#x27;&#x27;，他表示有值，但是值为空串，所以not null可以有空串。而NULL是没有值 4.主键是在最后给出，主键为多列时，可以在()中用,隔开 5.AUTO_INCREMENT标识这一列是自增，也就是插入一行时，系统将这一列的值自增1,并赋值到插入行中 6.每个表只允许一个AUTO_INCREMENT列，而且它必须被索引（如，通过使它成为主键，可以通过主键索引快速定位到对应行）。 7.如果一个列被指定为AUTO_INCREMENT，你在在INSERT语句中指定一个值，只要它是唯一的（至今尚未使用过），该值将被用来替代自动生成的值。后续的增量将在该手工插入的值基础上自增。 8.可使用last_insert_id()函数获得某表最后一个AUTO_INCREMENT值 9.cust_city char(50) NOT NULL default &#x27;北京&#x27;, //给一列添加默认值，NOT NULL default和NULL default都可以。 假设我建立下面这张表 create table test1(id int not null auto_increment,name char(50) not null default &#x27;haha&#x27;,primary key(id))engine = InnoDB; 那么我insert into test1 values();就可以，因为两列一个auto increment,一个有默认值，所以可以都不填 10.不同的数据库引擎 ❑ InnoDB是一个可靠的事务处理引擎，它不支持全文本搜索； ❑ MEMORY在功能等同于MyISAM，但由于数据存储在内存（不是磁盘）中，速度很快（特别适合于临时表）； ❑ MyISAM是一个性能极高的引擎，它支持全文本搜索（参见第18章），但不支持事务处理。 外键不能跨引擎，即使用一个引擎的表的外键不能是不同引擎的表的主键。 123456789//2.更新表 alter table test1 drop column name;//给表删除列 alter table test1 add column age int;//给表添加列//3.删除表 drop table test1;//4.更改表名 rename table test to test3; 22.使用视图12345//1.什么是视图？ 首先我们考虑一个场景，如果你需要频繁的使用多张表联接之后的结果，比如频繁的select，那么每次select时要写的代码太多了，比较麻烦，此时我们想要一种类似于编程语言函数一样的东西，向外提供接口，可供我们多次调用。其实，视图就类似于一个向外提供接口的函数，这个函数将sql语句封装起来，可以供我们重复调用。————所以视图主要用来简化我们的查询操作的。 比如下图这个例子，每次先把表联结之后再筛选联接表这样的语句写起来很长很麻烦，我们可以把创建联接表的sql语句封装成一个函数————即视图。然后每次筛选这个视图就可以了。虽然视图只是对sql语句的封装，但是你可以直接在逻辑上把这个视图看成他封装的sql语句执行后的结果，即一张虚拟表。而且也可以把则个视图当作表来操作。 之所以称他为虚拟表，是因为他最后是他封装的sql语句执行后的结果，是经过计算的，并不是数据库实实在在的表，他是在数据库中存在的基本表的基础上创建的新关系(一个视图可以是一个或多个基本表计算后的结果)。 比如下下张图，我们把这个联接表的创建sql语句封装成一个名为productcustomers的视图，可以把这个视图当作一个虚拟表来直接使用。 1234567891011121314//2.视图的规则与限制 1.视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。 2.对于可以创建的视图数目没有限制。 3.为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。 4.视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。(但是视图嵌套会降低查询效率) 5.ORDER BY可以用在视图中，但如果从该视图检索数据的SELECT语句中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。 6.视图不能索引，也不能有关联的触发器或默认值。 7.视图可以和表一起使用。比如将视图的表联结到一起。//3.使用视图 1.视图用CREATE VIEW语句来创建。如下图 2.使用SHOW CREATE VIEW viewname；来查看创建视图的语句(即视图封装的SQL语句)。 3.用DROP删除视图，其语法为DROP VIEW viewname; 4.更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创建一个视图；如果要更新的视图存在，则第2条更新语句会替换原有视图。 12//4.使用视图的一些骚操作 视图搭配计算字段来控制格式化输出，如下图，将创建格式化输出的计算字段语句封装成一个视图，并且我们也在这里看到了取别名的另一个好处，就是可以在创建成视图之后在视图之外也可以直接使用。 12//5.更新视图 视图是可以更新的，修改视图会导致最终其关联的基表的值也被改变(同理对基表的修改也会呈现到视图中来)。但是有些情况不能更新视图，情况很多，但是更新视图很少，更多还是用视图来检索数据，所以就不记了。 23.使用存储过程mysql命令行创建存储过程实例 123456789101112131415161718192021222324//1.什么是存储过程 当我们做非常复杂的查询时，需要很多条sql语句配合执行，每次键入就很麻烦，所以我们可以将多条sql语句封装成一个函数，以后使用时调用这个函数就可以了，这个函数就称为存储过程。和视图不同的一点就是视图是只用来辅助查询(至少我现在见到的都是这样的)或者说仅包含sql语句，但是存储过程之中可以有多种不同的sql语句以及各种不属于的sq语句的控制流语句。 //2.使用存储过程 因为存储过程是一个函数，所有他和其他编程语言调用函数的方式是相同的。 call productpricing(@low,@high) //类似于调用函数，同时传递参数，这里相当于传入两个变量进去，函数会对这个变量赋值，但是这里low和high两个变量不需要事先创建，@low这个语句就相当于创建了一个名为low的变量并传入函数。注意就算这个存储过程没有参数，调用时也需要将括号带上，和一般语言的函数调用一样。 //3.创建存储过程 如下图所示，begin和end指明了存储过程中包含的sql语句体。在上面的语句还指明了这个存储过程的名字和参数。 这个存储过程的调用就是call productpricing() 还要注意的一点就是如果在mysql的命令行定义存储过程，因为mysql命令行这个程序会存储过程中定义的sql语句的;当成结束分隔符，会导致出现语法错误，所以在命令行定义时要特殊处理。 delimiter // 这个delimiter是告诉命令行程序&quot;//&quot;是新的分隔符，当然分隔符可以随便定义，除了\\符号 create procedure productpricing() begin select Avg(pro_price) AS priceaverage from products; end // 这里新定义的分隔符告诉命令行程序存储过程定义到这里结束，之前是使用;作为分隔符的 delimiter ; 这里是将分隔符重新定义为; 因为命令行输入到这里结束，按照惯例还是以;来结束分割 &quot;这个上面演示的代码不是全部输入在一行的，具体的例子看上面的黑框图，有两种方式&quot; //4.删除存储过程 和所有的删除一样，drop+类型+存储过程名 drop procedure productpricing 注意存储过程和数据库中的表、视图等一样，不能覆盖，只能删了然后重建 12345//5.使用参数 如下图所示，我们创建了一个带有参数的存储过程。 out p1 decimal(8,2)：out定义这个存储过程要传出的一个变量(返回给调用者的返回值)，将来在存储过程的sql语句中可以将select到的结果into到这个变量p1中(相当于在函数内部对返回值取的名字)————总之就是在用out定义了一个变量之后，函数内部就把这个变量名当作一个输出值来看，可以给它赋值。遵循这个参数定义，调用者将变量传进来，存储过程在这里面给它赋值。有点类似于c++的引用传递。decimal(8,2)是指这个结果是一个长度为8位的十进制数，其中小数部分长度为2位。 call productpricing(@low,@high,@avg);对下面定义的这个存储过程调用之后，如果想要使用这些变量可以 select @low,@high;来直接查看变量的值 123如下图，in相当于在函数内部定义了一个输入变量，在函数内部可以直接使用这个输入变量(注意看这个输入变量的类型和out变量类型不相同)。 比如我们调用函数可以写为call ordertotal(2005,@total); 然后select @total;查看函数处理后的变量值 123456789//6.智能存储过程 其实就是在sql语句的基础之上又加入了流程控制语句，如下图 1.--是存储过程内注释的开头 2.BOOLEAN就是bool类型，非0整数都被当作true 3.declare也是定义变量，不同于in out是在函数形参中定义的变量，函数体内定义变量就用declare 4.函数名后面的comment也是注释一样东西，SHOW PROCEDURE STATUS可以看到(这个语句是查看存储过程的所有基本信息)//7.显示存储过程的定义语句 show create procedure ordertotal;//和查看视图一个样的方式，主要是能看到存储过程的声明和定义体 24.使用游标12345678910111213141516171819202122232425262728293031//1.什么是游标cursor 传统的sql语句在检索之后返回的是满足某一条件的结果集，也就是若干行的集合，存放在内存的某一位置。普通的sql语句无法再寻找这若干满足要求的结果集中具体某一行(如果想要操作具体某一行只能根据更多的条件来继续筛选)。这个时候就可以用游标了，他是sql语句返回的结果集(行集)，允许程序对结果集的每一行执行相同或不同的操作，而不是对整个行集合执行同一个操作。 特点： 1.不敏感：数据库可以选择不复制结果集 2.只读 3.不滚动：游标只能向一方向前进，并且不可以跳过任何一行数据(即只能从第一行开始一行一行的向下寻找) 游标的适用场景： 1.存储过程 2.函数 3.触发器 4.事件 //2.使用游标 使用游标的顺序一般是:声明游标、打开游标、读取数据、关闭游标、删除游标。 几个注意点 1.游标定义(声明)之后一定要打开游标来使用(即不能定义着却不用)，当然读取游标的数据之前也需要打开游标 2.游标定义时其实还没有检索数据 3.游标结束使用时一定要关闭 4.mysql的游标只能定义在存储过程里面 5.游标可以多次打开和关闭//3.创建游标 DECLARE cursor_name CURSOR FOR select_statement //在存储过程中除了可以用declare定义变量也可以用declare定义游标。例子如下图 //4.打开游标 OPEN cursor_name; 比如OPEN ordernumbers; 打开游标时，会执行游标定义的select语句，并分配内存存放select语句返回的结果 //5.关闭游标 OPEN cursor_name; 注意如果不主动关闭游标，也会在存储过程的end时系统自动隐含关闭游标，释放游标所占的资源。 12//6.读取数据 FETCH cursor_name INTO var_name1,var_name2,...;//从第一行开始读取游标中的行，并写入var_name1,var_name2...中(如果游标中的行有多列)，读完之后游标中的指针指向结果集的下一行 1234567891011121314151617181920游标举例delimiter //create procedure p1()begin declare id int; declare name varchar(100) character set utf8; declare done int default 0; -- 声明游标 declare mc cursor for select stuId,stuName from student where stuAge &gt;19; declare continue handler for not found set done = 1; -- 打开游标 open mc; -- 获取结果 fetch mc into id,name; --读取第一行的数据到变量中 -- 这里是为了显示获取结果 select id,name; -- 关闭游标 close mc;end //delimiter ; 更多的例子看 https://www.cnblogs.com/oukele/p/10684639.html 25.使用触发器12345678910111213141516171819//1.什么是触发器 1.如果你想要某条SQL语句（或某些语句————比如存储过程）在事件发生时自动执行。比如每当订购一个产品时，都从库存数量中减去订购的数量；此时就需要使用触发器 2.触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句 DELETE INSERT；UPDATE。其他MySQL语句不支持触发器。//2.创建触发器 创建触发器时要给出4点信息： 1.唯一的触发器名(最好在全数据库范围内使用唯一的触发器名)； 2.触发器关联的表； 3.触发器应该响应的活动（DELETE、INSERT或UPDATE）； 4.触发器何时执行（处理之前或之后————after or before） 例子如下:创建一个名为newproduct的触发器，在对products表执行insert事件之后触发，触发器对应的sql语句是select &#x27;Product added&#x27;,即打印一条语句。for each row就说明对每个插入的行都会触发这个触发器 只有表才支持触发器，视图不支持（临时表也不支持）。 创建一个触发器，只能关联一个表(不能和多个表关联)的一个事件，但是after delete和before delete相当于两个事件,所以每个表最多支持6个触发器（每条INSERT、UPDATE和DELETE的之前和之后）。如果你需要一个对INSERT和UPDATE操作执行的触发器，则应该定义两个触发器. 如果BEFORE触发器失败，则MySQL将不执行请求的操作(触发器包含的sql语句)。此外，如果BEFORE触发器或语句本身失败，MySQL将不执行AFTER触发器（如果有的话）。 12345678910111213141516171819202122232425//3.删除触发器 drop trigger newproduct; //4.使用触发器 关于before和update注意的一点：当你要对某个表要执行某个操作(uodate delete insert)，操作执行前DBMS就知道了，也就是DBMS确切知道了将要对这个表执行这个操作。然后他才会在执行这个操作之前触发before触发器(如果有)，在执行这个操作之后触发after触发器。如果压根没有发出相应的操作，before触发器也是不会被触发的(否则他不是一直被触发吗)。 关于NEW和OLD的注意点：NEW是你insert语句中携带的行数据，OLD是你要更新(更新前)或删除的行的数据。 1.insert触发器： ❑ 在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行； ❑ 在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值）； ❑ 对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值。 例子如下面第一张图，NEW这个虚表就代表被插入的行，所以这个触发器包含的语句就是选出被插入行的order_num列 通常，将BEFORE用于数据验证插入行之前验证数据（目的是保证插入表中的数据确实是需要的数据）。 2.delete触发器 ❑ 在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表(和NEW类似)，访问被删除的行； ❑ OLD中的值全都是只读的，不能更新。 OLD就代表要被删除的行，所以OLD.order_num就是被删除行的对应列，表中任意行被删除前都要执行这个存储过程 3.update触发器 ❑ 在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值； ❑ 在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）； ❑ OLD中的值全都是只读的，不能更新。 下面的例子保证州名缩写总是大写（不管UPDATE语句中给出的是大写还是小写）; 具体的含义就是，若你将来会对vendors表执行一条update语句，那么在DBMS收到请求之后、执行这个语句之前，会触发before update触发器，这个触发器会将要插入的数据中的vend_state设置为大写，也就是直接修改了待插入的数据，然后再插入。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"leetcode题型总结","slug":"leetcode题型总结","date":"2021-01-25T15:23:48.000Z","updated":"2021-01-26T09:44:49.094Z","comments":true,"path":"2021/01/25/leetcode题型总结/","link":"","permalink":"http://example.com/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/","excerpt":"双指针​ 目前刷到的双指针题目主要有三种 夹逼型：左右指针初始时分别指向左端点和右端点，然后根据某种条件向中间夹，一般这种情况要求数组有序(无序比如翻转数组) 双指针维护滑动窗口类型：即指针p逐个向后遍历，指针q要按某种条件移动，指针(q,p)就维护了一个区间，这个区间会不断移动，也叫做滑动窗口。这个窗口不一定是有固定长度的，具体要看题目的条件。1.滑动窗口的条件可以用循环不变式来约束，即用集合的思想来思考 2.滑动窗口内必须是连续的(求解的问题必须是连续的)，如果结果可能非连续(比如求最长子序列)，无法用滑动窗口 两个指针指向不同的数组：两个指针指向不同的数组，按照某种条件移动两个指针。这个指针初始化时不一定要指针两个数组的开头，也可以指向两个数组的末尾。常常用来合并数组或者链表 链表题的快慢指针。141 142两题。","text":"双指针​ 目前刷到的双指针题目主要有三种 夹逼型：左右指针初始时分别指向左端点和右端点，然后根据某种条件向中间夹，一般这种情况要求数组有序(无序比如翻转数组) 双指针维护滑动窗口类型：即指针p逐个向后遍历，指针q要按某种条件移动，指针(q,p)就维护了一个区间，这个区间会不断移动，也叫做滑动窗口。这个窗口不一定是有固定长度的，具体要看题目的条件。1.滑动窗口的条件可以用循环不变式来约束，即用集合的思想来思考 2.滑动窗口内必须是连续的(求解的问题必须是连续的)，如果结果可能非连续(比如求最长子序列)，无法用滑动窗口 两个指针指向不同的数组：两个指针指向不同的数组，按照某种条件移动两个指针。这个指针初始化时不一定要指针两个数组的开头，也可以指向两个数组的末尾。常常用来合并数组或者链表 链表题的快慢指针。141 142两题。 夹逼型167:两数之和1234给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数，返回这两个数的下标。输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 有序，自然是左右端点夹逼型 633:平方数之和12345给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c 。实例:输入：c = 5输出：true解释：1 * 1 + 2 * 2 = 5 有序，又是找两个满足某条件的点，自然双指针。这里为了不超时，可以让右指针从sqrt(x)开始。 345.反转元音字符12345输入：&quot;hello&quot;输出：&quot;holle&quot;示例 2：输入：&quot;leetcode&quot;输出：&quot;leotcede&quot; 双指针翻转字符 680.验证回文串12345678给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。示例 1:输入: &quot;aba&quot;输出: True示例 2:输入: &quot;abca&quot;输出: True解释: 你可以删除c字符。 判断回文串自然是夹逼型双指针，重点是我们夹逼到发现两个字符不相等时如何处理，由于只能删除一个，自然可以删除左边也可以删除右边，我们再去测试一下删除字符之后的部分串是否为回文串。所以我们两边都要试一下，有一个是就直接返回。 123456789101112131415161718192021222324class Solution &#123;public: bool test(string s)&#123; int i = 0,j = s.size() - 1; while(i &lt; j)&#123; if(s[i] != s[j]) return false; i++,j--; &#125; return true; &#125; bool validPalindrome(string s) &#123; int i = 0,j = s.size() - 1; while(i &lt; j)&#123; if(s[i] != s[j])&#123; //两边都试一下 if(test(s.substr(i+1,j - i))) return true; if(test(s.substr(i,j - i))) return true; return false; &#125; i++,j--; &#125; return true; &#125;&#125;; 指针指向不同数组型88.归并两个有序数组12345678910给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。说明：初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。输入：nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出：[1,2,2,3,5,6] 指针分别指向两个数组的尾部，按照规则放入nums1数组。这就是双指针不一定非要放头部的反例，提一嘴，这个合并复杂度是o(m+n) 524.通过删除字母匹配到字典里最长单词1234567给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。输入:s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]输出: &quot;apple&quot; 本质上是看能否在串s中找到一个在字典中出现过的子序列串，如果找到且有多个。就会返回最长，如果相等，就返回字典序小的那个 野的方法就是找到串s的所有子序列，然后看他们是否在d中出现，加入一个集合后再筛选。这是从s找到符合d的东西。但是我们可以逆向思维，我们依次遍历d中的串，看他是否是s的子序列，这里判断是否为子序列我们就可以使用第二种类型的双指针了，这里是两个指针分别指向两个字符串的开头。 为了优化，我们可以事先将d排序，按照先长度后字典序的方式排序，那样字典按需遍历时，找到的第一个符合条件的一定就是最终结果 123456789101112131415161718192021class Solution &#123;public: static bool com(string&amp; s1,string&amp; s2)&#123; if(s1.size() != s2.size()) return s1.size() &gt; s2.size(); int i = 0; while(i &lt; s1.size() &amp;&amp; s1[i] == s2[i]) i++; return s1[i] &lt; s2[i]; &#125; string findLongestWord(string s, vector&lt;string&gt;&amp; d) &#123; sort(d.begin(),d.end(),com); for(int i = 0;i &lt; d.size();i++)&#123; int s_cur = 0,d_cur = 0; while(d_cur &lt; d[i].size() &amp;&amp; s_cur &lt; s.size())&#123; if(d[i][d_cur] == s[s_cur]) s_cur++,d_cur++; else s_cur++; &#125; if(d_cur == d[i].size()) return d[i]; &#125; return &quot;&quot;; &#125;&#125;; 21.合并两个有序链表滑动窗口型3.没有重复字符的字长子串12345678给定一个字符串，请你找出其中不含有重复字符的 最长子串 的&quot;长度&quot;。输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 这里我们可以用双指针维护一个滑动窗口，滑动窗口内的字符必然要满足一个条件，我们在移动这个遍历用的指针遍历到新的元素时，必然要考虑到他对这个滑动窗口的影响，也就是对这个集合的影响，是新元素加入窗口、窗口扩大还是剔除窗口左端元素(剔除元素是为了维护窗口内的性质和我们的预期一致)，移动窗口(可以看到移动窗口其实就是对窗口左端点指针移动)，此时就可以用到集合论的思想，即循环不变式 先定义好我们的窗口中的元素(集合)满足的条件：显然是集合中无重复元素，所以循环不变式(集合元素满足的条件)就是窗口中无重复元素。那么我们要使用一种方式记录这个窗口中是否有元素重复，此时我们想到了哈希表，以元素值为key，value标识这个元素出现的次数。当我们遍历用的指针i移动到下一个元素时，将这个元素加入窗口，对应的元素值++，如果发现加了之后hash[i] &gt; 1，说明这个窗口中有和新加入的这个元素一样的元素，我们就要移动窗口的左端点指针j，每移动一个将对应的hash值–，直到hash[i] == 1。在此过程中用窗口大小更新结果。 904.水果成篮1234输入一个数组Tree,数组的编号代表不同的树，Tree[i]的值表示第i棵树上结的水果。问你从任意一棵树开始，自左向右用两个体积无限大的篮子接水果，并且每个篮子只能放一种水果，最后返回你能采摘的水果数的最大数量。输入：[1,2,1]输出：3解释：我们可以收集 [1,2,1]。 这题其实和上面那题一样，就是维护一个滑动窗口，使滑动窗口内只含有两种类型的水果，抽象出来就是让滑动窗口内只包含两种数，并最后求这个滑动窗口最长时的长度 为了维护这个循环不变式，我们可以用哈希表来窗口内水果类型的个数和对应的每种类型水果的个数。自然我们就是要让这个哈希表的元素不超过2个。i移动时，加入一个新的元素使哈希表元素大于两个，我们就要移动j，使这个滑动窗口内完全丢掉一种水果(无论是哪种)，所以此时我们可以根据hash[j]的值是否为0来判断某种水果是否全没了。哪个先没了，把哪种水果从哈希表丢掉。 76.最小覆盖串1234567给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。示例 1：输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;输出：&quot;BANC&quot; **这题也是滑动窗口，这个窗口的性质也即满足的条件是窗口内包含串t的所有字符，不需要顺序。所以我们要记录窗口内有效串的个数，来了一个新元素之后看是否会对我这个窗口有影响 如果当前窗口不包含t的所有字符，来了一个新的之后判断是否能让这个窗口包含t所有字符，如果能，我们想让窗口尽可能小点，移动窗口左端点，移动左端点的终止条件就是窗口内不包含t中的所有字符了。由于最后是要返回串，所以我们要记录最小满足条件的串的左端点和这个串的长度 ** 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string minWindow(string s, string t) &#123; unordered_map&lt;char,int&gt; mp; //记录t串出现的字符和出现的次数 for(int i = 0;i &lt; t.size();i++)&#123; mp[t[i]]++; &#125; //窗口内有t有效字符的个数、最小子串的左边界、最小字串的长度 int cnt = 0,min_l = 0,min_size = INT_MAX; for(int l = 0,r = 0;r &lt; s.size();r++)&#123; if(mp.count(s[r]))&#123; //有效字符个数只有mp[s[r]] &gt; 0时才算,去除重复字符的影响 if(mp[s[r]] &gt; 0) cnt++; mp[s[r]]--; &#125; //获得了以r为右端点且包含t全部有效字符的最短子串 while(cnt == t.size())&#123; if(mp.count(s[l]))&#123; if(++mp[s[l]] &gt; 0) cnt--; &#125; if(r - l + 1 &lt; min_size)&#123; min_l = l; min_size = r - l + 1; &#125; l++; &#125; &#125; return min_size == INT_MAX ? &quot;&quot; : s.substr(min_l,min_size); &#125;&#125;; 二分​ 整数二分就主要使用acwing的模板就可以了，即自左向右找到第一个满足条件的点，自右向左找到第一个满足条件的点。小数二分比较简单。目前尚未总结出题型 ​ 注意二分不一定要求数组有序，只要你能找到一次能排除一般元素的排他性条件就可以了。 123456789101112//左边第一个大于等于x的点，最后一定会停止，但是可能最后结果在逻辑上不满足条件while(i &lt; j)&#123; int mid = i + j &gt;&gt; 1; if(arr[mid] &gt;= x) r = mid; else l = mid + 1;&#125;//从右开始第一个小于等于x的点while(i &lt; j)&#123; int mid = i + j + 1&gt;&gt; 1; if(arr[mid] &lt;= x) l = mid; else r = mid - 1;&#125; 整数二分模板题69.求平方根12345678计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。输入: 4输出: 2输入: 8输出: 2说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 根据题意就是找到自左到右的第一个t，使t^2 &lt;= x；所以我们使用第一个模板，条件就是mid^2 &lt;= x 43.区间查找12345678910111213给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4]示例 2：输入：nums = [5,7,7,8,8,10], target = 6输出：[-1,-1]输入：nums = [], target = 0输出：[-1,-1] 模板题直接套，即找到第一个小于等于target的位置，如果这个位置的值不等于target，说明数组中没这个元素，直接结束。 81.搜索旋转数组123456789假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。示例 1:输入: nums = [2,5,6,0,0,1,2], target = 0输出: true示例 2:输入: nums = [2,5,6,0,0,1,2], target = 3输出: false 这题我们可以采用查找分界点，也就是旋转点，然后根据分界点和target的大小关系选择到分界点的左端还是右端查找。如果旋转了，分界点的特点一定是第一个小于nums[0]的点。但是这题因为有重复元素，所以预处理去重。我们删去数组右端的点，直到右端的点小于nums[0]，接下来就可以二分查找第一个小于nums[0]的分界点了。 540.有序数组的单一元素1234给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。示例 1:输入: [1,1,2,3,3,4,4,8,8]输出: 2 这一题可以用位运算(亦或)来做，但是也可以二分来做。我们找到的二分条件就是如果arr[mid] == arr[mid + 1],那么如果mid处包括之前没有那个只出现一次的元素，这个mid一定是偶数。否则这个只出现一次的数一定出现在mid右边。同理分析 1234567891011121314151617181920class Solution &#123;public: int singleNonDuplicate(vector&lt;int&gt;&amp; nums) &#123; int l = 0, r = nums.size() - 1; while(l &lt; r)&#123; int mid = (l + r)&gt;&gt; 1; //注意边界条件 if(mid + 1 &lt;= r &amp;&amp; nums[mid] == nums[mid+1])&#123; if(!(mid % 2)) l = mid + 2; else r = mid - 1; &#125; else if(mid - 1 &gt;= 0 &amp;&amp; nums[mid] == nums[mid - 1])&#123; if(mid % 2) l = mid + 1; else r = mid - 1; &#125; else return nums[mid]; &#125; return nums[l]; &#125;&#125;; 动态规划​ 目前还没有总结出动态规划的套路，记录一下到目前为止的一些思考 ​ 看了知乎的帖子之后【https://www.zhihu.com/question/291280715/answer/1570410869】，我明白了DP的做题三部曲： 定义好状态，即创建一个多维数组，明确数组中每一个值的意义 确定好某些状态的初始值，即初始化数组中某些元素的值 确定转移方程，这个也是最难的一步，目前为止我觉得主要靠经验 知乎帖子总结青蛙跳台阶1234//一维DP1.dp[i]表示跳到第i层台阶的总次数2.dp[0] = 0,dp[1] = 1,dp[2] = 23.dp[i] = dp[i - 1] + dp[i - 2] 62.不同路径12345一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？ 1234//二维DP1.dp[i][j]:到[i,j]这个位置可以有的路径数(i &gt;= 0,j &gt;= 0)2.dp[0][1...m]都是1，因为只能从左向右一条路走，dp[1...n][0]都是1，只能向下走，一个道理3.dp[i][j] = dp[i - 1][j] + dp[i][j - 1] 64.最小路径和123给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。 1234//思路和上面一题一样，任意(i,j)这个点都只能从(i-1,j)和(i,j-1)来，所以我们只要取这两个之中的最小值即可1.dp[i][j]:从(0,0)到(i,j)所有路径中路径之和最小的值2.第0行和第0列的值都需要初始化3.从(1,1)开始，dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j] 72.编辑距离1234567891011121314给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对一个单词进行如下三种操作：插入一个字符删除一个字符替换一个字符输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)rorse -&gt; rose (删除 &#x27;r&#x27;)rose -&gt; ros (删除 &#x27;e&#x27;) 这一题的转移方程和1143的LCS的思考方式特别像，两题一起看 123451.dp[i][j]:word1的前i个字符组成的子串转换成word2的前j个字符的子串所要的最少操作次数2.dp[0][0...word2.size() - 1]都是当前遍历到的word2的子串的长度(一个长度为0，转过去自然是另一个串的长度),dp[0...word1.size() - 1][0]都是当前遍历到的word2的子串的长度3.对于dp[i][j],如果word1[i] == word2[j],不用转了,那么dp[i][j] = dp[i-1][j-1]如果不等，那我们可以1.删除word1的第i个位置，就是在dp[i-1][j]的基础上又操作了一次;2.删除word2的第j个位置，就是在dp[i][j-1]的基础上又操作了一次 3.将word1的i或者word2的j替换成和对方一样的(或者让其中某一个插入对方的字符)，就是在dp[i-1][j-1]的基础上又操作了一次。&quot;这三种情况都可以，所以我们自然要取其最小值&quot;。所以此时dp[i][j] = min(min(dp[i-1][j]+1,dp[i][j-1]+1),dp[i-1][j-1]+1) 侯卫东 步骤 想转移方程时要考虑最后一步也就是考虑最后问题的解，假设他是最优解，那么最后规模的上一个规模的解也一定是最优解，可以用反证法证明。 这样我们就把原问题的接转换成了求规模更小的子问题的，更精确的说是当且问题的解可以在规模更小的子问题的解的基础上操作得到——想出这个操作就是转移方程(怎么由子问题解推出当前问题的解)。当然当前问题可能由多个子问题的解比较取优得到，不一定是只由一个子问题得到 由多个子问题的最优解比较得到当前问题最优解，这个过程就是转移方程 接下来就是考虑DP数组初始值和边界情况，比如数组越界时怎么处理。比如这里f(0)就是初始，用0个硬币就可以拼出 最后是考虑计算顺序，大部分是自左到右，当然还是要看你退出来的数之间的依赖关系 322.零钱兑换(其实也是背包问题)123456789101112给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。你可以认为每种硬币的数量是无限的。示例 1：输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1示例 2：输入：coins = [2], amount = 3输出：-1 123456789101112131415161718//主要说一下这里初始值和处理边界值的方式，如果某个数量无法用基本硬币组成，也就是数组越界，我们用无穷大表示他，为了方便处理，把除0以外的其他位置都设置成无穷大。class Solution &#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; vector&lt;int&gt; dp(amount+1,0x3f3f3f3f); dp[0] = 0; sort(coins.begin(),coins.end()); for(int i = 1;i &lt;= amount;i++)&#123; for(int j = 0;j &lt; coins.size();j++)&#123; //如果没有越界，则如何处理 if(i - coins[j] &gt;= 0) dp[i] = min(dp[i - coins[j]] + 1,dp[i]); else break; &#125; &#125; if(dp[amount] &lt; 0x3f3f3f) return dp[amount]; return -1; &#125;&#125;; 我的一些感悟123在01背包中，我们把状态f[i,j]称为一个选法集合。我们在思考转移方程时就要考虑当前这个状态可能会由哪些子问题转过来，当我们知道可能会由哪些子问题转过来之后，只需要在这些问题中取最大或最小值就可以了。一般在求f[i,j]时，多半是从f[i-1]过来的，所以我们就可以知道要么是在前i-1个问题选满了j个，第i个放不下， 要么就是前i-1选满了，但是还能放下第i个元素，所以只会由f[i-1,j]和f[i-1,j-v[i]]过来在矩阵联城法中，f[i,j]表示(i,j)这个连乘所有的乘的方式的集合，但是最终都会化为两个矩阵相乘，所以我们只需要考虑(j - i + 1)所有连乘链组成的所有可能的两个矩阵就可以了。 上面的意思就是明确状态表示哪些集合，然后集合可以按照什么样的条件划分为若干类，这个就是做题经验了。每一小类的计算一般会用到子问题的解 线性DP198.打家劫舍123456789你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。//相邻房子不能偷能偷到的最大价值 1234567891011121314//第一种状态的定义方式。偷第i个时，第i-1个不能偷。而dp[i-1]是包括偷第i-1个的，所以我们只能在i-1的基础上偷class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; vector&lt;int&gt; dp(nums.size() + 1,0); dp[1] = nums[0];//防止边界问题，从第2个开始算 for(int i = 2; i &lt;= nums.size();i++)&#123; dp[i] = max(dp[i-2]+nums[i-1],dp[i-1]); &#125; return dp[nums.size()]; &#125;&#125;; 1234567891011121314//使用股票那一题的状态定义方式dp[i][0]:第i个不偷情况下的最大值dp[i][1]:第i个偷情况下的最大值class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; dp(nums.size() + 1,vector&lt;int&gt;(2,0)); for(int i = 1;i &lt;= nums.size();i++)&#123; dp[i][0] = max(dp[i-1][0],dp[i-1][1]); dp[i][1] = dp[i - 1][0] + nums[i - 1]; &#125; return max(dp[nums.size()][0],dp[nums.size()][1]); &#125;&#125;; 213.打家劫舍Ⅱ123456你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。示例 1：输入：nums = [2,3,2]输出：3解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 123//和上一题相比，这一题就是多了环形数组这个条件。怎么解决呢？我们发现如果偷了第一个，那么最后一个一定没法偷。同理偷最后一个第一个一定没法偷。所以根据这一互斥条件，讲原数组分为两个队列，一个包含1...n-1这n-1个元素(即可能偷第一个)，一个包含2...n这n-1个元素(即不会偷第一个)。//第一组可能偷第一个，也就是有可能不偷第一个。那么假设在第一组中，最大值的组合是不偷第一个，最后一个偷的是n-2,那么你是不是会想，此时在第一组要是可以偷第n个，这样价值会更大，而且满足了1 n互斥的关系。其实如果存在描述的这种情况他会在第二组中被检查到，我们函数的功能就是找到某个区域偷盗的最大值。而上面描述的那种情况如果存在，他肯定比第一组最大值大，但是他所扫描的区域实际上是2...n，这是一定会在第二组被找到的。所以这种做法是没问题的。 12345678910111213141516class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; if(nums.size() == 1) return nums[0]; //创建两个DP数组，一个是偷第一个，一个不偷第一个 vector&lt;int&gt; dp1(nums.size()+1,0),dp2 = dp1; //dp1是一定偷第一个(则一定不会偷最后一个)，dp2是不偷第一个 dp1[1] = nums[0],dp2[2] = nums[1]; for(int i = 2;i &lt; nums.size();i++)&#123; dp1[i] = max(dp1[i-1],dp1[i-2]+nums[i-1]); &#125; for(int i = 3;i &lt;= nums.size();i++) dp2[i] = max(dp2[i-1],dp2[i-2]+nums[i-1]); return max(dp1[nums.size()-1],dp2[nums.size()]); &#125;&#125;; 123456789101112131415161718192021//空间优化版本class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; if(nums.size() == 1) return nums[0]; vector&lt;int&gt; dp1(2),dp2(2); dp1[1] = nums[0],dp2[1] = nums[1]; for(int i = 2;i &lt; nums.size();i++)&#123; int tmp = dp1[1]; dp1[1] = max(dp1[1],dp1[0]+nums[i-1]); dp1[0] = tmp; &#125; for(int i = 3;i &lt;= nums.size();i++)&#123; int tmp = dp2[1]; dp2[1] = max(dp2[1],dp2[0]+nums[i-1]); dp2[0] = tmp; &#125; return max(dp1[1],dp2[1]); &#125;&#125;; 413.等差数列划分1234A = [1, 2, 3, 4]返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。//规定连续的长度大于等于3的子数组为等差子数组，求给定数组中等差子数组的个数。 123456789101112class Solution &#123;public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) &#123; if(A.size() &lt; 3) return 0; vector&lt;int&gt; dp(A.size(),0); for(int i = 2;i &lt; A.size();i++)&#123; if(A[i] - A[i - 1] == A[i - 1] - A[i - 2]) dp[i] = dp[i - 1] + 1; else dp[i] = 0; &#125; return accumulate(dp.begin(),dp.end(),0); &#125;&#125;; 746.最小花费爬楼梯12345数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。 12345678910111213141516171819202122232425262728class Solution &#123;public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123; //dp[i]表示能到i号阶梯的所有跳跃方式的集合,但是还没跳上i号阶梯 vector&lt;int&gt; dp(cost.size(),0x3f3f3f3f); dp[0] = 0,dp[1] = 0; for(int i = 2;i &lt; cost.size();i++)&#123; dp[i] = min(dp[i-2] + cost[i-2],dp[i-1] + cost[i-1]); &#125; int n = cost.size() - 1; int res = dp[cost.size() - 1] + cost[cost.size() - 1]; if(n - 1 &gt;= 0) res = min(dp[n-1] + cost[n-1],res); return res; &#125;&#125;;//改进版本class Solution &#123;public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123; int n = cost.size(); vector&lt;int&gt; dp(n + 1); dp[0] = dp[1] = 0; for (int i = 2; i &lt;= n; i++) &#123; dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]); &#125; return dp[n]; &#125;&#125;; 矩阵问题矩阵问题的一个特点就是状态的定义，我目前总结了一下常见的意义 121.dp[i][j]代表以(i,j)为右下角的整个区域内满足某种条件的子集的集合2.dp[i][j]代表在1的基础上，所以子集中必须包含(i,j)这个点的集合，相当于在1的基础上缩小了(即固定住(i,j)这个点)。比如221题 174.地下城游戏 题意就是让你找到一个最小的HP值使你能走到终点，比如这里，第一个格子就要掉2HP，所以至少要3起步。总之就是勇士的血在路过每一个格子之后都不能低于1 这题是罕见的从右下向左上推 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; d) &#123; int n = d.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(d[0].size()+1,0)); dp[n][d[0].size()] = d[n-1][d[0].size()-1] &lt; 0 ? -d[n-1][d[0].size()-1] + 1 : 1; for(int i = d[0].size()-1;i &gt;= 1;i--)&#123; if(d[n - 1][i - 1] &gt;= 0)&#123; if(d[n-1][i-1] &gt;= dp[n][i+1]) dp[n][i] = 1; else dp[n][i] = dp[n][i+1] - d[n-1][i-1]; &#125; else dp[n][i] = dp[n][i+1] - d[n-1][i-1]; &#125; for(int i =n - 1;i &gt;= 1;i--)&#123; if(d[i - 1][d[0].size() - 1] &gt;= 0)&#123; if(d[i-1][d[0].size()-1] &gt;= dp[i+1][d[0].size()]) dp[i][d[0].size()] = 1; else dp[i][d[0].size()] = dp[i+1][d[0].size()] - d[i-1][d[0].size()-1]; &#125; else dp[i][d[0].size()] = dp[i+1][d[0].size()] - d[i-1][d[0].size()-1]; &#125; //上面是处理边界， for(int i = n-1;i &gt;= 1;i--)&#123; for(int j = d[0].size()-1;j &gt;= 1;j--)&#123; if(d[i-1][j-1] &gt;= 0)&#123; int val = min(dp[i+1][j],dp[i][j+1]); if(val &lt;= d[i-1][j-1]) dp[i][j] = 1; else dp[i][j] = val - d[i-1][j-1]; &#125; else&#123; dp[i][j] = min(dp[i+1][j],dp[i][j+1]) - d[i-1][j-1]; &#125; &#125; &#125; return dp[1][1]; &#125;&#125;; 542.01矩阵123456789101112给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。两个相邻元素间的距离为 1 。输入：[[0,0,0], [0,1,0], [0,0,0]]输出：[[0,0,0], [0,1,0], [0,0,0]] 第一种方式就是BFS：不过我们的BFS是初始化时先将所有的值为0的点入队，并更新dist数组，然后把这所有的0点看作一个超级节点，也可以看成树中的根节点，然后以这个根节点开始DFS，那么第一次遇到的所有非0节点，他们距离0的距离就是dist[x] [y] + 1.然后把这些第一次更新的节点加入到队列，中依次再遍历周围找到新的节点。根据BFS的性质，BFS第一次遇到的点的层数一定是这个点到根节点的最短距离 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;vector&lt;int&gt;&gt; dist(matrix.size(),vector&lt;int&gt;(matrix[0].size(),0)); using PII = pair&lt;int,int&gt;; queue&lt;PII&gt; que; for(int i = 0;i &lt; matrix.size();i++)&#123; for(int j = 0;j &lt; matrix[0].size();j++)&#123; if(!matrix[i][j])&#123; que.push(&#123;i,j&#125;); dist[i][j] = 0; &#125; else&#123; dist[i][j] = INT_MAX; &#125; &#125; &#125; int dx[4] = &#123;-1,1,0,0&#125;,dy[4] = &#123;0,0,-1,1&#125;; while(que.size())&#123; auto q = que.front(); que.pop(); for(int i = 0;i &lt; 4;i++)&#123; int x = q.first + dx[i]; int y = q.second + dy[i]; if(x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; matrix.size() &amp;&amp; y &lt; matrix[0].size())&#123; //判断是否入过队列,非INT_MAX一定是访问过的 if(dist[x][y] &amp;&amp; dist[x][y] == INT_MAX)&#123; dist[x][y] = dist[q.first][q.second] + 1; que.push(&#123;x,y&#125;); &#125; &#125; &#125; &#125; return dist; &#125;&#125;; 本题使用DP的话对任意一个状态他的集合要分为4类，但是无论是从上到下还是从下到上最多有两个方向也就是两类在计算这个状态之前被算出来了。所以我们选择从上到下一次，然后从下到上一次。两次更新。这样就更新到了所有方向 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;vector&lt;int&gt;&gt; dp(matrix.size(),vector&lt;int&gt;(matrix[0].size(),0x3f3f3f3f)); int dx[4] = &#123;-1,1,0,0&#125;,dy[4] = &#123;0,0,-1,1&#125;; for(int i = 0;i &lt; matrix.size();i++)&#123; for(int j = 0;j &lt; matrix[0].size();j++)&#123; if(!matrix[i][j])&#123; dp[i][j] = 0; continue; &#125; for(int k = 0;k &lt; 4;k++)&#123; int x = i + dx[k],y = j + dy[k]; if(x &gt;= 0 &amp;&amp; x &lt; matrix.size() &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; matrix[0].size())&#123; dp[i][j] = min(dp[x][y],dp[i][j]); &#125; &#125; dp[i][j] = dp[i][j] + 1; &#125; &#125; for(int i = matrix.size() - 1;i &gt;= 0;i--)&#123; for(int j = matrix[0].size() - 1;j &gt;= 0;j--)&#123; if(!matrix[i][j])&#123; dp[i][j] = 0; continue; &#125; for(int k = 0;k &lt; 4;k++)&#123; int x = i + dx[k],y = j + dy[k]; if(x &gt;= 0 &amp;&amp; x &lt; matrix.size() &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; matrix[0].size())&#123; dp[i][j] = min(dp[x][y],dp[i][j]); &#125; &#125; dp[i][j] = dp[i][j] + 1; &#125; &#125; return dp; &#125;&#125;; 关于动态规划为什么只考虑左上和右下就可以了。 1234_ _ _ 0 __ _ _ _ __ _ 1 _ __ _ _ _ _ 如上图，我们假设某个位置(x,y)离它最近的0只有一个，且是在它的右上角，在它“右1上2”的位置。这意味着距离中心1距离为“3=1+2”的范围内，所有的位置都是1（或者出界，我们暂时不考虑出界的情况，不影响结论）。 所以这张图一定是（不考虑左下方的出界情况，不影响）: 1234567? ? ? ? 1 ? ? ? ?? ? ? 1 1 0 ? ? ?? ? 1 1 1 1 1 ? ?? 1 1 1 &quot;1&quot; 1 1 1 ?? ? 1 1 1 1 1 ? ?? ? ? 1 1 1 ? ? ?? ? ? ? 1 ? ? ? ? 所以我们来考虑它右一处标为X的位置，离这个位置最近的0，一定就是它“上二”方向的0： 1234567? ? ? ? 1 ? ? ? ?? ? ? 1 1 0 ? ? ?? ? 1 1 1 1 1 ? ?? 1 1 1 &quot;1&quot; X 1 1 ?? ? 1 1 1 1 1 ? ?? ? ? 1 1 1 ? ? ?? ? ? ? 1 ? ? ? ? 所以在“考虑左上角的时候”，X处的位置可以记录到目标0的信息，X处的最短距离被正确记录了。 然后在“考虑右下角的时候”，X处的最短信息，正好又能被我们的中心“1”观察到，所以中心1间接地，记录到了目标0的最短距离。 123456789101 1 1 1 1 1 11 1 1 1 0 1 11 1 1 1 1 1 11 1 1 1 1 1 1如图，从左上开始的第一遍会让0为左上角的矩形区域全部记录到1 1 1 1 1 1 11 1 1 1 / 0 1 11 1 1 1 / 1 1 11 1 1 1 / 1 1 1从右下向左上遍历时，右下的区域又会把记录到的最短信息更新给左上半部分的区域 221.最大正方形 题意就是在给定矩形矩阵中找到全由1构成的最大正方形的面积 1&quot;对于矩阵搜索正方形或者长方形的题目，常见的做法是使用dp&quot;。在这种题目里面一般定义dp[i][j]所代表的集合为以(i,j)为右下角的所有全是1的正方形/矩形 1234567891011状态计算令dp[i][j] = kdp[i-1][j] &gt;= k - 1dp[i][j-1] &gt;= k - 1dp[i-1][j-1] &gt;= k - 1如果不满足上面的这个条件，以(i,j)为右下角的长度为k的矩形中绝对不可能全是1又因为dp[i][j]也只能从上说的三个方向的正方形延申过来，所以dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]) + 1 &quot;如果dp[i-1][j],dp[i-1][j-1],dp[i][j-1]至少有一个为0，那么(i,j)的三个方向肯定有一个为0，那么没得大一统了，只能最多为1了。否则，看下图&quot;。 所以两个条件一结合就是这个递推式了 12345678910111213141516171819class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix[0].empty()) return 0; int m = matrix.size(),n = matrix[0].size(); int maxlen = 0; //dp一般从下标1开始，申请多一个方便处理边界，但还是要具体问题具体分析 vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0)); for(int i = 1;i &lt;= m;i++)&#123; for(int j = 1;j &lt;= n;j++)&#123; if(matrix[i-1][j-1] == &#x27;1&#x27;)&#123; dp[i][j] = min(min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1]) + 1; &#125; maxlen = max(maxlen,dp[i][j]); &#125; &#125; return maxlen*maxlen; &#125;&#125;; 1277.全为1的正方形子矩阵123456789101112输入：matrix =[ [0,1,1,1], [1,1,1,1], [0,1,1,1]]输出：15解释： 边长为 1 的正方形有 10 个。边长为 2 的正方形有 4 个。边长为 3 的正方形有 1 个。正方形的总数 = 10 + 4 + 1 = 15. 1这一题我们只需要在221题的基础上修改就可以了。dp[i][j]的值是以(i,j)为右下角的正方形的长，那么它&quot;也可以表示以(i,j)为右下角的正方形的个数&quot;.所以最后我们把dp矩阵累加起来就可以了 1234567891011121314151617class Solution &#123;public: int countSquares(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix[0].empty()) return 0; int m = matrix.size(),n = matrix[0].size(); int res = 0; vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0)); for(int i = 1;i &lt;= m;i++)&#123; for(int j = 1;j &lt;= n;j++)&#123; if(matrix[i-1][j-1]) dp[i][j] = min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1])) + 1; res += dp[i][j]; &#125; &#125; return res; &#125;&#125;; 分割类问题 顾名思义就是把一个数按要求拆分成几个部分，问拆分之后生成的最少部分数是多少。 拆分类的题目都可以用dp来做，思路就和找零钱差不多 279.完全平方数1234给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。输入: n = 12输出: 3 解释: 12 = 4 + 4 + 4. 1234567891011121314//思路和找零钱差不多，dp[i]表示拆分i需要的最少的完全平方数的个数class Solution &#123;public: int numSquares(int n) &#123; vector&lt;int&gt; dp(n+1,0x3f3f3f3f); dp[0] = 0,dp[1] = 1; for(int i = 2;i &lt;= n;i++)&#123; for(int j = sqrt(i);j &gt;= 1;j--)&#123; dp[i] = min(dp[i - j*j] + 1,dp[i]); &#125; &#125; return dp[n]; &#125;&#125;; 91.解码方法12345678910一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：&#x27;A&#x27; -&gt; 1&#x27;B&#x27; -&gt; 2...&#x27;Z&#x27; -&gt; 26输入：s = &quot;226&quot;输出：3解释：它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。//问你数字有多少种解码方式 123456789101112131415161718192021222324252627//dp[i]表示前i个字符的解码方式的个数，我们按照第i个字符是否独立编码划分集合(即是否和i-1结合)，一种是独立编码，另一种是与i-1结合编码。//class Solution &#123;public: int numDecodings(string s) &#123; vector&lt;int&gt; dp(s.size()+1,0); //dp[1]和dp[2]是初始值需要特殊处理 dp[1] = s[0] == &#x27;0&#x27; ? 0 : 1; if(s.size() &gt;= 2)&#123; if(s[1] == &#x27;0&#x27;)&#123; //看这个组成的两位数符不符合标准 if(atoi(s.substr(0,2).c_str()) &lt;= 26) dp[2] = dp[1]; &#125; else if(s[0] != &#x27;0&#x27;)&#123; if(atoi(s.substr(0,2).c_str()) &lt;= 26) dp[2] = 2; else dp[2] = 1; &#125; &#125; for(int i = 3;i &lt;=s.size();i++)&#123; //如果i号字符能单独存在 if(s[i-1] != &#x27;0&#x27;) dp[i] = dp[i-1]; //如果i号字符能和i-1号结合 if(s[i-2] != &#x27;0&#x27; &amp;&amp; atoi(s.substr(i-2,2).c_str()) &lt;= 26) dp[i] += dp[i-2]; &#125; return dp[s.size()]; &#125;&#125;; 139.单词拆分123456789给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。说明：拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot; 1这题也可以用dp，dp[i]的集合表示s的前i+1个字符所有的拼接组合方式，值为这些组合方式中是否存在&quot;所有被拆分的部分都在字典中出现&quot;这种情况。我们跟91一样，根据第i号字符是否和i以前的字符组合来划分集合。 12345678910111213141516171819202122class Solution &#123;public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; unordered_map&lt;string,bool&gt; mp; for(auto&amp; c:wordDict) mp[c] = true; vector&lt;bool&gt; dp(s.size(),false); //0号是初值 if(mp[s.substr(0,1)]) dp[0] = true; for(int i = 1;i &lt; s.size();i++)&#123; //从i开始依次向前结合 for(int j = 1;j &lt;= i+1;j++)&#123; //如果[i-j+1,i]在字典出现，只需要再检查dp[i-j]是否能被成功拆分就可以了，如果 if(mp[s.substr(i-j+1,j)])&#123; if(i &gt;= j) dp[i] = dp[i - j]; else dp[i] = true;//特判j == i+1这种情况 &#125; if(dp[i]) break;//如果为true,说明存在某种拆分方式，直接退出 &#125; &#125; return dp[s.size() - 1]; &#125;&#125;; 背包类问题01背包注意点 未优化的情况下，第二维都要从0开始，如果第i个货物放不下，就等于上一层。优化过后，逆着来，就相当于直接等于上一层，所以到j &gt;= v[i]为止就可以了 416.分割等和子集12345678给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。注意:每个数组中的元素不会超过 100数组的大小不会超过 200示例 1:输入: [1, 5, 11, 5]输出: true解释: 数组可以分割成 [1, 5, 5] 和 [11]. 12这一题用01背包来做，我们定义dp[i][j]为前i个元素可以选出来的所有集合，他的值就是这些集合中是否存在和为j的这种集合。所以言下之意就是我们能否在前i个元素中找到和为j的目标集合k。&quot;我们根据这些子集中是否有第i个元素来将所有集合划分成两大类，然后我们只需要看这两大类子集中是否有和为j的子集就可以了。这两大类子集，第一类就是i-1个元素组成的所有子集，第二类就是就是第一类的所有集合中加入一个i号元素。如果第一大类有，那第二大类就没有，如果第二大类没有只需要检查第二大类，因为第二大类所有集合都有i，所以他们的和都有i号元素，那么对于第二大类只要检查有没有和为j - nums[i]的值就可以了。&quot; 事实上这样划分的集合也是不重不漏的，前i个元素的所有集合是由所有含i号元素的集合和不含i号元素的集合一起构成的 1234567891011121314151617181920class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int sum = accumulate(nums.begin(),nums.end(),0); //奇数不可能 if(sum % 2) return false; int target = sum / 2; vector&lt;vector&lt;bool&gt;&gt; dp(nums.size()+1,vector&lt;bool&gt;(target+1,false)); //初始值，后面的边界值处理需要 for(int i = 0;i &lt;= nums.size();i++) dp[i][0] = true; for(int i = 1;i &lt;= nums.size();i++)&#123; //正规01背包未优化的写法，j应该从0开始 for(int j = 0;j &lt;= target;j++)&#123; dp[i][j] = dp[i-1][j]; if(j &gt;= nums[i-1]) dp[i][j] = dp[i][j] || dp[i-1][j-nums[i-1]]; &#125; &#125; return dp[nums.size()][target]; &#125;&#125;; 12345678910111213141516171819class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int sum = accumulate(nums.begin(),nums.end(),0); //奇数不可能 if(sum % 2) return false; int target = sum / 2; vector&lt;vector&lt;bool&gt;&gt; dp(nums.size()+1,vector&lt;bool&gt;(target+1,false)); //初始值，后面的边界值处理需要 for(int i = 0;i &lt;= nums.size();i++) dp[i][0] = true; for(int i = 1;i &lt;= nums.size();i++)&#123; //这里也是01背包未优化，但是j不是从0开始也是对的，我不知道为什么 for(int j = nums[i-1];j &lt;= target;j++)&#123; dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]]; &#125; &#125; return dp[nums.size()][target]; &#125;&#125;; 1234567891011121314151617//优化为一维，倒着来class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int sum = accumulate(nums.begin(),nums.end(),0); if(sum % 2) return false; int target = sum / 2; vector&lt;bool&gt; dp(target+1,false); dp[0] = true; for(int i = 1;i &lt;= nums.size();i++)&#123; for(int j = target;j &gt;= nums[i-1];j--)&#123; dp[j] = dp[j] || dp[j-nums[i-1]]; &#125; &#125; return dp[target]; &#125;&#125;; 474.1和01234567给你一个二进制字符串数组 strs 和两个整数 m 和 n 。请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。示例 1：输入：strs = [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m = 5, n = 3输出：4解释：最多有 5 个 0 和 3 个 1 的最大子集是 &#123;&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;&#125; ，因此答案是 4 。其他满足题意但较小的子集包括 &#123;&quot;0001&quot;,&quot;1&quot;&#125; 和 &#123;&quot;10&quot;,&quot;1&quot;,&quot;0&quot;&#125; 。&#123;&quot;111001&quot;&#125; 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。 123456789101112131415161718192021222324252601b背包，只不过这次相当于有两个包的限制，所以是多维01背包class Solution &#123;public: int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123; vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(strs.size()+1,vector&lt;vector&lt;int&gt;&gt;(m+1,vector&lt;int&gt;(n+1,0))); vector&lt;int&gt; one(strs.size()+1,0); vector&lt;int&gt; zero(strs.size()+1,0); for(int i = 0;i &lt; strs.size();i++)&#123; for(int k = 0;k &lt; strs[i].size();k++)&#123; if(strs[i][k] == &#x27;1&#x27;) one[i+1]++; else zero[i+1]++; &#125; &#125; for(int i = 1;i &lt;= strs.size();i++)&#123; //01背包未优化都要从0开始 for(int j = 0;j &lt;= m;j++)&#123; for(int k = 0;k &lt;= n;k++)&#123; dp[i][j][k] = dp[i-1][j][k]; if(j &gt;= zero[i] &amp;&amp; k &gt;= one[i]) dp[i][j][k] = max(dp[i-1][j-zero[i]][k-one[i]]+1,dp[i][j][k]); &#125; &#125; &#125; return dp[strs.size()][m][n]; &#125;&#125;; 12345678910111213141516171819202122class Solution &#123;public: int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0)); vector&lt;int&gt; one(strs.size()+1,0); vector&lt;int&gt; zero(strs.size()+1,0); for(int i = 0;i &lt; strs.size();i++)&#123; for(int k = 0;k &lt; strs[i].size();k++)&#123; if(strs[i][k] == &#x27;1&#x27;) one[i+1]++; else zero[i+1]++; &#125; &#125; for(int i = 1;i &lt;= strs.size();i++)&#123; for(int j = m;j &gt;= zero[i];j--)&#123; for(int k = n;k &gt;= one[i];k--)&#123; dp[j][k] = max(dp[j-zero[i]][k-one[i]]+1,dp[j][k]); &#125; &#125; &#125; return dp[m][n]; &#125;&#125;; 字符串编辑 **双字符串题(72 1143 10)**的dp[i] [j]表示第一个字符串的前i个字符和第二个串的前j个字符 72.编辑距离650.只有两个键的键盘12345678910111213最初在一个记事本上只有一个字符 &#x27;A&#x27;。你每次可以对这个记事本进行两种操作：Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。Paste (粘贴) : 你可以粘贴你上一次复制的字符。给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 &#x27;A&#x27;。输出能够打印出 n 个 &#x27;A&#x27; 的最少操作次数。示例 1:输入: 3输出: 3解释:最初, 我们只有一个字符 &#x27;A&#x27;。第 1 步, 我们使用 Copy All 操作。第 2 步, 我们使用 Paste 操作来获得 &#x27;AA&#x27;。第 3 步, 我们使用 Paste 操作来获得 &#x27;AAA&#x27;。 *主要是考虑合数i = ab表示i个A可以由a个b时的状态粘贴过来，也可以由b个a状态粘贴过来，取最小值** 1234567891011121314151617class Solution &#123;public: int minSteps(int n) &#123; vector&lt;int&gt; dp(n+1,0x3f3f3f3f); if(n == 1) return 0; dp[1] = 0,dp[2] = 2; for(int i = 3;i &lt;= n;i++)&#123; for(int j = 2;j &lt;= sqrt(i);j++)&#123; if(i % j == 0)&#123; dp[i] = min(min(dp[i],dp[j] + i / j),dp[i/j]+j); &#125; &#125; if(dp[i] == 0x3f3f3f3f) dp[i] = i; &#125; return dp[n]; &#125;&#125;; 10.正则表达式的匹配123456789给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 &#x27;.&#x27; 和 &#x27;*&#x27; 的正则表达式匹配。&#x27;.&#x27; 匹配任意单个字符&#x27;*&#x27; 匹配零个或多个前面的那一个元素所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。示例 1：输入：s = &quot;aa&quot; p = &quot;a&quot;输出：false解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。 1234567只要是涉及到双串(无论是匹配或者是其他操作)，dp时他们的状态数组都是同一种方式，dp[i][j]这题dp[i][j]还是表示S串的前i个字符和P串的前j个字符是否匹配操作还是类似于LCS，对尾部进行判断 1.P[j] == S[i] || p[j] == &#x27;.&#x27;，那么dp[i][j] = dp[i-1][j-1] 2.P[j] == &#x27;*&#x27; 此时若*前面的字符和S[i]不相等,那么可以把*和其前面的字符一起消掉,即dp[i][j]=dp[i][j]||dp[i][j-2] 如果*前面的字符x和s[i]相等，但是s[i-1],s[i-2]...可能都与x相等，这个时候就要考虑消去p的几个才能匹配了，所以我们要把所有可能要消去的元素都枚举一遍，看看是否能成功。 12345678910111213141516171819202122232425262728class Solution &#123;public: bool isMatch(string s, string p) &#123; vector&lt;vector&lt;bool&gt;&gt; dp(s.size()+1,vector&lt;bool&gt;(p.size()+1,false)); dp[0][0] = true; //这里主要是初始化p串不为空，s为空但是也能匹配的这种特殊情况 for(int i = 1;i &lt; p.size();i+=2)&#123; if(p[i] == &#x27;*&#x27;) dp[0][i+1] = dp[0][i-1]; &#125; for(int i = 1;i &lt;= s.size();i++)&#123; for(int j = 1;j &lt;= p.size();j++)&#123; if(s[i-1] == p[j-1] || p[j-1] == &#x27;.&#x27;) dp[i][j] = dp[i-1][j-1]; else if(p[j-1] == &#x27;*&#x27;)&#123; int k = i; //这里是*前面的元素和S[i]不相等或者相等时却不消去S[i]的情况 dp[i][j] = dp[i][j] || dp[i][j-2]; //下面枚举消去连续相等的1、2、3...个 while(k &gt; 0 &amp;&amp; (s[k-1] == p[j-2] || p[j-2] == &#x27;.&#x27;))&#123; dp[i][j] = dp[i][j] || dp[k-1][j-2]; k--; &#125; &#125; &#125; &#125; return dp[s.size()][p.size()]; &#125;&#125;; 股票买卖 给定一支股票的价格数组，问你怎么买卖这支股票利润最该 一次买入，接着卖出才算一次交易 https://leetcode-cn.com/circle/article/qiAgHn/ 这个非常详细，他介绍的状态模板非常好用 1234567//只有今天买入股票才会减少最大交易次数T[i][k][0] 表示在第 i 天结束时，最多进行 k 次交易且在进行操作后持有 0 份股票的情况下可以获得的最大收益；T[i][k][1] 表示在第 i 天结束时，最多进行 k 次交易且在进行操作后持有 1 份股票的情况下可以获得的最大收益。//今天不持股，1.昨天也不持股，今天啥也不做(那今天允许的最大交易次数为k,昨天允许的最大交易次数也为) 2.昨天持股，今天卖掉，但是不影响最大交易次数(今天允许的最大交易次数为k，今天只是卖掉，所以昨天允许的最大交易次数也为k)。因为只有今天买入才会影响交易次数T[i][k][0] = max(T[i - 1][k][0], T[i - 1][k][1] + prices[i])//今天持股，1.昨天就持股，今天啥也不做(那么你最大交易次数为k,昨天最大交易次数还是3) 2.昨天不持股，今天买入，要花掉一次交易次数。(前i天最大只能交易k次，你第i天交易了一次，那么前i-1天最大只能交易k-1次)T[i][k][1] = max(T[i - 1][k][1], T[i - 1][k - 1][0] - prices[i]) 121.股票买卖最佳时机Ⅰ1234567891011给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你&quot;最多只允许完成一笔交易（即买入和卖出一支股票一次）&quot;，设计一个算法来计算你所能获取的最大利润。注意：你不能在买入股票前卖出股票。示例 1:输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。//注意本题只能买入卖出股票一次，也就是只能交易一次，而每次交易都是从买入开始的，所以买入股票之后才是减少了一次交易，所以交易一次后的状态就是持有股票 123456789这一题是最多只卖买一次推导状态转移方程：dp[i][0]：规定了今天不持股，有以下两种情况：昨天不持股，今天什么都不做；昨天持股，今天卖出股票（现金数增加），dp[i][1]：规定了今天持股，有以下两种情况：昨天持股，今天什么都不做（现金数与昨天一样）；昨天不持股，今天买入股票（注意：只允许交易一次，因此今天买入股票就是第一次也是最后一次买，所以dp[i][1]就是今天股票价格的相反数）。 12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; vector&lt;vector&lt;int&gt;&gt; dp(prices.size()+1,vector&lt;int&gt;(2,0)); dp[1][0] = 0,dp[1][1] = -prices[0]; for(int i = 2;i &lt;= prices.size();i++)&#123; dp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i-1]); //只有一次交易，所以买入股票也是第一次买入，所以获得利润一定是这次股票金额的相反数 dp[i][1] = max(dp[i-1][1],-prices[i-1]); &#125; return dp[prices.size()][0];//肯定是最后天不持股前最多，因为只能买入一次，所以今天还有股票，钱一定是负数，还没卖 &#125;&#125;; 12345678910111213//滚动数组优化class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; vector&lt;int&gt; dp(2,0); dp[0] = 0,dp[1] = -prices[0]; for(int i = 2;i &lt;= prices.size();i++)&#123; dp[0] = max(dp[0],dp[1]+prices[i-1]); dp[1] = max(dp[1],-prices[i-1]); &#125; return dp[0]; &#125;&#125;; 122.股票买卖最佳时机Ⅱ123456789//本题允许多次交易给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。示例 1:输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; vector&lt;vector&lt;int&gt;&gt; dp(prices.size()+1,vector&lt;int&gt;(2,0)); dp[1][0] = 0,dp[1][1] = -prices[0]; for(int i = 2;i &lt;= prices.size();i++)&#123; dp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i-1]); //多次交易和一次交易的区别就在这里，多次交易今天买股票就有可能不是第一次交易了 dp[i][1] = max(dp[i-1][1],dp[i-1][0]-prices[i-1]); &#125; return dp[prices.size()][0];//最后一定是没有钱套在股票里面利润高 &#125;&#125;; 12345678910111213//空间优化class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; vector&lt;int&gt; dp(2,0); dp[0] = 0,dp[1] = -prices[0]; for(int i = 2;i &lt;= prices.size();i++)&#123; dp[0] = max(dp[0],dp[1]+prices[i-1]); dp[1] = max(dp[1],dp[0]-prices[i-1]); &#125; return dp[0]; &#125;&#125;; 123.股票买卖最佳时机Ⅲ123给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 &quot;两笔&quot; 交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 1234567891011121314151617//这里用到的就是k=2时的递推模板class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(prices.size()+1,vector&lt;vector&lt;int&gt;&gt;(3,vector&lt;int&gt;(2,0))); //这个初始化很重要，无论是最大交易次数为几次，第一天 dp[1][1][1] = - prices[0],dp[1][2][1] = -prices[0]; for(int i = 2;i &lt;= prices.size();i++)&#123; //其实这里顺着逆着都可以，因为他用到都是昨天的 for(int j = 2;j &gt;=1;j--)&#123; dp[i][j][0] = max(dp[i-1][j][0],dp[i-1][j][1]+prices[i-1]); dp[i][j][1] = max(dp[i-1][j][1],dp[i-1][j-1][0]-prices[i-1]); &#125;zu &#125; return dp[prices.size()][2][0];//自然是最后没有钱套在里面钱最多 &#125;&#125;; 12345678910111213141516//空间优化class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; vector&lt;vector&lt;int&gt;&gt; dp(3,vector&lt;int&gt;(2,0)); dp[1][1] = - prices[0],dp[2][1] = -prices[0]; for(int i = 2;i &lt;= prices.size();i++)&#123; //因为j=2和j=1是独立的空间，所以从后向前和从前向后都一样 for(int j = 1;j &lt;= 2;j++)&#123; dp[j][0] = max(dp[j][0],dp[j][1]+prices[i-1]); dp[j][1] = max(dp[j][1],dp[j-1][0]-prices[i-1]); &#125; &#125; return dp[2][0]; &#125;&#125;; 188.股票买卖最佳时机Ⅳ123给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 1234567891011121314151617181920212223242526//这一题就是上面可以2次交易的一般推广版，只要注意k=1时要特殊处理就行了.下面是优化过后的代码class Solution &#123;public: int maxProfit1(vector&lt;int&gt;&amp; prices) &#123; vector&lt;int&gt; dp(2,0); dp[0] = 0,dp[1] = -prices[0]; for(int i = 2;i &lt;= prices.size();i++)&#123; dp[0] = max(dp[0],dp[1]+prices[i-1]); dp[1] = max(dp[1],-prices[i-1]); &#125; return dp[0]; &#125; int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) return 0; if(k == 1) return maxProfit1(prices); vector&lt;vector&lt;int&gt;&gt; dp(k+1,vector&lt;int&gt;(2,0)); for(int i = 1;i &lt;= k;i++) dp[i][1] = -prices[0]; for(int i = 2;i &lt;= prices.size();i++)&#123; for(int j = 1;j &lt;= k;j++)&#123; dp[j][0] = max(dp[j][0],dp[j][1]+prices[i-1]); dp[j][1] = max(dp[j][1],dp[j-1][0]-prices[i-1]); &#125; &#125; return dp[k][0]; &#125;&#125;; 309. 最佳买卖股票时机含冷冻期123456789给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。示例:输入: [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]//这题还是官方题解比较清晰 1234567891011121314151617181920212223//关于冷冻期，只有卖出股票之后才是冷冻期，才会影响股票的购入，所以冷冻期一定之和购入股票有关系，而购入股票只有在持有股票这种状态才有，所有我们要到持有股票态dp[i][1]思考class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.empty() || prices.size() == 1) return 0; vector&lt;vector&lt;int&gt;&gt; dp(prices.size()+1,vector&lt;int&gt;(2,0)); dp[1][0] = 0,dp[1][1] = -prices[0]; dp[2][0] = max(dp[1][0],dp[1][1]+prices[1]); dp[2][1] = max(dp[1][1],dp[1][0]-prices[1]); for(int i = 3;i &lt;= prices.size();i++)&#123; dp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i-1]); /*现在考虑的是今天结束后你持有股票 1.昨天结束后你就有股票，今天啥也没干 2.你昨天结束之后没有，但是今天要买(所以昨天结束后一定未持股)，那么昨天要么是冷冻期，要么就是前天就没有然后昨天又没买。是否有冷冻期取决于前天到底是否卖出了股票，你前天卖出去了，昨天冷冻期，导致未持股。前天你本来就没股票，然后你昨天也没股票，昨天又没买。 综上，我们只需要保证前天结束之后你没股票，从这个状态过来就可以，所以对于前天而言，我们只需要这一种决策就可以了。因为你前天结束之后没股票，不管他是怎么没的，在我们的要求下昨天都不会买。所以在i-2天没股票的情况下过来，昨天结束之后没股票的钱是等于前天结束之后没股票的钱的。 */ &quot;最新总结，如果你想第i天买股票，那么i-1天必须没股票，但是如果从i-1天直接过来的话会有问题：因为你i-1天不持股的最大价值dp[i-1][0]可能是由于你第i-1天卖出去导致，也有可能是你第i-1天没股，啥也不动(即i-1天之前就获得了最大值)。如果如果dp[i-1][0]是由于第i-1天卖掉股票得到的，会导致今天冷冻期，结果你还买了，违反了冷冻期。所以我们要让第i天买的时候绝对不是冷冻期，所以冷冻期最多在i-1天。所以如果从i-2天过来就不会有这儿问题。为什么呢？因为i-2天之后就铁没股票的(我们从dp[i-2][0]调过来)，然后第i天要买，不管i-2天是怎么弄得，就算有冷冻期，冷冻期也只在第i-1天，对第i天一定影响都没有。还有就是我们从dp[i-2][0]过来之后，要保证第i买股票，所以i-1天必定没股票，也就是第i-1天什么都不操作。在这两层约束下，dp[i-1][0] = dp[i-2][0]的。所以调过来是没问题的&quot; &quot;保证i天不是冷冻期且第i天能买&quot;-&gt;第i-1天绝对没卖且第i-1天结束后没股票-&gt;那么i-1天开始就没股票-&gt;那么只能从i-2天后没股票这个状态过来，即dp[i-2][0]。 dp[i][1] = max(dp[i-1][1],dp[i-2][0]-prices[i-1]); &#125; return dp[prices.size()][0]; &#125;&#125;; 二叉树124.二叉树的最大路径和123456789给定一个非空二叉树，返回其最大路径和。本题中，路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。输入：[1,2,3] 1 / \\ 2 3输出：6 如图，对这样的一棵一般性的树，根的左右孩子都有两条分支。我们只要求A左子树上包括根节点在内最大单侧分支。A右子树的最大单侧分支。再将他们和根节点加起来得到一个值。这三个值最大值就是我们的结果 我们写一个函数，返回的就是root左孩子两个圈的最大值v1和右孩子两个圈的最大值v2。这样整个树路径最大值。只可能在。v1,v2,v1+v2之间取了。考虑到v1,v2都可能为负数，如果是负数对整个最大路径没有增益，所以可以用0来处理。 123456789101112131415161718class Solution &#123;public: //返回包括root在内的左右斜枝的的路径的最大值 int maxOneSide(TreeNode* root,int &amp;value)&#123; if(!root) return 0; int left = maxOneSide(root-&gt;left,value); int right = maxOneSide(root-&gt;right,value); int lmr = max(0,left) + max(0,right) + root-&gt;val; int ret = max(0,max(left,right)) + root-&gt;val; value = max(value,max(ret,lmr)); return ret; &#125; int maxPathSum(TreeNode* root) &#123; int value =INT_MIN; maxOneSide(root,value); return value; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题","slug":"算法/刷题","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题","slug":"算法/刷题","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]}