<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021每日计划</title>
    <url>/2021/01/27/2021%E6%AF%8F%E6%97%A5%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="610dbcd5c12c78880aab4f481c3ee6012dfece24e1ed79d68b10d08ba35680f2">96f2a68488faad80b51c97a5335afc52d288b9a260dfc02df6690d3b527971c474c383ae21bcfa531a8ae1ac7a9a3c5bf0b2cfc6f74cb4782d7c6310efe70c28a97cdcb74ac610160a911c89a85229343555982cd03ad7f8a01efd1262f915c77abf0dc9a62ed6e629772ecd93a2a85c4dd8a959032a92ac75b666cab8d8ba2afa21100ecc9dc9e8d9d0981a59cbd8ac52aa9b04917fdd4a141ce2203a41e478ed3a80dbd7c5000c9feb17449d8b0b5c6804d2b01f86b09de22de3c7e55a7c64c41c1bbc307e09a0b9cb9cc2f25a86c35395f7dd05e99f561948db41b472976156d37bd8ad4cafed1b80f32a3643b70e383a20515fe708d0b5c169d582c8ebcbefc323064a686f9f3cb82ecd89d54e7f380c5667e6cf9b647463b06a8205e4b536429fc01180ec108b36f226302ea265f70f5e7847081384a064bfa2fe2b0f5f3dfea55a5d81ece38300044424b942a4e70203b06d3f30e2b1ffc04ea7e17d8bf67b096f569f3f18dd9abb81cae0242daf4bc1287e1971d92324eec90e1b092cd3cb850d37fdc3c5e9988b7504e6262f005648e4637dfbacc1d7d0cf0d2d512e94e5d472f0ba423f01680c7e3a59d7cb7f40085d29b0117a721cf73f59e517c97351ac51bf055111970e4a0fb181eb5f6892bd1afe20b58ba39e5b0c9093c608bd1bbd4bdfaccd10d6271cfbd66035dde364b38ea8214db0dd59e14207badb12be33c39362a1bb7268515311d5b419772f00a0b7525872f475f57385a37420e0b23decc706a92514937192fbf164748383e189ae0d23ddd62ef644b85ad5d6b770de878ac346e16303159aee4ac17438cf0143d6c9857859a8620d78720a4e47f9c2cd266688571860a66fb7225db90a1c61b9caa8871bddd0d27c10923a21db1dde5fc77e574be43123e5325fabe3e1990bd89db9f63d724f482a4a5b63a26b9f19770c7f384e407fe94ad98a1de951dcfcaf7f6dc3d67fe3a2c0a9267879fa4ddc9c72cc05a8983455f4d52545cdf6504e4d390250d8b7046d5617a2bc3ef3672ce9fbb10ba3e80850fc37a5c9a1a94fa1672443ca0f3ef0ebd72842cf847eed659c281b8020059418df5939ceab7364d656051314da7148d70ad9eb0a44b3a2849268796e24f4ba1103cd1f3c1c593ef0dc1eba82f7200195c975d6bb2264ae81684a9da5d30e82c866e78869e82af337758da4a4fff0716f551dee5565bc1281be57d0b260aecaaec2a49afd5f3f8af71c72ba07a39b3a63e81e10e0c1e5917ad7d55dfb417bd6c980edf17b368306fd8c21d020bc775868d64dd8f64023dfc2cb10f26dcea061d16cf5bd39eb79acf688a991b9c84a984f77e2cc491abeb2ca2844609057dc4367aace71e1aa20996998688b2ac8dfa4ac6532368c3fabaacbcad603b06daabb00b6be754455b073a58350f2e7411279b6b2f80e417998a2a3e4595bc5647ea238e5984c8115b414d46b6a04e75036c3b9cbc2b5b5f6a82d421c1661318fa2592bf3650033b5dcc614e15f23e745f02fad6657525582b390e2d79f01cd7ac5ff7875b9620a100369cdc62994eaf1c77b9ba409d61471067de20d4e5d3e734ffc3f24f26c930c783ee64ca4b5bca93e6ef873f829bcd5e0b7adc982ce67af35fdbf851cfc6f797d8552ca3331bf3abc0a2537ae641e38419b34506104f3c60e8d84bb5e40ac7e6ec0eae664f6725356d14bf5d5d9b1cda2d9045eb3cea3d72c7f5a4993bcff73da43ce997ed19432997ebf6dfd9e3eb4393ec9f7cadbdcfc1eee53a58df1ae75b037bc25ac2bf6f9d4ba646c9f27a2ea4124db448f5131df396bb2dbfd866d98e1941523ff6f4f4a7b450582fbc69289881b53219b25f8d3f08bb4b8d54071368c636fc76c3621bdd3606d79b1c1c8889227e4531178a9c2fd4a074e9c733f0895530a1088e76d726f8e87050a529f0229e4912ba52b8fcf82eb07d1d938c7300e0955f3b15d01e94f962e831f055138727abe493912f33018ce7de28acb47d232321b3aeb4a12532d59abf0e11f7463e77e3834a1b0b115b4278dc2e311e6255577d4ad1ac14a4b591572c4b1c88699102c277a5c21071bf185dc515c436807e6c131ccd6d478c8021b66127077182a6d8480a1c0c9d7fd4e48e615e4281ed8cf799dcc594fba3c52610dcadd5761e9927e2ae9b326137300b0f2f9633d9dd9bb3845f2dfa265a49743c81522dcda1260fdf36bf5916559d9ba68a19a8f921bcf7c050f5e2099f5336b6dd0e5392b6f9b22e54e85529ca2f61824c5668637c4eb5d378a1671e8d8ad1f841713f80553f3b992506fa47361f30feb5cd076801b8e5b7c830ebc1f66b976727c1beefdbc49b7f23e66bcb3d2c21d3806fa4bfe55da592876edaba2b4fcde2d54fa0d686a767bf4d04254cb63156dac6c7ac0053fd48281ffa12317a3756d6d9552b09db5a75d4da55059dc9c533856d58170f6bc256e30960f63951d6e8d6eeb6072b5428c8f27dd510ed621b2118ec1294625a6148a6565b1dcc45bb130b7f4b101cd4ae30cda61e9f67cbf85c5d43fe7e39bf506bd6616af7642f5fa7e8000de70e9321af98847e4575dd394211b21ad3869c15786f5a1d8752e0846b08086c9518a237960c56a8e4fc696536ce5e1431cca82e3fae600786baaa127b9649aa04c546a9d0d998d252bf5f8b8956e1bb592440becd7fc8d47a4823956920ee3dc6227f01dfc23f13a895192478ffa8f674547d0e449521cf9c0df0a7140dbef3d7fd098e086878e7e0bad14e31438076f07d645bc9a68e5db2a2eac1e31e18a3451de9150b2b8f7669bfbcc9edb61cdd87419008f4e6083f4fe45af4679d75ab93adc29bead6caef172e804db2c2b1a1fa8a24af2af0a9eb3d3570f90f95885d5886cc451403f45bb7f1791eb7450ce886f8a407d1960039bc443ef4cf4f9f86401d608e64fff1793e99a3aebcb9caad327e453ea24454414ecf1c5c24f0840a86e15e043a692ce239b5c4f81ac90816ed4f2a34c4479b449adb634eb9f8388158331f603a878b7f6cb252a880130d1057107e5155d61cd9771db3d24fbeeaed4156ae11c38a3e27699a9a1dc8ec21a89165e7dca5a52fa6f6652d1d51e33d1a41ef020866d3731a5d81d1e51163b63584b594337aefee8ce43000e9661ef97082c6013731f72aea48cff4f37566f475a87cf5d25407287545263bbe4c28a54ab7df8b7f28c80b9b25c5be6a2141f27a6ba63d589067b299e090552e92835e8fec75f813c8869553f530cafbd6ecee3f7289c11e992e2729237b367a91744148ad7520ca7b064a6fb557bf206a89e42f314f9c171de2420effd44f1537c563a2256e4b92dc32877c046448d9e3d72eaa1124d69c137c95dce51d951434a71c272db039f08221b7c564735c8803694aafbe857b89e57eb4308ead8285636ce7f2b40999c57d520fcc63ab55f18d774c21c647f859e312eb40c6b2ead65a5f5ccd294e1f2bbbe8219d0847585aaa32a2915ff2330b9d69dcd4ed0f9d0748231192f5ab0ea33bbe4ceaca83155d9e07b5160db0b34cd3107bb4777a26031f15490f26dbba2dbbbfb7d93d1252f75990cc8cf6700a9373e4b357fe821aaf9250cc49c6c64fccaf68f9911fdd24a2cb0dc0aedcbdebf5068242a17e9bf73e6df4160241763cae62de1d6ac7b7aea460073d08383683cfe01d6560f6ae02087d9c5842c6c7b6cba4edc08684f8359f5654999d79d831037263f894849520d82756c9ac7cc8247eba5e8e1a0a033916d6613e27e37171d0ee2a645f3fe738a3d2c4da73c9946d42f3f2bb60cd344c4b7271179947c700a1cc985850387db8f5eed2e9ac25a45fdb51acbb480af4f1b863919481093eaec87959978a299245beac43e3342af780083eee9663acd44f94a2852959c4fe3c178f2911d9e21a3e7e9ca744158d3419f4b24b37eceae5ec193d56c7180e0bee6bf302d8e22138b15ec0b32de414fa9c188488696552a5c64772a12847b88c6e00aeb3954bdd7a3edc9616956a72972cc4f957681257c3ccd128dff5fdc897105f92d3d9e518ca7727bf8dabf1afee7310f86271ed6f9044b80a11366d073725f0d5267d18b7fcf502dee753080d2130884cf7b3ae6ecff89fd2581d297c6d15eb237529a9cbc5b5007a503b525778318c1789dfec452070da89a29a17ce9111c83fb60d10c2853712b90ac6853ca65de7a45b071b5cc5896e782f5fc2330008bf6c92f0258637d6b2ffb259d5dff5d2b8d2f5bdde161bdbfdbc383b0e6587d70b9b8b7a76ba0ec08d5a56b5dedd8bf078ff2ff5277e553a8f2e1e9150892dd5e2eca4d3a7e100c7d4b4f03f7ff0df5e1a87df4083fca13c844e7dd0d467c511e3834d45baed140058c76ff54cb784403d98bc36c84b2f372623659a466a7b1e72d6719c2ce0872e541a8ffc318bf395ecfe3bcac986cd34aa447ded46a279304df8a4f6624dd9737ede84744be77c87e2123c4ba4348935da027cf890efb18d29e17ae8b3b51bab215ea6d4a67b16f22693a68624679bdbad49a845ea2e025bcff2f27b71d5a68ee20a1c878231ef432e1f72f9abd74d8e3889beb187be12562b5bbc7abcfc9ef583935e34891336086d30cca59c89eaf57492e36e7fc02c9b8f6fd3a4eab0ab977ae29a6b017773696cd6ce7d99dd4730167138a2088094434a590a75a64d510ddcfa108b07f652198ca5fb7cb804d81f213b7a6e39a6915b506cfd562ab62cc2c17bf90256cde75a7b1c16a36ac2adfee99378334cd9e7d65b281080aa6f461792aae39bfd40babdba557d1616c3f04bf7c0020357410dbdf877e72ee069bff8d0bebd7f9e3003dc74ab4c5657fbdad2f32e2a29caa466defa5c2e1200ca3d844890c782ca6445b98ff08e3862b3fa3f3dc288a5747720054410dd9847cf2e8bb1d8eecac5faff561b58309c69a807e2ce312b14950c1a91789e77fd67c9df5afb0b392e74846179e91fd6174585f338b70247274cd098e67c386d8703afbdbc929c7eec5f391cb3aa1fe57d3944829c33e5f900e33337a720cd34ed0ec130ed4f81f9797331f5e6cdacaec3732cbcc8001e08c382ae095b0a2da7164e7f233a0e60ba0696a5e92e42b085024a2242790136f9881683e896a273bde3096d8d41d17ece8f9820c5b55397aec50364792dfcb06631aac5d6e306305702f67db97ffe0a5435e2eb769218cf93c46a45568c80056ebde514feffbe4b5fe2057615b907614ef3e21b09a4de46c712abaa1005166a88257b1d78b58e8502fd074e84791c91619955bb5029524d3a0a779bb0290740ac94898ededb93120526e42772c7e2a70ffb26a318b1539216fc8ce20961efdb47f53991306ddec3b93a9e5a46d14b5ed779b91f5217ce92a716b31559a4b623c32bdca201c4aae50a7031336a4b4c84b737935cf3dcf3a8ab1f764469169506c5927c9e070969028cdf50e37b5d49d368043a5e6ae4529e1b5ea394a372d56984906d2affc009c7b3bd1e71c51be296484a6a4d6b29104c5ca2f85efe79e6f200e14b4d5af9da8048a3f0a5fe64a57f72829c6c5aa58d688e9fdd8b1d1560bfd7255454ad4cf5041dd7ee79966c2956647d57a1a65f9409a244600b0f7eb0095697b3a2ee2a13efd19d9ec64b5fbe6408560a3d134937c42cbea629c97d2cd5b341df589585a914d68d8eee3469aae6c0dac713ec71252fef75f56864af56198428bb47f65911cef385a96d985523d2b78216bad047872a109460be621d5dcda64ed85f1e1d94777b956631989dcb1cbd38c1e025bbe1242ff7fe29973af8bfd2f3103868670129129ce674ae288909661f6828587f1464c0d8170a633317178b7fd1cd32a3155beaf5505904fc7ecee19e3e148e3c6179a717eddbf7814cd3057743cd97b9fb3d7fc100e53623ccae802fc43f6199763e07ef73f29954f24cd187407920b6addf10ae17fc1bf5b6d9a9077fd65d6333100224c89763837ee23ceaa0a000a06ced8dda3d28f135a1c7574637d6190d05238f40b2fe8893ff8fc7a666cb096a114ec696760564f52345e9ce7d06a34a6e34982eec562bdee681b6091fe028f6d8570b5260ca9b4041f0a5755b693885b066b08ca0b03b2c564141facf4d1f7b54a4a24cae8d979a904ba97f7b3d507ce740d80d1ea65aae15e1151c88fdc4bc4b0ea322f010eed592c9f7d2523d6269ee490f194711ca4612686117b93db5323f534c31a5501dca7ce58cec7df531842fc2929096e59b9be430585ddd3996ce8e5b38e643447f57d957e482116a4e73ff986d705a0ae1f45f7828e32397441559701b30483f400022634a54d5719b40aa4bea7283c7663a8b69f97405a8a7357e21ee641743faf3890637c7d95f458067cb6e9400f7114043bb1be2165e621ac46a156a2c70c6964815b13ed4ea6f12e0ffa4c41b848371c9f86d9089b3e81f235bd230877b36232943624c4917b811638e0182e2c51bc96d8330f899f57bebc2813c7df44c4a5c7dcc78a67b6ec0c70e40442f60e8253e91fd55c39d810a83c27bb13fe474472259086238885c4b0fe88ed1d2387f4b091d5accc6d6de77e06973ec0ddd875d7f5395e17cd9c33e36646886a4e484ff814be27d4e9cfb53e26ba224022069323c318a37dbab519ba60efe8152ea6cb63ddf22c7116821f58f41548e1547e3883c55ee92bb1fe320e2d07dd66cab7f611a7ea27d43a124cac57b6723e692d74c8af9603eabfd96b5951bb6f0ed6de3bce9e82face26f005da91f9a3b09df984aff7afeea5c72a0807dd30de0a64370953888fc55d64e576a2964dd7eb786d16e53dd2f4711cded581132788a95292a86197042325db0674d9615704f3e4286441b0181c3d5987ecfd202246d68d90df3df6d9469ddd43708cb5415991a6c97e98a5c70b23a00eebe4da0bea60e1dae3727ad4d64a19eb1dede2328ad9cac6fd7202c2bdbb24bec88fa0dccfc43cbe5397ceaf630fee214fd3a9af6b856047b384f3035004e236c318ea181ec100ee7482bd456a0f28fd8636109d4980ce615ca12c6815fd5af18c8bd781806f78887e573bae445c5393aa82786fff66758e0ad7145a455d73db9966ebae382d3fa6cf96533b9dba41bd4218604014be7c8f15039b410a885b39c0205242028424aab9352b4b72362e5f6683f49c2b522089f50fb35be6a9c2a74a6692f345c712340f15b393f005c1cd57dc8fb7a30fc6513be2af257793ab342395ddc2bfbb73f63ecbd17dd997e7b12b724602f36975dc067d0f4b4444d802743eff7b77219a2b41b613d44227192c306a01e228053c749a9ae4ee91fb4889389de717c520529bcbbea81b1c81064f5cca1172b1d67ffc665c9a3f6f3841a743a4a20e074c2c1a7abe20d64b71145816d14488692765e93009ed04a2bcf7a5929d2e17d5a20be3248a0bc6cc829d726750a4e8ba6c291cec193ca3229688e3c301123f496395f24aa1317914fedea2325e1b3891f3f34a3a9288e84b482aac53c118f61ea76478be3c2d348f043cd68ae9d8df268b2530d2df90b36e294ffd5abf6e5100efc9a5708cf2ae25cbb644d8894f72d63f745524a1d05f5d00409aac5d96dcd2ca75744f7d98d7d4adef3edfeb5c99a1a87612862f1b2de4c4ad51728570e674efbf9a603a3affc6eaf3ed6d0e2e57c4b2401f5b3e60892af973c55a95dc63a0b492efb68e4082ab72241bdb0d66ae938d67f44419268bf51422ad6969be41a58bd64fc60a470e94c91832412e0da0737269c93749a8746985e32d8091bd28d26d54b50ee220d592a119de1ba1dcf4c81dafea3cad026c29d3cc72a80f51b157d6bbdd1f8bd046834e978ec29abe914c6240e34572cb43a36efea071925caf69056e58a6f5cb6a5a664eac7599e620870d61a21372bbeeaea0c8cd15b8b970f570ad5f48ace73ca001bbadb77715a1b9992bd423e1d4bb7066ecc1852b44b739be1dd4b12c3985cc5ab59b190e44359fd2f10252715778d848b6679faec0cd24f4fd736a64cf781b81f8336e1073650c8923837ac09fa68cbed2a19645fd13ea8ca046e58b18eb9a84353bee9ec0901841ed740e121fd58d4bbde98bbb3161e7d4ab0dc547de99743bb9155afd0167a516531a2df37a371c1cbc02e00a3ced36c1f098f7c127ab7392dc8a24054e947adb673d187320800f19e82d602af1124ea0d37bb3983b624a1a7b79ddefc8ca104032a07bebb1e17ea3150ffcf9ce9e112d2e217b299d3633f6cf159ad7a259af707b44de84ce1cd7bc5db6e14526e407e826f73de3aa03e280fe0475a44a46bc156a853374a0045e59df5f958a423d5b3b9810dddef67ce1f2b7b8cd9da9476d400797cc39cf10d4b26d95ab9e7dc9428baf751a19f20d23e315e2cf01b9d73e4c29e21295bade9aba07ce6c0b20a08af62b88fe37cf0aeb8300331cdcc497836edcdc1a7d3a6c40f1dea093701f2fed461781de305d32cf94b6e2eb8d34c26847af0a64cfe001661db4adeab63e011b72a0d538a6ecc02c24f5acca10eefdf7e7983633b04ac9f6e032e307721e69b386b9a44f6d22242c13d83d54968bdfb1d0c4303b96ad96789e9e1f621eb0ddc7d6f7489deb948c7d0f8a52433e1c999aebeff03c1d387ae14f6e7c75116b57941c7305cf9558945960d407401aaf37d14ecfc4ebec2e88e743c1854f221e83bd08dc4e5aa549b7555e7d9c1b6f0a2f3b6aec054cfb77d7e167c9f6c06307436f000d6f547e8a1db4370ec8da0cd8818fd45190ad2b870d4d25d44c3dcf905a3d6e33ef8a3fdbe7d2dc4ad89bacb85c84efce89169c770cd753c443ecd9dcc096246579480727283e2294905a247ac62f951b8b0887f76f250aaae210beb3cae784c2554951873356485ae25908ea1b8d492ca2ccbb8843bb2b12588e212cac851229353b61dd69ace2ba0bb6061e3627c142844a38edbcf01dffb6c82c91a8981efdd5a1ec4527a709e22b066afa357bfe151d71e7bf2d486897b11f7f0422b1675c60a842e17cd20e304070d1bdd1d288534739d5c60d9385264ae4a24e952c68bdc0940ef1a29acea2f05303fa082fddb5388959eff21b147f8d45365a20c1d623c1395753b85979f5b9371cec21fcfb2ab3b51138bc51cb001e7a4756b32d0a22e005fbdcf58b44643a8c11b1030dcec122d0a1d531ad72fae85310793b44da8df2ba7a766a0a34bd3e6ac44c28d3e8fab11eed5ccef4cc9bffea02516eb0388ea3be9044af2f54c4000e3cb9a14deeee91a82fe706ea30c0d716b2d46c753de8eb1a957483fdab1e475b4199a7094211944b803cac6840d22934ad0c2c1e120d783d6999cc7cafa4e3a91e3e0c8b3ef9fae6ea10b2a9d56a2a164437709764a8df1e8cb11dcb365b2e0bd4e6efe7881b3a299dd3eb325e00f656a34d15b93648076de5a9b87a285592b935a1757a85663210467e39dc72e0bf8edcdb3d4604d4808432366443a06e5cbb8c45814a2a96dc7a751165220c0b2a71ab6779d76dccea81fb33409c438c9cd319786cdf19d915618cc541d279cb289d2ed8610a0011f822e6f8320ae56006c1de5d4b81ec9e9fcc76d1a9ee22c18ecca06e1e0f3ba78f7e7b34ece0d96d811f7bc75be43a0c5e20e92130fd09e094261055948035e46ed6d45d349520a550c003e0fb6b5bf9d887332655887379349e5c6b163f82094f2f9723691a103cbb70fe4c23bc23294593128238641a80b66275c31c1775b87a89d03f7cb902a3d9203617ff758c2fcef9731f5dd3ef65b9555c7dc273b3cdb1bc7aa5faf37539b02d9fe422804c9e227b4b190c40059ab41dea52db2f2e8ba297802671a252a82ca5e143ea419eb9fa6e1350b5ea8e9de4e41dfff766e3dc542b4015fc9b915473a486c14641266762aa7e8777af172e69ce9680ad1941c600da0e7c557b40df9336d27fe8c4ed5621ce1abd3f57746cd53254f72ed97d4b5ef8275cde7bee77c59715326961a637cfc6176e7a6747c8456b88b402e952838d157ff4172e976d95f96b434afa2f0ca8b46ef4ac71de9b00385e9def05cca6772b662f242075fe3bfe4afa7c70e3067c6bdef460e24635aa0c21b485e644e4e3803b57c03e59cc0f826a286bb354a2ffa7185e4254943afe5463f0e41c6536b3c19d6bad7001f679f40de130cb4af048e52afda420cf5a556d975f3a3902c1aef8cf31f9768730017159bae896edf75064010b51c47704395d2db4858826662441837c3be9d77ed026903919a6f4b22a3b7165ae4a311f02df4adee12cae51e7ff50c3b843fdb66b9afd9959d2d95b12e90e88d9405a1cf577730764123e9672ccb587f50e4c82dbf2cf4ce41f6e2ae36a6df4daccdffe1174f2b173f4a514b859d7e161f77ab9e8a806dd4a17b268074047c415cb1414c0bcd67e52f447a88cb87fa08d5302a78c9e457679e73ce9969f57a71d3cf87fdab4a8e5fb6b3e9022d7e51c97da253bb148fa1c4186769a09893f0b1e6379bb637fc4bb26747a5e1e89d7a72a71d75b7198913302ee89bad47fb8752e2c201423ee980335fa13298930e1c34a40e86b8b7afbfc57d90cd70c6ba22284d3eb839ceafc154d51db6bff9ae371ab86267568ee278927275f202c6c4756a2da0e01f4f9af3a895c41f6741bce7fbddf2db0e7167efd89a054c15e5c48a69a84f17604b81ec0ecf17d49738593931e76d359dd06b464f572fc1a11cf0766aca840aa4ea637faebd1d5142e3973f4c366a3be421d4c0c74b68f6978c0ae18c581e3dff241d316cc51d1fac0390c01538a5d8bee240fe2fba6a041cfe4fa99d667d667e565364529b50295c19a6adbe436bffb41e5c80d71523a975ebc7c68680b1c6d5bb26ebc728b074429e944464d1fdcf91dd12fc5ffb97bcc2c66019e6057a1d4b1cb6a188c07565f8b1700f2a4a1990ac7b2b72ddf4c0689360b991cf583078d32bf57fd24b0d9cd6ad982472039acd4143137d09c887554c23d5bf9f08088a4fa5582fdcb8a10f901f0db504c3624d02afb72fb25087a8c3c12a88254a84e353da8096802cefbfe7d178b0aea4adc0180887435558e844d87a9ed7cb3d1c03b16e6796b79f572daf0950e18c718e99f93590e811cd300a6a0b2a61a64ea6de0d3220cb066fa08c28f32442086b15683062492363967ce780e70fd7daf8fd52a6d953b3d4d6f65efac89007ab1681a5eaa5cd285d6c81983bf3a525b44dd25473b129129fa22c37e45d2956f15aec6f041ee908c235d812f6ed45300959cec38066c6d4a3887f16372cee9d986281b1080d145c125ed4cde75d10971552946d004a7b7af57ad16a7a21d3b5c862d730ac43002da098fc8e8371c161bcf1163ebaffdd8cf235fcce679f03f6e0313f25d45b509059cc4ab4725d6ada61850e29f32853609e8215d7dbdaee1a7c3ca8d34b561f9b2bad20641a4283084bc89a43b043f667bcc86601e2eb3ba4ff0f529392c33c0379b16e6caa76f97786b90e03ca60e949ddab979baccf0ed572b013443ef3c720819a98cd9871371a8144b6e7bde6062848dc4e091b31431e51a493858109dc893e10fa6a5adc28f7657e59af5f7817f437fbd24895c632c89aced35c705c71b79669df4ca2f6236798c283ab4c35ed3cace9e45dc4df2d075a945886e8decbf2e803414f4a9ad5b6b66eccac033a056f122f42673223f49a5f476574993eb577740018a3322e129fb17f7b252a6ddd91da989136ca672c209e62c22c230f2d9c81f462cdea4e0b3964a0b600838a4f5711e6472ce88d4835fa38ecb9b5ab038d2f59e9f6fce09794bec32650b4d70af326c273167ea16081db5eefdc1d9f098c30e5c8d4ad6511d27d51179ac04f2d1f8f7749bc6d5defff4387cdf4dedd9ce7d9761bb5d1c3701d56284f5fb6b6df8d0bbe6c3c44907f1dedc493d21f0a20db2882291337b48c588f5110bc113e448528c3fa94199083577d3e33f017509ffb2a8ca99fca761d1410765e40cc9ddb5e96df43806e30e8ebc53ef18fe5741e27cb06160b7a9a263127de71d9a7498a57037098da6ef92df1445cc803333b27df494c3f57eb8e020ce61bc80c648043a0a79a3f629995723e49c54975ae0f3e3573f92114920fc69ef7c330f886aea46aa676f90c4f3bd0891ec9eaf4337a0ffd30db074e6fad9d3f5415e0fd9d7b088a10f74f00376fb9b945ca93b1897fa0e4844ff3875d2e7ae275a5899814656fb5368d62f6744eb166ecaecccf562094e3a3bbfe9f77b46ce61e9b8a003eb743f6c864f3f0cddbc3d2df1c70ab71b06cad821802cbfed27a6c940eb8e587e5dd026b66def61fdddcbc5ad50ef4c41af6ef8a99346cecd381279d0dc4659d7aa1d551d8f5efd5d40574181dac4b43e70f29a4e17d9d1b7cbfdceb811718058f29fe68e639ec3aa3ac063326adff9214ec7e86f951014f6cebc94c478359099f33d3537d43dd9f3c05dff1a6482b3a63f7d01817d7319c6c9ec3822bae17edf21b699acd50a763ddf5ccb4889fa01a3405a3f682283e8a15fdf0b57dcc5e9c94e59785ef9581cc7195578b2b402997c9cb726e256ba2256e3ca6532be47196918acf80d32a3a29c69db449e2faa9bf0d8e70207a2c6b626e1ce11e573b5b368294d1e409ae480a8a56736256ce651240834b40f36c138b6ef3f789d0626c723c0c78b8ffc157e1984767133cd25535418eb21cbdec0c9f4e714dca26f1f1e5bda81d04c816c4ef4fcf891a960448e481633efd435ecb07448651bf545e39e253d1b8ce5e1331438106a3e78da5d357109c6f8d17b8fccb15f2d72adbb46bbdb0cb032b9ca79f7bf83000d5652b8b0e488deb0089b13b14c6eeabfc8fc8ed55d7d842a8ebb5cff9968dee244d3f1ae28bdba7948eeea169b5154761e253905bbbbdc69f7c23242f5efc4e16fa9d7484b0645016c8dea0a00e8fa30ad3f226584866db8ed497958cc67951e4629a930449358dc47b4a6a1c3a9c98b99c5260bd755666859c871b651aec07e9284dadeea8c356465ce95b9de4b669a76593f10614ab78ce52f44478547d7d156c4f5e20b56a4f2615b7632fd120e97041a2919992cfae1d9c4821f055c57a7253b2d445f78c83f5f64c62aed94c3f29b4485e3628d483fbe6d6211e7087dfbb895dd02bd6cad513566e6c9e61a931f6453b77afb3904f86670f5f14ebc64c77f72d98b5828b819a092127ee004bc15a9bdeb9118290fa9a0c224b571905441f3514e6e302c2e7bbb16bbcb5d38d610d4ddc84e463920bb3fe5bc8a2004b30cec09379c02f39a592964be870d55af140e01aef92f22ab891e4bf3fd64759e6597eef6eb08f17cce5e8fcfd7055ae3e2668aaeac97989342d77ec21a200384f2d7a08ce89409ad65a45836c5884895c73268dfaeccc8e09c0999e8dd90ad538c26c546c92f7fd8c3d3ed79181a0c67468291e87f481bf5663bfbefdb1b3cd26877305833c4523975fe2f8e3b38a3f2a5e88cae3229c60fe4f7a478e3b00a6ca979acc3630c2fcc433fc872f849ac8f6c5564e688e8ecd03cf1aa0049285522931806d156c482fe84914daf068f600d836c502e1fbd351ad1bbe5112fe69f89a303e8fadeae17c9bb559b6267492a2f23cbce6a31867d016c99809e522e2736b2254c1e056d1b76112103b7ab2f06f5afdfb888a4c14018676cba1c8dcbdcebdcaa507aec5c7d938d3171c9455b9e5ea1e1b76207fdf7d7f752b79b76969828c6f0c93d6388b74d530092bc4b40148aa67253ac94abb6f86b0cf74ef3391290c9c5656e6263ca5cd37672d78cd2a02c4826f1fc7d3da90a3cdb5587bde67130350cb39b8a22fba67f2c4ef6166e5d8fb3f09d412f551f6eedfcf80971eaaa18e014e4372579a56b4222753ecaad4cf3cbccb94897cff621f7b49253d1319b0fb5a65061fe7decb466b92cf87dad91d9029cbfc11d7cbc12df597b2f32863b07454570169e5d9df3ae43deca1450b0a23cd2cd9c1a7b3b4437d200e93bb4f01b9e655d3f5dc5eaebd14f1f7127a4f6b86778f17963902695cb0b328fac6bd2daee1e65517720b179d804653e65376da967394939168fd11889e53d155d95cd741ccf1ab3082d5e0bf1ec15f808f34748a392ef69c8d6d78f313e4e73354721a12e92583d2ad04ed87fab1393143820292aafbcfb460a8dc1d1da8c9e18f4398770f27566e7360bafbadb7e872a230b9279bb1e9aebe41d4c0b10e04cd6dcff99b764bf1529011ea4ac1134d454f8d05b551eddb47458bfa8af8704f29fb16241831e9e85fe92f8805b24588b4ea0fdca5dce84490fae1dcef956c5bd6479cb408104299a6e47788ac7b86f1c5ccd4bc0550c13a59fb240dd630e10854f1854624ad4717d0cfd717a2b4e8d38bb0d41e5a36ec7b1d5ed0fa975e4cd02aada00795c7213d69c35109f85b1318138857c3cd0b46b4cf6927a7e8e2282e80a85114bdc8fc12f06ad6496561fabb491a86bcb84be01b41688367de472f91c9458f29569e7e8891c00e11e9ccaf207e412cb688bde1b4832b7cfcb5d6ea07fb4f0f06a6564ca7669bf857bd96e6b3532f0b6b72c206e56e0e95a3be44d91d85d8c0e6bea14f810657e61026ee75eb0f4123fa51a1a57cf099f8242feb4d474485f86153b88f040ef22d4daafd0ed246fe9f1740626d6f4a3dc224f671bb74ae95b11b26a416d9f17f33e9ce4d21e63b99c43f8073c496e9e7223097b46b0ce3d0eac6188cf33736cf99c4751fd4d1711c9d94dce8c268fa67d8efcf757822d4f54b3d83bf7cfc4e8fcb82dee5c70afecf57c8da1a2454aff33d2412bcd7303148e36d5a04126565e54d8c9f89356eaf8381115dd2fc0b8410dfa48ad0b8e52a20f3cd4093ce0b23727361109a9948df89c3f38418962739a520859cf421e79426d4eabe7003f4f4e18f9cbd4645cb56349bba9d0daa5b354a627c7fec464b403e506876d7c730d6e8337bb7587fabd8f10cefd20d28f240c41bae11fc2e185e43ccca800acb97b9ba3a8cdd5ba1df017bea51e16e8ac3f1edf114589d826ea687c51bcfc4d42378d6b2ca70b3cd9c2331feba7feee756a6de6b2a67d8e57bcb48e170bc16757af187bd1e36b94697821706eeb2016e1ecb11a5efbb3e61f129b67b5c374de4c047f3086331b721b35d1d7b2c132716092d83365cca3c9ec5c9e0ae9bd14c16c6fdfc5efa50da2111e199281020c01fe9a3b62db3f630b5a91e5f73181ed048626a92b328d7294503f11f4c15980b691008a8bc3087e2a2dbe409a93fb07eb4883831c6e4a98e4b16588042a44996ec61122eb2d4a2b4173982d87b4090f37bf4ee26cc34695574f2350140b8f7fe4f7c4795e780727e7fe76702849f358b1592e867bf4c1f19516b5aea1f2454db875869bba5eccf70a4ae502d7a52a94654ea409de148f0b1b392f2b47fae03327077df3c63467d3819f76d86d94673867496086368ece78fd819aae97d5ee8292490aaf79fb393df913de6b4e6b71f65a1fc1eb5eccb87fe8e381cc54f493a9e5b79646987e94ecd67f0b2c40faf7b63552b056cf65e8465081659bfe6a8b141e33bfb3511203918b180303beb12f69f4cd5809f159b39ca2dad0a93f5de60430178b2a0203bb8f38644753a05687bf141849187ef29a7e206ee33ec1783fa2fc38feff90f80bcc4e409320db9e1bf83c68e9320d4cc560aaeade84d29394755add2fa89a14733878307c40ec7e33394ee7340f37593d6c2d893d9432e0530bd6a03bd36b5f9961e3e036ae0d373d57f75afa396305e9fe45dba8bdc1b3ac98ab13d691399d6860591d55e85e4ff496169c18475fdb286826edbcd4ea92f0a8c666cdb1c58ccde51d03e0468cee4c4c893390f348e47cc39719f81d13ec2bd50a58a944b296fe24fe60ab8d860dd73a3c4276bc969cb107827f7f9171f607478d299f7c66afe6ae4aaf19b273ab71b41cd653ffd2028823031e0050e53cdeb68d8993858481e3e27776186743b7926b8a5a692991d9e8da14eedc07520cd18444a726bb3c367b0c95d6dca4b5c977efeeb5558f8f348da376c63fc8136a978504ff9718dddf74cd5f77cd716f7d6004f033481adee59bc4a4cde3c980353bd7054873fd84764f090bd3385c1d4d83fb6c09228ae106f7ff8f3e96d6b49fe6d2f6441db43ebb85ab860b767ab3f400f0e4e5ed7e16f892d51f513261ac34634432673507480a40fd3b85864add18b8aa7a8c5c627a533fad7a4c2ef0e27f4136d9f1c8095c060dd05d9b85fc31bee4853b33ea10f8d31a5c4c46f6299d5cc55bf5b5935fb2e8b58a48d3ead6237284109943e8129056f3c45f8954dab56e0c6b3014469a80e9d27ddf66d258dc466f8c4927a7eabbfa77a227dbc85f0b8df9b3e64ea07539a24efdcfb2f9d3807f6c13c24aaecfa5ea476cdfbff0b038f31a7ad2053aad4d9932c584409e61a94b8d5b7846cb5bf1cccbfaacbca3c6aa418979cbef566a1479e9d512d87bda7716d7e9b1e7f01d5242b03c14c4255b5ae559bbb47f20075938bd5dfc8033939d36ccd581f1133a6533faaba6657569ee9ff8aadc4cf682f104cb4cb3c9c529d59d44080607ee9479985eacd10eaabaa8877552aa68adbc4a6d685b2a83c0216b0b8ab4c7eab864d4fa42497ea93982a0e02fcca2ffba13af44b983cae49ed6ea653e22099ad708938e5091aa090ad2a21efe82dc17b8a6e74e2f25f69959e884515999bd72af4ecf3384142c41331f788043de45ab066dd15b9c4c77195e5b2616bcc490fc028ce46691d4cce4f1c917f2ffe3295d357628a09211dccaabc8a256b5f668e3c558bebdd0d9cd41618e1f1d9420b614650c9dc682ac62c1902aa2595ff86689d853a0a87cc3422f3a374d351a15b78ddf30a4847147ce6f04217bb89a87de3ff35f146f1052c8998958842aaa1d930ac7be4f5cd63c2dca16a0a05ec1377f9fdedc96282f29006ed52aa66e382432d9ed9f7bf5589fe1a9b09f205c24e5462e64043e361952de59c3c4852400562bb141dd75c4dbe006e29862dba0b83ddf530ab1297a909862b95647d2cacc7aaf9bc29df6e83a653687b44f72af697deaa1982e121353b85c20cc5aac3e08baec9bead1e4f05ac3ffb08fd4cf3419979eccfed9768eb76255c791e33d183b7ee109b0325e1f560a6d4abdb0e3f05678f03b7d47182c91510e786ca2cc48179f90444c711227605684a139c37d08833c01621d151361eb0b45aa041ea1f4ce2bca56bdfe2ada5b325abe35ee97b0e3a80e8208afcb91b3274c55e41f5817dca1b47328b03a25f0d07302dddf259e095673e5bb99ebd4f4679240a0d2439786aea157d0532a180ba82625fac72e205c2bd005186249d0ab7a93fae65b42d4da90c1ecd4adb5f8ac48dadd23279c49417a7158c926799bea4f2508306a75daf867169ecf56888560b3ca901c23dc5a7484abe86bc65f31f007a48bb4d4fb43fb0c7cf2d6faa8a3e3d695223f2c22642e8bf04350b1056f1f58c368fbf17997b7699755cf9efa179818fc922d66164ea0f6e28840bd50ec73de876ffefc34c915bbf9ff3a2202afb2d86bf4efca9b55d6f6e22cc890fac145ee93b6d3eece5880b2371690bf7e31f6fda007ff2cd0d72ae9272d79c0be8761bb175d8de4f71536942c741a3d961a24c76aebba9874e80aa972af40fb0c9ca3123d4a240cacb6f4a404261b01a2db248d3377a05ccef1b7d7ef6a521b5bb39b83961ac5d40f77ed8eec48ab2971b426935e838a89d785fad149be7c077f8df7404b45b73807aeb462b69739ea384fbc19dd91febdd9d00c479a663289ba9bc83c5f0dcbbedcfa38aef581e38342271c505ae7fff9fa9ec54aa90a8d2234f1fd00344f10a25f8cf11f39bf7f986c44b56314e5d70e21d14bf70533d4686cf3c9890410bdc4896eee6a4808bbf3047035021f7d3246d7a6160826e79cf90f4124eef82447cbb0f821873afb001808459ea6e429abc4b5ab983537e4d5cbbf8bae6f69a44ac4911df71c88159ccdb79eb32308091df38a6295ac30f7bfd68a1abfffe291303032c982c0a77ce6f59e0b26eaec9ad2c0bf0fac91a187b9389a7d71384e169d3e4f2c0e7fb6b724ac99cb52942ce00683bc2d8318b46c03eb671c0db180a69192c177360d3e6b4db24b26e78c89</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>日常生活</category>
      </categories>
      <tags>
        <tag>每日计划</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL必知必会读书笔记</title>
    <url>/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="内容补充"><a href="#内容补充" class="headerlink" title="内容补充"></a>内容补充</h1><p>补一个MySQL语句的执行顺序</p>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210130001805602.png" class>

<h1 id="1-了解SQL"><a href="#1-了解SQL" class="headerlink" title="1.了解SQL"></a>1.了解SQL</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>数据库和数据库软件：数据库是<strong>存放一组</strong>按某种组织方式组织起来的<strong>数据</strong>的<strong>容器</strong>，而这里说的容器是概念性的，这个容器的物理构成是可以多样的，但一般是以计算机中的文件的形式存在(存放在外存之中)。而数据库软件(比如MySQL),他其实是DBMS，它来负责直接对物理数据库进行操作，包括修改、添加(添加则说明DBMS是创建这个数据库容器的软件)、删除数据库。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">主键和表</span><br><span class="line">	表：关系数据库中的数据以表的方式组织起来存放的。表中的每一列代表一个属性，每一个属性在创建时都要给定数据类型。</span><br><span class="line">	主键：一般在创建一张表时，默认情况下要指定某一列或某些列为主键。主键是用来区分同一张表中不同的行的，特点是：</span><br><span class="line">	<span class="number">1.</span>不同行的主键的值不相同，主键值必须唯一(若是一组列，允许某一列值相同，但是不同出现完全相同的组合方式)</span><br><span class="line">	<span class="number">2.</span>主键值不能为空</span><br></pre></td></tr></table></figure>
<p>SQL也称为结构化查询语言，是用来让DBMS识别其语义，来向数据库发出对应操作的一种语言。SQL由标准委员会制定，大部分DBMS都能识别，但是在实现上会有不同，并且不是完全可移植的，也就是不同的DBMS支持SQL会有不同点。</p>
<a id="more"></a>

<h1 id="2-MySQL简介"><a href="#2-MySQL简介" class="headerlink" title="2.MySQL简介"></a>2.MySQL简介</h1><ul>
<li><code>MySQL</code>是一种基于客户服务器的DBMS，服务器端软件来直接访问和处理数据，一般运行在一个专门的服务器上。而这个服务器端软件也就是我们的DBMS本体，比如<code>MySQL</code>这个软件。DBMS处理数据的请求一半来自于客户端软件，客户端软件包括能连接DBMS的程序设计语言编写的软件等。<strong>当然这个客户端的软件和DBMS也可以部署到同一台机器上</strong></li>
<li><code>MySQL</code>的命令行的命令后面要加上<code>;</code>才能执行</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mysql -u root -p <span class="comment">//连接数据库</span></span><br><span class="line">quit;            <span class="comment">//退出数据库连接</span></span><br></pre></td></tr></table></figure>


<h1 id="3-使用MySQL"><a href="#3-使用MySQL" class="headerlink" title="3.使用MySQL"></a>3.使用MySQL</h1><p>使用<code>MySQL</code>之前必须要连接上<code>MySQL</code>,连接时需要提供账户和密码，<code>MySQL</code>内部会存有用户的权限等信息，不同的用户对数据库的操作权限也不同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">常见命令</span><br><span class="line">show databases;</span><br><span class="line">show tables;</span><br><span class="line">use name; <span class="comment">//使用某个数据库之前要use一样，这个命令相当于切换当前工作数据库</span></span><br><span class="line">show columns from table_name;<span class="comment">//查看表的所有列的属性等</span></span><br><span class="line">describe course_info;<span class="comment">//和上面一样</span></span><br></pre></td></tr></table></figure>
<h1 id="4-检索数据"><a href="#4-检索数据" class="headerlink" title="4.检索数据"></a>4.检索数据</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">select column_name from table; <span class="comment">//查询表中某一列的所有数据，注意返回的不一定是有序的</span></span><br><span class="line"></span><br><span class="line">select c_id,c_name,c_teacher from course_info;<span class="comment">//从一张表中检索多列，都好隔开</span></span><br><span class="line"></span><br><span class="line">select * from course_info;<span class="comment">//查看所有列</span></span><br><span class="line"></span><br><span class="line">select distinct c_score from course_info;<span class="comment">//c_score可能有重复值，distinct修饰符会去重只展示不重复的值</span></span><br><span class="line"></span><br><span class="line">select distinct c_score,department_id from course_info;<span class="comment">//error,对多列去重不可以</span></span><br><span class="line"></span><br><span class="line">select c_teacher from course_info limit <span class="number">5</span>;<span class="comment">//limit接一个数，表述输出从第一行开始的5行</span></span><br><span class="line"></span><br><span class="line">select c_teacher from course_info limit <span class="number">4</span>,<span class="number">5</span>;<span class="comment">//limit接两个数，表示输出从第5行(我试了一下，给的是4，实际结果是从第5行开始算的 )开始的5行</span></span><br><span class="line"></span><br><span class="line">select course_info.c_score from manage_sys.course_info;<span class="comment">//.符号的语法，到指定表找指定列，只不过这里.相当于给出了所属关系。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="5-排序检索数据"><a href="#5-排序检索数据" class="headerlink" title="5.排序检索数据"></a>5.排序检索数据</h1>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SQL语句都是由子句构成的，order by和from where都是子句</span><br><span class="line">  </span><br><span class="line">select c_remain from course_info order by c_remain;<span class="comment">//是这样的，他先把一个表中的所有记录按c_remain这个属性排序，排序完之后再展示排序之后的记录中的c_remain这一项。先逻辑操作，再显示</span></span><br><span class="line"><span class="string">&quot;先运算————order by,再投影Select&quot;</span></span><br><span class="line">  </span><br><span class="line">select c_remain,c_name,c_score from course_info order by c_remain,c_score;<span class="comment">//输出多列;先按c_remain对表中所有记录排序，然后对按c_remain排序时相等的记录(也仅对相等的记录)再按c_score排序。两次排序之后再展示排序后记录中的c_remain,c_name,c_score这三列</span></span><br><span class="line">  </span><br><span class="line">select c_remain,c_name,c_score from course_info order by c_remain desc,c_score;<span class="comment">//先对所有记录按c_remain降序排序，然后对c_remain排序时相等的那些记录按c_score按c_score升序排序，desc只影响他最接近的那个熟悉</span></span><br><span class="line">  </span><br><span class="line">select c_remain from course_info order by c_remain desc limit <span class="number">1</span>;<span class="comment">//组合技，输出结果最大值</span></span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210125144002097.png" class>

<h1 id="6-过滤数据"><a href="#6-过滤数据" class="headerlink" title="6.过滤数据"></a>6.过滤数据</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">select c_score,c_name from course_info where c_score = <span class="number">3</span>;<span class="comment">//where进行过滤数据</span></span><br><span class="line">select c_score,c_name from course_info where c_department = &#x27;软件学院&#x27;;//如果是字符串用&#x27;&#x27;括起来</span><br><span class="line"></span><br><span class="line">select c_score,c_name from course_info where c_score = <span class="number">3</span> order by c_remain;<span class="comment">//order by和where结合时，应该先过滤然后再排序，否则会出错</span></span><br><span class="line"></span><br><span class="line">where筛选的逻辑有 = &gt; &lt; != &gt;= &lt;= between</span><br><span class="line"></span><br><span class="line">select c_remain from course_info where c_remain between <span class="number">90</span> <span class="keyword">and</span> <span class="number">100</span>;<span class="comment">//筛选范围，注意必须是范围的低端点和高端点。</span></span><br><span class="line"></span><br><span class="line">select c_id from course_info where c_remain is <span class="literal">NULL</span>;<span class="comment">//查询是否有空值，如果某一行的c_remain有空值，就返回</span></span><br></pre></td></tr></table></figure>
<h1 id="7-过滤数据加强版"><a href="#7-过滤数据加强版" class="headerlink" title="7.过滤数据加强版"></a>7.过滤数据加强版</h1><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">and</span>操作符</span><br><span class="line">select c_id from course_info where c_score = 3 and department_id = &#x27;001&#x27;;//where的筛选条件用and逻辑操作符连接</span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span>操作符</span><br><span class="line">select c_id from course_info where c_score = 3 or department_id = &#x27;001&#x27;;//找到所有c_score = 3或者department_id = ‘001’的记录，并返回这些记录中的c_id。其实过程也应该就是在不满足一个条件的记录中再去找那些满足第二个条件的那些记录</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210125152646309.png" class>

<p>由于SQL语句设定的and操作符计算次序优先级比or要高，所以上面的语句会被解析为3 or (1 and 2)</p>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210125152921378.png" class>

<p>消除歧义的方法就是使用括号提升优先级。使用and 和 or组合时，尽量使用()来明确条件的组合。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">select c_remain from course_info where c_remain <span class="title">in</span> <span class="params">(<span class="number">80</span>,<span class="number">88</span>,<span class="number">95</span>)</span></span>;<span class="comment">//()除了提升优先级之外还可以圈出一个集合，比如上面就圈出了一个数量集合，集合中有80 88 95三个元素，和in操作符结合。这个where条件就是找所有剩余数量为80 88 95的记录</span></span><br><span class="line">用in圈定范围比用<span class="keyword">or</span>一个一个连接要好，因为in比<span class="keyword">or</span>快。</span><br><span class="line">    </span><br><span class="line"><span class="function">select c_remain from course_info where c_remain <span class="keyword">not</span> <span class="title">in</span> <span class="params">(<span class="number">80</span>,<span class="number">88</span>,<span class="number">95</span>)</span></span>;<span class="comment">//用not取个反</span></span><br></pre></td></tr></table></figure>
<h1 id="8-用通配符进行过滤"><a href="#8-用通配符进行过滤" class="headerlink" title="8.用通配符进行过滤"></a>8.用通配符进行过滤</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">select c_teacher from course_info where c_department like &#x27;%学院&#x27;;</span><br><span class="line">上面是使用%通配符，他代表任意字符出现任意次数(包括<span class="number">0</span> <span class="number">1</span> ...n)组成的字符串(说人话就可以表示任意的字符，包括空)，这里就是找所有记录的department中，以...学院结尾的记录。</span><br><span class="line"><span class="number">1.</span>上面的 %学院称为搜索模式;</span><br><span class="line"><span class="number">2.</span>搜索语句中使用模式必须加上like操作符(like可做操作符也可以做谓词);</span><br><span class="line">3.通配符可以有多个，也可以出现在搜索模式的任意位置，比如&#x27;%han%&#x27;就是代表所有存在han文本的属性</span><br><span class="line"><span class="number">4.</span>通配符也匹配不了<span class="literal">NULL</span>，检查<span class="literal">NULL</span>值只能用is <span class="literal">NULL</span>;你<span class="string">&#x27;%&#x27;</span>也不能匹配<span class="literal">NULL</span></span><br><span class="line">5.有的MySQL匹配时设置了大小写敏感，那么你&#x27;%H&#x27;是搜索不到&#x27;%h&#x27;的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x27;_ello&#x27;: -通配符只能匹配一个字，不能多也不能少，即不能出现0次</span><br><span class="line">select c_teacher from course_info where c_department like &#x27;_软件学院&#x27;;//这样就是什么也搜不到</span><br><span class="line"></span><br><span class="line">通配符注意事项</span><br><span class="line"><span class="number">1.</span>尽量少用通配符搜索，比较慢</span><br><span class="line"><span class="number">2.</span>如果要用，尽量避免把通配符放在开头，放在开头搜索是最慢的</span><br></pre></td></tr></table></figure>


<h1 id="9-用正则表达式进行搜索"><a href="#9-用正则表达式进行搜索" class="headerlink" title="9.用正则表达式进行搜索"></a>9.用正则表达式进行搜索</h1><ul>
<li>正则表达式也是一种模式，where语句可以根据这个模式来匹配文本</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.正则表达式匹配及其特点</span></span><br><span class="line">select c_teacher from course_info where c_department regexp &#x27;科学&#x27;;//正则表达式匹配，他会查找所有记录的c_department,检查其文本中是否有&#x27;科学&#x27;这个模式，即是否有&#x27;科学&#x27;这个文本，有的话就返回。即查看属性值中是否有这个正则表达式模式的文本，用的关键字是regexp</span><br><span class="line">1.&#x27;科学&#x27;：这个同样也叫做模式</span><br><span class="line">2.&#x27;.科学&#x27;：这个.是正则表达式支持的符号，代表任意一个字符，和&#x27;-&#x27;通配符一样，仅能且必须要代表一个符号，不能空。</span><br><span class="line"><span class="number">3.</span>正则表达式的匹配默认不大小写敏感，如果要明确区分大小写，加上binary关键字。</span><br><span class="line">select c_teacher from course_info where c_name regexp binary &#x27;WuHanyi&#x27;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.通配符模式匹配的特点(比较着看)</span></span><br><span class="line">select c_teacher from course_info where c_department like &#x27;科学&#x27;;//而这个是查找所有记录，查看他们的属性值是否为&#x27;科学&#x27;。即用like就是看属性值是否和我这个模式匹配</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.or连接符</span></span><br><span class="line">select c_teacher from course_info where c_department regexp &#x27;科学 | 学院 | 软件&#x27;;// |表示或运算，连接</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.[]符号</span></span><br><span class="line">select c_teacher from course_info where c_department regexp &#x27;[软件科学]学院&#x27;;//这个[软件科学]的意思是  [软件|科学]，[]括起来的字符也是一种或逻辑，这里让找的c_department中出现&#x27;软件学院&#x27; | &#x27;科学学院&#x27;的文本。</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.[]和 |的对比</span></span><br><span class="line">select c_teacher from course_info where c_department regexp &#x27;软件 | 科学学院&#x27;;//如果这样写,意思就是查找出现&#x27;软件&#x27; | &#x27;科学学院&#x27; 文本的记录</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.[]里面的^符号</span></span><br><span class="line">&#x27;[^软件科学]学院&#x27;:这个就是找除&#x27;软件学院&#x27;和&#x27;科学学院&#x27;以外的所有文本</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.范围匹配</span></span><br><span class="line">&#x27;[1-5] hello&#x27;:范围匹配，也就是&#x27;[12345] hello&#x27;这个模式的简写</span><br><span class="line">&#x27;[a-p]&#x27; hello&#x27; :同范围匹配</span><br><span class="line">&#x27;[1-5\\.]&#x27;:范围匹配，也就是&#x27;[12345\\.] hello&#x27;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.匹配特殊字符</span></span><br><span class="line">如果要匹配有.符号的文本，用&#x27;.&#x27;不行，因为他代表所有字符。所以匹配特殊字符需要加上转义符号&#x27;\\&#x27;，转义符号可以原本有特殊意义的符号变为他字符层面的意思。所以匹配的模式是&#x27;\\.&#x27;  ;一般语言的转移符号都是一个\，但是mysql需要2个</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210128165926938.png" class>

<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210128165951012.png" class>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">上面都是正则表达式定义的特殊符号，举个例子</span><br><span class="line">select name from student_info where id regexp &#x27;[:alnum:]&#123;4&#125;&#x27;</span><br><span class="line">这个[:alnum:]就是任意数字或字母，而&#123;4&#125;就是指定匹配4次，所以这个意思就是匹配任意数字或字母重复出现4次的文本，比如&#x27;1111&#x27;,&#x27;aaaa&#x27;都是</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210128171243689.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">上面都是定位符，前面说的都是从属性值的任意位置开始匹配，如果想从指定位置开始匹配就要使用上面的定位符</span><br><span class="line">select name from s_info where id regexp &#x27;^[1-5//.] hello&#x27;;</span><br><span class="line">这个就是在属性的开头，检查有没有&#x27;[1-5//.] hello&#x27;的文本</span><br><span class="line">    ^在[]里面和外面有不同的涵义</span><br><span class="line">    </span><br><span class="line"><span class="comment">//正则表达式的测试，也就是不依赖数据库单纯测试表达式是否可行</span></span><br><span class="line">    select &#x27;hello world&#x27; regexp &#x27;d&#x27;</span><br><span class="line">    这个测试式子只会返回<span class="number">0</span>或<span class="number">1</span>，有就<span class="number">1</span>，无<span class="number">0</span>,上面式子返回的就是<span class="number">1</span></span><br></pre></td></tr></table></figure>


<h1 id="10-创建计算字段"><a href="#10-创建计算字段" class="headerlink" title="10.创建计算字段"></a>10.创建计算字段</h1><ul>
<li>所谓计算字段就是本身并不存在于数组库中(即数据库中本没有这一列)，是由DBMS按照输入的SQL语句(应该说是MySQL支持的特殊的SQL语句)来将数据库中的数据进行拼接等逻辑操作处理后返回的特殊数据(特殊处理后的数据)。</li>
<li>使用计算字段就是因为大多数情况下，并不是直接获取数据库中的数据。比如数据库中有商家店名、商店地址这两列，我想要获得店名(商店地址)这样的一种数据，数据库中没有，这时候就需要DBMS将数据库中的数据特殊处理后生成符合我们要求的数据，也就是计算字段。</li>
<li><strong>综上，用函数处理的一堆数据称为计算字段</strong></li>
<li>其实我们也可以在客户端对数据进行组合处理，但是肯定没有DBMS干这事快。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Concat函数拼接生成计算字段</span></span><br><span class="line">select Concat(s_name,&#x27;的&#x27;,c_name,&#x27;成绩为&#x27;,grade) from grade_info;</span><br><span class="line">结果就是返回<span class="string">&quot;s_name的c_name成绩为grade&quot;</span>这样一种数据</span><br><span class="line"></span><br><span class="line"><span class="comment">//Trim函数，来去除某一列数据的空格</span></span><br><span class="line">select Concat(RTrim(s_name),&#x27;的&#x27;,c_name,&#x27;成绩为&#x27;,grade) from grade_info;//比如这个就是去掉了s_name右边的空格。以此类推还有LTrim,Trim(两边的空格都去掉)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用as关键字给计算字段取个别名</span></span><br><span class="line">select Concat(s_name,&#x27;的&#x27;,c_name,&#x27;成绩为&#x27;,grade) as info from grade_info;//给这一串数据取名为info，目前不知道有啥用</span><br><span class="line"></span><br><span class="line"><span class="comment">//真&quot;计算&quot;字段，支持+-*/，可以用()来区分优先级</span></span><br><span class="line">select c_score*c_remain as score from course_info;</span><br></pre></td></tr></table></figure>
<h1 id="11-使用数据处理函数"><a href="#11-使用数据处理函数" class="headerlink" title="11.使用数据处理函数"></a>11.使用数据处理函数</h1><p>本章只要知道有这么个东西，真正用再来查</p>
<p>大多数的DBMS都支持下列三类函数</p>
<ol>
<li>文本处理函数</li>
<li>日期和时间处理函数</li>
<li>数值处理函数</li>
</ol>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210128182110172.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">这里面注意的就是Soundex(),有点邪乎，他是找发音匹配的数据</span><br><span class="line">比如数据库有个人名为Steve，但是你输入成Stev是找不到的，但是Soundex(Stev)就能找到Steve,感觉没啥用</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210128182641137.png" class>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">举一个例子，比如数据库中有一列是日期这一项，但是日期是年/月/日 时/分/秒 格式来存放的，你要查找时，完全不记得时/分/秒，你只记得，是几号。那么查找就可以用Data()函数</span><br><span class="line">select ord_num,ord_id from order where Data(order_date) = &#x27;2020/1/27&#x27;;//这个感觉很有用</span><br><span class="line"></span><br><span class="line">select ord_num,ord_id from order where Year(order_date) = &#x27;2020&#x27; and Month(order_date) = 9;//查询2020年9月的所有订单，组合技，也挺有用的</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210128184022029.png" class>

<p>上面是常见的数值处理函数，各大DBMS这个函数好像是一致的</p>
<h1 id="12-汇总数据"><a href="#12-汇总数据" class="headerlink" title="12.汇总数据"></a>12.汇总数据</h1><img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210128191736465.png" class>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AVG返回列的平均值</span></span><br><span class="line">select AVG(grade) from grade_info where s_id = &#x27;sa20225068&#x27;;//返回特定用户的在grade这一列的平均成绩</span><br><span class="line">AVG忽略值为<span class="literal">NULL</span>的列</span><br><span class="line"></span><br><span class="line"><span class="comment">//Count()确定表中行的数目或者符合特定条件的行的数目</span></span><br><span class="line"><span class="number">1.</span>Count(*):返回表的行数，不管表值是否为<span class="literal">NULL</span>,即*时不忽略<span class="literal">NULL</span></span><br><span class="line"><span class="number">2.</span>Count(column):返回特定列不为<span class="literal">NULL</span>的行数</span><br><span class="line"></span><br><span class="line"><span class="comment">//MAX(column),MIN(column),SUM(column)的用法都是相同的</span></span><br><span class="line"><span class="function">select <span class="title">MAX</span><span class="params">(c_score*c_remain)</span> from course_info</span>;<span class="comment">//处理普通用法之外还可以这么用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//聚集不同的值，对于SUM,AVG,Count来说有用</span></span><br><span class="line">select AVG(distinct grade) from grade_info where s_id = &#x27;sa20225068&#x27;;//返回特定条件的grade中，不重复的值的平均值</span><br><span class="line">Count只能Count(distinct column),不能Count(distinct *);</span><br><span class="line">SUM(distinct c_score*c_remain);这种也是可以的</span><br><span class="line"></span><br><span class="line"><span class="comment">//这些聚集函数还能一起用</span></span><br><span class="line">select AVG(grade) as s_avg,</span><br><span class="line">	   SUM(grade) as s_grd,</span><br><span class="line">from grade_info where s_id = &#x27;sa20225068&#x27;;//列属性之间加上,号，而不是换行加,</span><br></pre></td></tr></table></figure>


<h1 id="13-分组数据"><a href="#13-分组数据" class="headerlink" title="13.分组数据"></a>13.分组数据</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建分组</span></span><br><span class="line">select c_name,s_id,Count(s_id) as &#x27;学生成绩条数&#x27; from grade_info group by s_id;</span><br><span class="line">上面意思是将所以记录按照s_id进行分组，s_id有几个不重复的，就分几组。记录分组之后，他给你返回的数据都是按组进行返回的。分组后的Count(s_id)也是由系统自动按组计数的</span><br><span class="line">    如下图所示，按s_id分组之后只有两组，所有返回的数据都是两行。虽然每一组c_name的取值也有多个，但是按组返回，返回的就是每一组s_id的第一个c_name(这个应该是随机的，我也只是看到现象)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//2.注意点</span></span><br><span class="line"><span class="number">1.</span>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</span><br><span class="line"><span class="number">2.</span>如果分组列中具有<span class="literal">NULL</span>值，则<span class="literal">NULL</span>将作为一个分组返回。如果列中有多行<span class="literal">NULL</span>值，它们将分为一组。</span><br><span class="line"><span class="number">3.</span>除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。(那我下面截图中的示例语句是错的)正确应该是</span><br><span class="line">    select c_name,s_id,Count(s_id) as &#x27;学生成绩条数&#x27; from grade_info group by s_id,c_name;</span><br><span class="line">	我是按s_id分组的，所以最后每个s_id就可以代表一个分组，最后投影投的是分组，也就是s_id</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210128204853697.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.过滤分组，MySQL使用having子句过滤分组；where子句处理不了分组，只能过滤行</span></span><br><span class="line">select s_id,Count(s_id) from grade_info where grade &gt; <span class="number">10</span> <span class="function">group by s_id having <span class="title">Count</span><span class="params">(s_id)</span> &gt; 3</span>;</span><br><span class="line">这个筛选顺序是这样的：先去找出所有grade大于<span class="number">10</span>的行，然后再把找出的这些行按s_id分组，然后计算count(s_id),此时Count(s_id)就是每个分组的s_id数目了，最后再筛选出分组中(s_id)个数大于<span class="number">2</span>的分组，最后再提取分组的s_id，计算字段。(再提醒一句，select子句的列除了计算字段外其他都要是group子句中的列)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.group by和order by结合</span></span><br><span class="line">select s_id,AVG(grade) <span class="function">as a_grd from grade_info group by s_id having <span class="title">Count</span><span class="params">(s_id)</span> &gt; 1 order by a_grd</span>;</span><br><span class="line">先按s_id分组，然后按分组，然后计算分组的Count(s_id)之后筛选，最后再将筛选出来的分组按照计算字段a_grd排序，最后投影。<span class="string">&quot;注意这里面排序貌似可以不用select子句后面的属性，但是把，你是输出这些玩意，肯定要按你投影的某个属性来排序，所以这里是按出现在select子句后面的计算字段来排序的&quot;</span></span><br><span class="line">注：还有一点，我终于知道了给计算字段取别名有啥用了</span><br></pre></td></tr></table></figure>
<p>最后再总结一下select子句的各个关键字：</p>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210128214816717.png" class>

<h1 id="14-使用子查询"><a href="#14-使用子查询" class="headerlink" title="14.使用子查询"></a>14.使用子查询</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.利用子查询进行过滤</span></span><br><span class="line">假设订单号和订单物品的关系存储在表A中，用户和订单号的关系存储在表B中，我现在有这么个需求：我要查询所有买过商品&#x27;TNT_2&#x27;的用户的u_id,为完成这个功能，我们可以分两步来做</span><br><span class="line">1.根据prod_id = &#x27;TNT_2&#x27;在表A中筛选出订单号order_id</span><br><span class="line"><span class="number">2.</span>在B中根据<span class="number">1</span>筛选出来的订单号来筛选u_id</span><br><span class="line">但是上面的功能可以使用嵌套子查询来完成</span><br><span class="line">select u_id from B where order_id in (select order_id from A where prod_id = &#x27;TNT_2&#x27;);</span><br><span class="line"><span class="number">1.</span>子查询语句是从内向外执行的，也就是嵌套在最里面的()中的select语句先执行，然后逐渐到外层。</span><br><span class="line"><span class="number">2.</span>子查询一般和in搭配使用，当然也可以用 = !=等逻辑</span><br><span class="line"><span class="number">3.</span>()套着的查询语句称为子查询语句</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.子查询替代计算字段</span></span><br><span class="line">select c_department,(select Count(*) from course_info where department_id = &#x27;001&#x27;) as course_num from course_info;</span><br><span class="line">也就是计算字段也可以用子查询语句代替</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.相关子查询————涉及外部查询的子查询</span></span><br><span class="line">select cust_name,cust_state,</span><br><span class="line">	(select Count(*) from orders where orders.cust_id = customers.cust_id) as orders from coustomers;</span><br><span class="line">orders.cust_id = customers.cust_id这个用到了全限定命名，原因是不加全限定，他会认为cust_id都是orders表的，即orders.cust_id = orders.cust_id;</span><br><span class="line">	用了全限定命名之后就称为相关子查询了，当然逻辑是因为你涉及外部查询-&gt;不得不提全命名限定</span><br><span class="line">	在customers表中cust_id是唯一的，所以orders.cust_id = customers.cust_id就是用customers的cust_id去订单表匹配cust_id相同的记录</span><br></pre></td></tr></table></figure>


<h1 id="15-联接表"><a href="#15-联接表" class="headerlink" title="15.联接表"></a>15.联接表</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.关系数据库的设计优点</span></span><br><span class="line">现在我想存储商品信息还有商品的供应商信息，如果存在一张表中会造成冗余即大量的空间浪费，我们用一张表只存商品信息，另一张存供应商信息，这个时候我们需要建立这两张表之间的联系，此时我们可以设立外键来建立两张表之间的联系。</span><br><span class="line">我们把供应商id作为供应商表的主键，然后在商品表中设立一列，这一列存放这个商品的供应商id，那么对于商品表来说，供应商id就是他的外键。这样供应商的信息改变只需要需改供应商表就可以的，对与他有关系的其他表没有影响。</span><br><span class="line"><span class="string">&quot;外键&quot;</span>：是表的一列，这一列是数据库中其他表的外键，通过外键来构建表之间的联系</span><br><span class="line">关系数据库优点：关系数据库的可伸缩性比较好，即能适应不断增加的工作量而不失效。</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建联结</span></span><br><span class="line">如下图所示的语句，select子句的列来自于不同的表，from子句之后也是跟着两个要联结的表的表名，两个表根据where的条件进行联结。如果不使用where子句来联结，输出的结果就是两张表的笛卡尔积(表A的每一行都和表B的所有行拼接，生成的结果有很多是没意义且不需要的)。</span><br><span class="line">这里的where条件就是将表vendors的vend_id值和表products的vend_id值相等的行拼接起来(以表的形式看就是生成了一张新表，这个新表每一行= vendors表一行+products表的一行 这种形式),在vendors中vend_id是主键，唯一。</span><br><span class="line"><span class="number">1.</span><span class="string">&quot;联结也不是数据库存在的东西，他们DBMS根据逻辑计算出来的结果&quot;</span></span><br><span class="line"><span class="number">2.</span>这里where条件创建的都是等值联结，根据两个表的值相等建立连接;也称为内部联结</span><br><span class="line"><span class="number">3.</span>还有一种特殊写法也能完成下面图片的同样功能，是inner join语法的</span><br><span class="line">    select vend_name,prod_name,prod_price from vendors inner join products on vendors.vend_id = products.vend_id;</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210129200253411.png" class>

<p>同时还可以联结多个表，如下图所示</p>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210129202119584.png" class>

<p>注意products.vend_id = vendors.vend_id 和后面的那一句才是等值联结的条件，order num = 20005这个是筛选条件，筛选出前两个等值联结条件建立的联接表的行</p>
<h1 id="16-创建高级联结"><a href="#16-创建高级联结" class="headerlink" title="16.创建高级联结"></a>16.创建高级联结</h1><p>除了可以给列、计算字段取别名外，还可以给表取别名，如下图所示</p>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210129205201038.png" class>

<p>使用不同的类型联结：自联结、自然联结、外部链接(上一章是内部联结)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.自联结，如下图所示</span></span><br><span class="line"><span class="number">1.</span>在from子句后面取的别名在前面的select子句就可以用</span><br><span class="line"><span class="number">2.</span>自联结就是两张相同的表联结，因此必须要是使用全限定命名</span><br><span class="line"><span class="number">3.</span>他的速度有时候比一般的子查询速度要快</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210129210601757.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.自然联结</span></span><br><span class="line">两张表联结的基础就表中存在相同的列，那么普通的等值连接生成联接表中会有多个相同的列,自然联结就是生成的联接表中相同的列只出现一次。但是现在的内部联结基本都是自然联结，也就是把重复列合并了，我们也不要考虑(....😔)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//3.外部联结，见下图</span></span><br><span class="line">内部联结时，表A和表B中相同列值的行联结到一起，但是有时候也想把某张表不相同的行也包含进来，此时就需要外部联结。加入我把A B联结，时把A中列值不相等的行也并入到联接表中，那么在联接表中自然没有与之对应的B表的行的信息，所以在联接表中对应的值就是<span class="literal">NULL</span></span><br><span class="line">    外部联结和内部联结语法相似outer join，但是要加上left或者right，他表示把outer join子句左边的表的列值不相等行加入联接表还是右边。比如下图，左边就是customers表，右边就是orders表</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210129215147411.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4.联结中使用聚集函数，如下图</span></span><br><span class="line">先内部联结生成联接表，然后再对生成的联接表分组，最后再对分组投影计算字段</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210129220059279.png" class>



<h1 id="17-组合查询"><a href="#17-组合查询" class="headerlink" title="17.组合查询"></a>17.组合查询</h1><p>组合查询就是将多条select语句的输出结果结合起来</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.使用union关键字创建组合查询</span></span><br><span class="line"><span class="number">1.</span>看情况使用(目前没实战，不清楚)，下面这个例子其实在where条件中用或连接起来也可以</span><br><span class="line"><span class="number">2.</span>两个select语句的结果集是合并到一起输出的(前提是两条语句输出的列是一致的，不然也没意义)，如果两条语句的结果有重复，MYSQL会自动合并，如果不想合并重复就在<span class="class"><span class="keyword">union</span>后面加<span class="title">all</span></span></span><br><span class="line"><span class="class">3.如果要对组合查询结果集排序，那么<span class="title">order</span> <span class="title">by</span>子句应该放在最后一个<span class="title">select</span>语句的后面，也就是只能出现一次。但是放在最后不代表只对最后一个<span class="title">select</span>语句的结果排序，他是回对所有<span class="title">select</span>语句组合到一起的结果排序</span></span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210129221129478.png" class>

<h1 id="18-全文本搜索-了解"><a href="#18-全文本搜索-了解" class="headerlink" title="18.全文本搜索(了解)"></a>18.全文本搜索(了解)</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.理解全文本搜索</span></span><br><span class="line"><span class="number">1.</span>MySQL支持多种数据库引擎，并非所有引擎都支持全文本搜索，Innodb不支持，MyISAM支持。</span><br><span class="line"><span class="number">2.</span>全文本搜索相比于前面说的通配符匹配、正则表达式搜索有以下好处：</span><br><span class="line">	<span class="number">1.</span>通配符匹配和正则表达式搜索需要检索所有的行，所以比较耗时，全文本搜索不需要</span><br><span class="line">	<span class="number">2.</span>通配符匹配和正则表达式搜索很难指定匹配什么，不匹配什么，他们只有和每一行都匹配一下才知道匹不匹配</span><br><span class="line">	<span class="number">3.</span>通配符匹配和正则表达式搜索搜索一个词时，会返回所有含该词的行，而不区分只含一次的行和含多次的行(即多次出现)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.使用全文本搜索</span></span><br><span class="line"><span class="number">1.</span>为了进行全文本搜索，必须对被搜索的列添加索引，而且要随着数据的改变不断地重新索引。在对表列进行适当设计后，MySQL会自动进行所有的索引和重新索引。在索引之后，SELECT可与Match()和Against()一起使用以实际执行搜索。</span><br><span class="line"><span class="number">2.</span>下图是建表时创建索引，在fulltext()语句添加被索引的列，多行用,隔开。</span><br><span class="line"><span class="number">3.</span>可以在创建表时指定FULLTEXT，或者在稍后指定（在这种情况下所有已有数据必须立即索引————目前不懂啥意思）。</span><br><span class="line"><span class="number">4.</span>不要在导入数据时使用FULLTEXT，应该首先导入所有数据，然后再修改表，定义FULLTEXT，这样有助于更快地导入数据</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210130165743603.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">5.在索引之后，使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。如下图，Match(note_text)指示MySQL针对指定的列进行搜索，Against(&#x27;rabbit&#x27;)指定词rabbit作为搜索文本。注意以下几点</span><br><span class="line">	<span class="number">1.</span>搜索文本为中文时多半会失败</span><br><span class="line">	<span class="number">2.</span>传递给Match()的值必须与FULLTEXT()定义中的相同。如果指定多个列，则必须列出它们（而且次序正确）。</span><br><span class="line">	<span class="number">3.</span>搜索不区分大小写 除非使用BINARY方式（本章中没有介绍），否则全文本搜索不区分大小写</span><br><span class="line">	<span class="number">4.</span>全文本搜索的会对结果排序(如果是通配符like匹配，不用order by是不会给你排序的)。具有较高等级的行先返回，而这个等级rank由MySQL根据行中词的数目、唯一词的数目、整个索引中词的总数以及包含该词的行的数目计算出来。。</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210130170234265.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.使用查询扩展，例子如下图</span></span><br><span class="line">❑ 首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有行；下图就是找出所有包含&#x27;anvils&#x27;的行</span><br><span class="line">❑ 其次，MySQL检查这些匹配行并选择所有有用的词（这个靠mysql发挥）。</span><br><span class="line">❑ 再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还使用上面检索到的所有有用的词来搜索。</span><br><span class="line"></span><br><span class="line">书上的例子：</span><br><span class="line">第一个记录包含词anvils，因此等级最高。第二个记录与anvils无关，但因为它包含第一行中的两个词（customer和recommend），所以也被检索出来(这个就是mysql认为有用的词)。第<span class="number">3</span>行也包含这两个相同的词，但它们在文本中的位置更靠后且分开得更远，因此也包含这一行，但等级为第三。第三行确实也没有涉及anvils（按它们的产品名）。</span><br><span class="line">	查询扩展用来设法放宽所返回的全文本搜索结果的范围。说白了就是返回更多可能的结果而不是只返回和查找文本匹配的结果,但是这些可能的结果不一定有用</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210130175013504.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4.使用布尔文本搜索</span></span><br><span class="line"><span class="number">1.</span> 使用布尔文本搜索可以提供的线索有以下</span><br><span class="line">    ❑ 要匹配的词；</span><br><span class="line">    ❑ 要排斥的词（如果某行包含这个词，则不返回该行，即使它包含其他指定的词也是如此）；</span><br><span class="line">    ❑ 排列提示（指定某些词比其他词更重要，更重要的词等级更高）;</span><br><span class="line">    ❑ 表达式分组；</span><br><span class="line"><span class="number">2.</span> 布尔方式不同于迄今为止使用的全文本搜索语法的地方在于，即使没有定义FULLTEXT索引，也可以使用它。但这是一种非常缓慢的操作（其性能将随着数据量的增加而降低）。</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210130181439859.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">3.</span> 上图就是布尔方式的所有操作符，在下面展示他们的用法</span><br><span class="line">	1. &#x27;heavy -rope*&#x27; :就是匹配所有包含heavy但是不包含任意以repo开头的词(如repos)的行,*是通配符，替代任意多个词</span><br><span class="line">	<span class="number">2.</span> 匹配包含词rabbit和bait的行，两个都必须有。</span><br><span class="line">	<span class="number">3.</span> 没有指定操作符，这个搜索匹配包含rabbit和bait中的至少一个词的行(搜索得到的集合大于加+操作符的)。所以只有一个单词的话加不加+都是无所谓的，不加+他也没得选</span><br><span class="line">	<span class="number">4.</span> 搜索匹配短语rabbit bait而不是匹配两个词rabbit和bait。</span><br><span class="line">	<span class="number">5.</span> 匹配rabbit和carrot，增加前者的等级，降低后者的等级。</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210130181639037.png" class>

<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210130182242164.png" class>

<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210130192639731.png" class>

<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210130193150140.png" class>

<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210130193230814.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5.使用说明</span></span><br><span class="line">❑ 在索引全文本数据时，短词被忽略且从索引中排除。短词定义为那些具有<span class="number">3</span>个或<span class="number">3</span>个以下字符的词（如果需要，这个数目可以更改）。</span><br><span class="line">❑ 许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。因此，MySQL规定了一条<span class="number">50</span>%规则，如果一个词出现在<span class="number">50</span>%以上的行中，则将它作为一个非用词忽略。<span class="number">50</span>%规则不用于IN BOOLEAN MODE。</span><br><span class="line">❑ 如果表中的行数少于<span class="number">3</span>行，则全文本搜索不返回结果（因为每个词或者不出现，或者至少出现在<span class="number">50</span>%的行中）。</span><br><span class="line">❑ 忽略词中的单引号。例如，don<span class="number">&#x27;</span>t索引为dont。</span><br><span class="line">❑ 不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果。</span><br><span class="line">❑ 如前所述，仅在MyISAM数据库引擎中支持全文本搜索。</span><br></pre></td></tr></table></figure>
<h1 id="19-插入数据"><a href="#19-插入数据" class="headerlink" title="19.插入数据"></a>19.插入数据</h1><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.数据插入</span></span><br><span class="line"><span class="number">1.</span>INSERT是用来插入（或添加）行到数据库表的。插入可以用几种方式使用：</span><br><span class="line">	❑ 插入完整的行；</span><br><span class="line">	❑ 插入行的一部分(某些列)；</span><br><span class="line">	❑ 插入多行；</span><br><span class="line">	❑ 插入某些查询的结果。</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.插入一行</span></span><br><span class="line">	insert into grade_info values(&#x27;202000008&#x27;,&#x27;test1&#x27;,&#x27;ios&#x27;,&#x27;74&#x27;,&#x27;12345678&#x27;);//这种方式是使用默认的表中列的定义次序，但是表列的次序可能改变，所以这是不安全的。并且这种方式下除非所有列都可以不填，只有一个列必须要填值，那么你就不能在values里面省去可以不填值的列的值。</span><br><span class="line">	<span class="function">create table <span class="title">test</span><span class="params">(id <span class="keyword">int</span> <span class="keyword">not</span> null auto_increment,name <span class="keyword">char</span>(<span class="number">50</span>) null,primary key(id))</span></span>;</span><br><span class="line">	insert into test values(&#x27;hello&#x27;);//错误，因为按照表列的定义次序，他是有两列的，你这里只给出一列值，不行</span><br><span class="line">	insert into test(name) values(&#x27;hello2&#x27;);//此时只能用第二种方式</span><br><span class="line">	但是如果是所有列都可以不填值，比如下面这张表</span><br><span class="line">	create table test1(id int not null auto_increment,name char(50) not null default &#x27;haha&#x27;,primary key(id))engine = InnoDB;</span><br><span class="line">	<span class="function">insert into test1 <span class="title">values</span><span class="params">()</span></span>;<span class="comment">//此时第一种方式写也可以</span></span><br><span class="line"></span><br><span class="line">	insert into grade_info(score_id,s_name,c_name,grade,s_id)  values(&#x27;202000008&#x27;,&#x27;test1&#x27;,&#x27;ios&#x27;,&#x27;74&#x27;,&#x27;12345678&#x27;);//这样的写法才是安全的，提供了列名，VALUES必须以其指定的次序匹配指定的列名，不一定按各个列出现在实际表中的次序。其优点是，即使表的结构改变，此INSERT语句仍然能正确工作。</span><br><span class="line">	</span><br><span class="line">	如果score_id设置为自增或者允许NULL还可以像下面这样，自增的那一列省略掉，&#x27;所以这个就是插入行的一部分&#x27;</span><br><span class="line">	insert into grade_info(s_name,c_name,grade,s_id)  values(&#x27;test1&#x27;,&#x27;ios&#x27;,&#x27;74&#x27;,&#x27;12345678&#x27;);</span><br><span class="line">	</span><br><span class="line">	插入行时指定列但是又省区了某些列，省去的列要满足以下要求：</span><br><span class="line">	❑ 该列定义为允许<span class="literal">NULL</span>值（<span class="literal">NULL</span>即无值或空值）。</span><br><span class="line">	❑ 在表定义中给出默认值(比如自增)。这表示如果不给出值，将使用默认值。如果对表中不允许<span class="literal">NULL</span>值且没有默认值的列不给出值，则MySQL将产生一条错误消息，并且相应的行插入不成功。</span><br><span class="line">	</span><br><span class="line">	数据库经常被多个客户访问，对处理什么请求以及用什么次序处理是MySQL的任务。INSERT操作可能很耗时（特别是有很多索引需要更新时），而且它可能降低等待处理的SELECT语句的性能。如果数据检索是最重要的（通常是这样），则你可以通过在INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL降低INSERT语句的优先级，insert low_priority into,这也适用于下一章介绍的UPDATE和DELETE语句。</span><br><span class="line">	</span><br><span class="line"><span class="comment">//3.插入多行</span></span><br><span class="line">	可以连着使用多条上面的插入单行的语句组合完成，也可以像下面这样,values后面接多组值，多组值用,隔开</span><br><span class="line">	<span class="function">insert into <span class="title">grade_info</span><span class="params">(s_name,c_name,grade,s_id)</span> </span></span><br><span class="line">	values(&#x27;test1&#x27;,&#x27;ios&#x27;,&#x27;74&#x27;,&#x27;12345678&#x27;)，</span><br><span class="line">	values(&#x27;test2&#x27;,&#x27;ios1&#x27;,&#x27;76&#x27;,&#x27;123456789&#x27;); //这个方式比连续使用多条快</span><br><span class="line">	</span><br><span class="line"><span class="comment">//4.insert与select语句结合</span></span><br><span class="line">	如下图所示，将表Aselect的结果插入到表B中.</span><br><span class="line">    INSERT SELECT中的列名:这个例子在INSERT和SELECT语句中使用了相同的列名。但是，不一定要求列名匹配。事实上，MySQL甚至不关心SELECT返回的列名。它使用的是列的位置，因此SELECT中的第一列（不管其列名）将用来填充表列中指定的第一个列，第二列将用来填充表列中指定的第二个列，如此等等。这对于从使用不同列名的表中导入数据是非常有用的。&#x27;他们抄的列的数量应该要是相同的&#x27;</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210130201755467.png" class>

<h1 id="20-更新与删除数据"><a href="#20-更新与删除数据" class="headerlink" title="20.更新与删除数据"></a>20.更新与删除数据</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.更新数据</span></span><br><span class="line">	<span class="number">1.</span>使用UPDATE语句，用两种方式使用UPDATE：❑ 更新表中特定行；❑ 更新表中所有行。</span><br><span class="line">	<span class="number">2.</span>使用update语句时不要省略WHERE子句,因为稍不注意，就会更新表中所有行。</span><br><span class="line">	<span class="number">3.</span>基本的UPDATE语句由<span class="number">3</span>部分组成，分别是：</span><br><span class="line">		❑ 要更新的表；</span><br><span class="line">		❑ 列名和它们的新值；</span><br><span class="line">		❑ 确定要更新行的过滤条件。</span><br><span class="line">	4.update grade_info set s_name = &#x27;test2&#x27; where s_id = &#x27;1&#x27; and grade = 86;//如果不用where选定行，他会更新所有行的s_name	</span><br><span class="line">     5.update grade_info set s_name = &#x27;test3&#x27;,c_name = &#x27;azhe&#x27; where s_id = &#x27;1&#x27; and grade = 86;//更新多列，用,隔开</span><br><span class="line">     <span class="number">6.U</span>PDATE语句中可以使用子查询，使得能用SELECT语句检索出的数据更新列数据。</span><br><span class="line">     <span class="number">7.</span>为了删除某个列的值，可设置它为<span class="literal">NULL</span>（假如表定义允许<span class="literal">NULL</span>值），如下面这个</span><br><span class="line">     	update grade_info <span class="built_in">set</span> grade = <span class="literal">NULL</span> where grade = <span class="number">82</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.删除数据</span></span><br><span class="line">	<span class="number">1.</span>使用DELETE语句删除行有两种方式：❑ 删除特定行；❑ 删除所有行。</span><br><span class="line">	<span class="number">2.</span><span class="keyword">delete</span>也不要省略where子句，除非你要删所有行。但是如果想从表中删除所有行，不要使用DELETE。可使用TRUNCATE TABLE语句，它完成相同的工作，但速度更快（TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据）。</span><br><span class="line">	<span class="number">3.</span>删除列使用update，<span class="keyword">delete</span>只能以行为单位删除</span><br><span class="line">	4.delete from grade_info where s_id = &#x27;12345678&#x27;;</span><br><span class="line">	<span class="number">5.</span>DELETE语句从表中删除行，甚至是删除表中所有行。但是，DELETE不删除表本身，删除表用drop。</span><br></pre></td></tr></table></figure>


<h1 id="21-创建和操纵表"><a href="#21-创建和操纵表" class="headerlink" title="21.创建和操纵表"></a>21.创建和操纵表</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建表，如下图</span></span><br><span class="line">	<span class="number">1.</span><span class="literal">NULL</span>值就是没有值或缺值。允许<span class="literal">NULL</span>值的列可以在插入行时不给出该列的值，那么插入行的这一列就是没有值，展示给用户为<span class="literal">NULL</span>。不允许<span class="literal">NULL</span>值的列在插入或更新行时，必须要明确给出该列的值。</span><br><span class="line">	<span class="number">2.</span><span class="literal">NULL</span>为默认设置，如果不指定NOT <span class="literal">NULL</span>，则默认指定的是<span class="literal">NULL</span>。</span><br><span class="line">	3.NULL和空串有区别的，空串比如&#x27;&#x27;，他表示有值，但是值为空串，所以not null可以有空串。而NULL是没有值</span><br><span class="line">	<span class="number">4.</span>主键是在最后给出，主键为多列时，可以在()中用,隔开</span><br><span class="line">	<span class="number">5.</span>AUTO_INCREMENT标识这一列是自增，也就是插入一行时，系统将这一列的值自增<span class="number">1</span>,并赋值到插入行中</span><br><span class="line">	<span class="number">6.</span>每个表只允许一个AUTO_INCREMENT列，而且它必须被索引（如，通过使它成为主键，可以通过主键索引快速定位到对应行）。</span><br><span class="line">	<span class="number">7.</span>如果一个列被指定为AUTO_INCREMENT，你在在INSERT语句中指定一个值，只要它是唯一的（至今尚未使用过），该值将被用来替代自动生成的值。后续的增量将在该手工插入的值基础上自增。</span><br><span class="line">	<span class="number">8.</span>可使用last_insert_id()函数获得某表最后一个AUTO_INCREMENT值</span><br><span class="line">	9.cust_city char(50) NOT NULL default &#x27;北京&#x27;, //给一列添加默认值，NOT NULL default和NULL default都可以。</span><br><span class="line">	假设我建立下面这张表</span><br><span class="line">	create table test1(id int not null auto_increment,name char(50) not null default &#x27;haha&#x27;,primary key(id))engine = InnoDB;</span><br><span class="line">	那么我<span class="function">insert into test1 <span class="title">values</span><span class="params">()</span></span>;就可以，因为两列一个<span class="keyword">auto</span> increment,一个有默认值，所以可以都不填</span><br><span class="line">	<span class="number">10.</span>不同的数据库引擎</span><br><span class="line">		❑ InnoDB是一个可靠的事务处理引擎，它不支持全文本搜索；</span><br><span class="line">		❑ MEMORY在功能等同于MyISAM，但由于数据存储在内存（不是磁盘）中，速度很快（特别适合于临时表）；</span><br><span class="line">		❑ MyISAM是一个性能极高的引擎，它支持全文本搜索（参见第<span class="number">18</span>章），但不支持事务处理。</span><br><span class="line">		外键不能跨引擎，即使用一个引擎的表的外键不能是不同引擎的表的主键。</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210130220923532.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.更新表</span></span><br><span class="line">	alter table test1 drop column name;<span class="comment">//给表删除列</span></span><br><span class="line">	alter table test1 add column age <span class="keyword">int</span>;<span class="comment">//给表添加列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.删除表</span></span><br><span class="line">	drop table test1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.更改表名</span></span><br><span class="line">	rename table test to test3;</span><br></pre></td></tr></table></figure>


<h1 id="22-使用视图"><a href="#22-使用视图" class="headerlink" title="22.使用视图"></a>22.使用视图</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.什么是视图？</span></span><br><span class="line">	首先我们考虑一个场景，如果你需要频繁的使用多张表联接之后的结果，比如频繁的select，那么每次select时要写的代码太多了，比较麻烦，此时我们想要一种类似于编程语言函数一样的东西，向外提供接口，可供我们多次调用。其实，视图就类似于一个向外提供接口的函数，这个函数将sql语句封装起来，可以供我们重复调用。————所以视图主要用来简化我们的查询操作的。</span><br><span class="line">	比如下图这个例子，每次先把表联结之后再筛选联接表这样的语句写起来很长很麻烦，我们可以把创建联接表的sql语句封装成一个函数————即视图。然后每次筛选这个视图就可以了。虽然视图只是对sql语句的封装，但是你可以直接在逻辑上把这个视图看成他封装的sql语句执行后的结果，即一张虚拟表。而且也可以把则个视图当作表来操作。</span><br><span class="line">	之所以称他为虚拟表，是因为他最后是他封装的sql语句执行后的结果，是经过计算的，并不是数据库实实在在的表，他是在数据库中存在的基本表的基础上创建的新关系(一个视图可以是一个或多个基本表计算后的结果)。</span><br><span class="line">	比如下下张图，我们把这个联接表的创建sql语句封装成一个名为productcustomers的视图，可以把这个视图当作一个虚拟表来直接使用。</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210201232725146.png" class>

<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210201235605157.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.视图的规则与限制</span></span><br><span class="line">	<span class="number">1.</span>视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。</span><br><span class="line">	<span class="number">2.</span>对于可以创建的视图数目没有限制。</span><br><span class="line">	<span class="number">3.</span>为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。</span><br><span class="line">	<span class="number">4.</span>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。(但是视图嵌套会降低查询效率)</span><br><span class="line">	<span class="number">5.</span>ORDER BY可以用在视图中，但如果从该视图检索数据的SELECT语句中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。</span><br><span class="line">	<span class="number">6.</span>视图不能索引，也不能有关联的触发器或默认值。</span><br><span class="line">	<span class="number">7.</span>视图可以和表一起使用。比如将视图的表联结到一起。</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.使用视图</span></span><br><span class="line">	<span class="number">1.</span>视图用CREATE VIEW语句来创建。如下图</span><br><span class="line">	<span class="number">2.</span>使用SHOW CREATE VIEW viewname；来查看创建视图的语句(即视图封装的SQL语句)。</span><br><span class="line">	<span class="number">3.</span>用DROP删除视图，其语法为DROP VIEW viewname;</span><br><span class="line">	<span class="number">4.</span>更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。如果要更新的视图不存在，则第<span class="number">2</span>条更新语句会创建一个视图；如果要更新的视图存在，则第<span class="number">2</span>条更新语句会替换原有视图。</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210202183859707.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4.使用视图的一些骚操作</span></span><br><span class="line">	视图搭配计算字段来控制格式化输出，如下图，将创建格式化输出的计算字段语句封装成一个视图，并且我们也在这里看到了取别名的另一个好处，就是可以在创建成视图之后在视图之外也可以直接使用。</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210202184608371.png" class>

<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210202200651178.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5.更新视图</span></span><br><span class="line">	视图是可以更新的，修改视图会导致最终其关联的基表的值也被改变(同理对基表的修改也会呈现到视图中来)。但是有些情况不能更新视图，情况很多，但是更新视图很少，更多还是用视图来检索数据，所以就不记了。</span><br></pre></td></tr></table></figure>
<h1 id="23-使用存储过程"><a href="#23-使用存储过程" class="headerlink" title="23.使用存储过程"></a>23.使用存储过程</h1><p>mysql命令行创建存储过程实例</p>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210202221606037.png" class>

<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210202221838964.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.什么是存储过程</span></span><br><span class="line">	当我们做非常复杂的查询时，需要很多条sql语句配合执行，每次键入就很麻烦，所以我们可以将多条sql语句封装成一个函数，以后使用时调用这个函数就可以了，这个函数就称为存储过程。和视图不同的一点就是视图是只用来辅助查询(至少我现在见到的都是这样的)或者说仅包含sql语句，但是存储过程之中可以有多种不同的sql语句以及各种不属于的sq语句的控制流语句。</span><br><span class="line">	</span><br><span class="line"><span class="comment">//2.使用存储过程</span></span><br><span class="line">	因为存储过程是一个函数，所有他和其他编程语言调用函数的方式是相同的。</span><br><span class="line">	<span class="function">call <span class="title">productpricing</span><span class="params">(@low,@high)</span> <span class="comment">//类似于调用函数，同时传递参数，这里相当于传入两个变量进去，函数会对这个变量赋值，但是这里low和high两个变量不需要事先创建，@low这个语句就相当于创建了一个名为low的变量并传入函数。注意就算这个存储过程没有参数，调用时也需要将括号带上，和一般语言的函数调用一样。</span></span></span><br><span class="line"><span class="function">	</span></span><br><span class="line"><span class="function"><span class="comment">//3.创建存储过程</span></span></span><br><span class="line">	如下图所示，begin和end指明了存储过程中包含的sql语句体。在上面的语句还指明了这个存储过程的名字和参数。</span><br><span class="line">	这个存储过程的调用就是<span class="function">call <span class="title">productpricing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span></span><br><span class="line">	还要注意的一点就是如果在mysql的命令行定义存储过程，因为mysql命令行这个程序会存储过程中定义的sql语句的;当成结束分隔符，会导致出现语法错误，所以在命令行定义时要特殊处理。</span><br><span class="line">	delimiter <span class="comment">// 这个delimiter是告诉命令行程序&quot;//&quot;是新的分隔符，当然分隔符可以随便定义，除了\符号</span></span><br><span class="line">	<span class="function">create procedure <span class="title">productpricing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	begin</span></span><br><span class="line"><span class="function">		select <span class="title">Avg</span><span class="params">(pro_price)</span> AS priceaverage from products</span>;</span><br><span class="line">	end <span class="comment">//  这里新定义的分隔符告诉命令行程序存储过程定义到这里结束，之前是使用;作为分隔符的</span></span><br><span class="line">	delimiter ;  这里是将分隔符重新定义为; 因为命令行输入到这里结束，按照惯例还是以;来结束分割</span><br><span class="line">	<span class="string">&quot;这个上面演示的代码不是全部输入在一行的，具体的例子看上面的黑框图，有两种方式&quot;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//4.删除存储过程</span></span><br><span class="line">	和所有的删除一样，drop+类型+存储过程名</span><br><span class="line">     drop procedure productpricing</span><br><span class="line">     注意存储过程和数据库中的表、视图等一样，不能覆盖，只能删了然后重建</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210202205306736.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5.使用参数</span></span><br><span class="line">	如下图所示，我们创建了一个带有参数的存储过程。</span><br><span class="line">    out p1 decimal(8,2)：out定义这个存储过程要传出的一个变量(返回给调用者的返回值)，将来在存储过程的sql语句中可以将select到的结果into到这个变量p1中(相当于在函数内部对返回值取的名字)————总之就是在用out定义了一个变量之后，函数内部就把这个变量名当作一个输出值来看，可以给它赋值。遵循这个参数定义，调用者将变量传进来，存储过程在这里面给它赋值。有点类似于c++的引用传递。decimal(8,2)是指这个结果是一个长度为8位的十进制数，其中小数部分长度为2位。</span><br><span class="line">    <span class="function">call <span class="title">productpricing</span><span class="params">(@low,@high,@avg)</span></span>;对下面定义的这个存储过程调用之后，如果想要使用这些变量可以</span><br><span class="line">    select @low,@high;来直接查看变量的值</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210202211520675.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">如下图，in相当于在函数内部定义了一个输入变量，在函数内部可以直接使用这个输入变量(注意看这个输入变量的类型和out变量类型不相同)。</span><br><span class="line">	比如我们调用函数可以写为<span class="function">call <span class="title">ordertotal</span><span class="params">(<span class="number">2005</span>,@total)</span></span>;</span><br><span class="line">	然后select @total;查看函数处理后的变量值</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210202212653010.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//6.智能存储过程</span></span><br><span class="line">	其实就是在sql语句的基础之上又加入了流程控制语句，如下图</span><br><span class="line">	<span class="number">1.</span>--是存储过程内注释的开头</span><br><span class="line">	<span class="number">2.B</span>OOLEAN就是<span class="keyword">bool</span>类型，非<span class="number">0</span>整数都被当作<span class="literal">true</span></span><br><span class="line">	<span class="number">3.</span>declare也是定义变量，不同于in out是在函数形参中定义的变量，函数体内定义变量就用declare</span><br><span class="line">	<span class="number">4.</span>函数名后面的comment也是注释一样东西，SHOW PROCEDURE STATUS可以看到(这个语句是查看存储过程的所有基本信息)</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.显示存储过程的定义语句</span></span><br><span class="line">     show create procedure ordertotal;<span class="comment">//和查看视图一个样的方式，主要是能看到存储过程的声明和定义体</span></span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210202214213980.png" class>

<h1 id="24-使用游标"><a href="#24-使用游标" class="headerlink" title="24.使用游标"></a>24.使用游标</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.什么是游标cursor</span></span><br><span class="line">	传统的sql语句在检索之后返回的是满足某一条件的结果集，也就是若干行的集合，存放在内存的某一位置。普通的sql语句无法再寻找这若干满足要求的结果集中具体某一行(如果想要操作具体某一行只能根据更多的条件来继续筛选)。这个时候就可以用游标了，他是sql语句返回的结果集(行集)，允许程序对结果集的每一行执行相同或不同的操作，而不是对整个行集合执行同一个操作。</span><br><span class="line">	特点：</span><br><span class="line">	<span class="number">1.</span>不敏感：数据库可以选择不复制结果集</span><br><span class="line">	<span class="number">2.</span>只读</span><br><span class="line">	<span class="number">3.</span>不滚动：游标只能向一方向前进，并且不可以跳过任何一行数据(即只能从第一行开始一行一行的向下寻找)   </span><br><span class="line">	游标的适用场景：</span><br><span class="line">	<span class="number">1.</span>存储过程</span><br><span class="line">	<span class="number">2.</span>函数</span><br><span class="line">	<span class="number">3.</span>触发器</span><br><span class="line">	<span class="number">4.</span>事件</span><br><span class="line">            </span><br><span class="line"><span class="comment">//2.使用游标</span></span><br><span class="line">	使用游标的顺序一般是:声明游标、打开游标、读取数据、关闭游标、删除游标。</span><br><span class="line">	几个注意点</span><br><span class="line">	<span class="number">1.</span>游标定义(声明)之后一定要打开游标来使用(即不能定义着却不用)，当然读取游标的数据之前也需要打开游标</span><br><span class="line">	<span class="number">2.</span>游标定义时其实还没有检索数据</span><br><span class="line">	<span class="number">3.</span>游标结束使用时一定要关闭</span><br><span class="line">	<span class="number">4.</span>mysql的游标只能定义在存储过程里面</span><br><span class="line">	<span class="number">5.</span>游标可以多次打开和关闭</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.创建游标</span></span><br><span class="line">	DECLARE cursor_name CURSOR FOR select_statement  <span class="comment">//在存储过程中除了可以用declare定义变量也可以用declare定义游标。例子如下图</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//4.打开游标</span></span><br><span class="line">	OPEN cursor_name;</span><br><span class="line">	比如OPEN ordernumbers; 打开游标时，会执行游标定义的select语句，并分配内存存放select语句返回的结果</span><br><span class="line">	</span><br><span class="line"><span class="comment">//5.关闭游标</span></span><br><span class="line">	OPEN cursor_name;</span><br><span class="line">	注意如果不主动关闭游标，也会在存储过程的end时系统自动隐含关闭游标，释放游标所占的资源。</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210202225529121.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//6.读取数据</span></span><br><span class="line">	FETCH cursor_name INTO var_name1,var_name2,...;<span class="comment">//从第一行开始读取游标中的行，并写入var_name1,var_name2...中(如果游标中的行有多列)，读完之后游标中的指针指向结果集的下一行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">游标举例</span><br><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> id <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">declare</span> name <span class="type">varchar</span>(<span class="number">100</span>) <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line">    <span class="keyword">declare</span> done <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">-- 声明游标</span></span><br><span class="line">    <span class="keyword">declare</span> mc <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> stuId,stuName <span class="keyword">from</span> student <span class="keyword">where</span> stuAge <span class="operator">&gt;</span><span class="number">19</span>;</span><br><span class="line">    <span class="keyword">declare</span> continue handler <span class="keyword">for</span> <span class="keyword">not</span> found <span class="keyword">set</span> done <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">-- 打开游标</span></span><br><span class="line">    <span class="keyword">open</span> mc;</span><br><span class="line">    <span class="comment">-- 获取结果</span></span><br><span class="line">    <span class="keyword">fetch</span> mc <span class="keyword">into</span> id,name; <span class="comment">--读取第一行的数据到变量中</span></span><br><span class="line">    <span class="comment">-- 这里是为了显示获取结果</span></span><br><span class="line">    <span class="keyword">select</span> id,name;</span><br><span class="line">    <span class="comment">-- 关闭游标</span></span><br><span class="line">    <span class="keyword">close</span> mc;</span><br><span class="line"><span class="keyword">end</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>
<p>更多的例子看 <a href="https://www.cnblogs.com/oukele/p/10684639.html">https://www.cnblogs.com/oukele/p/10684639.html</a></p>
<h1 id="25-使用触发器"><a href="#25-使用触发器" class="headerlink" title="25.使用触发器"></a>25.使用触发器</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.什么是触发器</span></span><br><span class="line">	<span class="number">1.</span>如果你想要某条SQL语句（或某些语句————比如存储过程）在事件发生时自动执行。比如每当订购一个产品时，都从库存数量中减去订购的数量；此时就需要使用触发器</span><br><span class="line">	<span class="number">2.</span>触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句</span><br><span class="line">	DELETE INSERT；UPDATE。其他MySQL语句不支持触发器。</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建触发器</span></span><br><span class="line">	创建触发器时要给出<span class="number">4</span>点信息：</span><br><span class="line">	<span class="number">1.</span>唯一的触发器名(最好在全数据库范围内使用唯一的触发器名)；</span><br><span class="line">	<span class="number">2.</span>触发器关联的表；</span><br><span class="line">	<span class="number">3.</span>触发器应该响应的活动（DELETE、INSERT或UPDATE）；</span><br><span class="line">	<span class="number">4.</span>触发器何时执行（处理之前或之后————after <span class="keyword">or</span> before）</span><br><span class="line">        </span><br><span class="line">	例子如下:创建一个名为newproduct的触发器，在对products表执行insert事件之后触发，触发器对应的sql语句是select &#x27;Product added&#x27;,即打印一条语句。for each row就说明对每个插入的行都会触发这个触发器</span><br><span class="line">	</span><br><span class="line">	只有表才支持触发器，视图不支持（临时表也不支持）。</span><br><span class="line">     </span><br><span class="line">     创建一个触发器，只能关联一个表(不能和多个表关联)的一个事件，但是after <span class="keyword">delete</span>和before <span class="keyword">delete</span>相当于两个事件,所以每个表最多支持<span class="number">6</span>个触发器（每条INSERT、UPDATE和DELETE的之前和之后）。如果你需要一个对INSERT和UPDATE操作执行的触发器，则应该定义两个触发器.</span><br><span class="line">     </span><br><span class="line">     如果BEFORE触发器失败，则MySQL将不执行请求的操作(触发器包含的sql语句)。此外，如果BEFORE触发器或语句本身失败，MySQL将不执行AFTER触发器（如果有的话）。</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210204182529402.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.删除触发器</span></span><br><span class="line">	drop trigger newproduct;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//4.使用触发器</span></span><br><span class="line">	关于before和update注意的一点：当你要对某个表要执行某个操作(uodate <span class="keyword">delete</span> insert)，操作执行前DBMS就知道了，也就是DBMS确切知道了将要对这个表执行这个操作。然后他才会在执行这个操作之前触发before触发器(如果有)，在执行这个操作之后触发after触发器。如果压根没有发出相应的操作，before触发器也是不会被触发的(否则他不是一直被触发吗)。</span><br><span class="line">	关于NEW和OLD的注意点：NEW是你insert语句中携带的行数据，OLD是你要更新(更新前)或删除的行的数据。</span><br><span class="line"></span><br><span class="line">	<span class="number">1.</span>insert触发器：</span><br><span class="line">	❑ 在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行；</span><br><span class="line">	❑ 在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值）；</span><br><span class="line">	❑ 对于AUTO_INCREMENT列，NEW在INSERT执行之前包含<span class="number">0</span>，在INSERT执行之后包含新的自动生成值。</span><br><span class="line">	例子如下面第一张图，NEW这个虚表就代表被插入的行，所以这个触发器包含的语句就是选出被插入行的order_num列 </span><br><span class="line">	通常，将BEFORE用于数据验证插入行之前验证数据（目的是保证插入表中的数据确实是需要的数据）。</span><br><span class="line">	</span><br><span class="line">	<span class="number">2.</span><span class="keyword">delete</span>触发器</span><br><span class="line">	❑ 在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表(和NEW类似)，访问被删除的行；</span><br><span class="line">	❑ OLD中的值全都是只读的，不能更新。</span><br><span class="line">	OLD就代表要被删除的行，所以OLD.order_num就是被删除行的对应列，表中任意行被删除前都要执行这个存储过程</span><br><span class="line">	</span><br><span class="line">	<span class="number">3.u</span>pdate触发器</span><br><span class="line">	❑ 在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值；</span><br><span class="line">	❑ 在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）；</span><br><span class="line">	❑ OLD中的值全都是只读的，不能更新。</span><br><span class="line">	下面的例子保证州名缩写总是大写（不管UPDATE语句中给出的是大写还是小写）;</span><br><span class="line">	具体的含义就是，若你将来会对vendors表执行一条update语句，那么在DBMS收到请求之后、执行这个语句之前，会触发before update触发器，这个触发器会将要插入的数据中的vend_state设置为大写，也就是直接修改了待插入的数据，然后再插入。</span><br></pre></td></tr></table></figure>
<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210204184412987.png" class>

<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210204185007312.png" class>

<img src="/2021/01/28/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210204185836887.png" class>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题型总结</title>
    <url>/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>​        目前刷到的双指针题目主要有三种</p>
<ol>
<li>夹逼型：左右指针初始时分别指向左端点和右端点，然后根据某种条件向中间夹，<strong>一般这种情况要求数组有序(无序比如翻转数组)</strong></li>
<li>双指针维护滑动窗口类型：即指针p逐个向后遍历，指针q要按某种条件移动，指针(q,p)就维护了一个区间，这个区间会不断移动，也叫做滑动窗口。这个窗口不一定是有固定长度的，具体要看题目的条件。<strong>1.滑动窗口的条件可以用循环不变式来约束，即用集合的思想来思考 2.滑动窗口内必须是连续的(求解的问题必须是连续的)，如果结果可能非连续(比如求最长子序列)，无法用滑动窗口</strong></li>
<li>两个指针指向不同的数组：两个指针指向不同的数组，按照某种条件移动两个指针。这个指针初始化时不一定要指针两个数组的开头，也可以指向两个数组的末尾。<strong>常常用来合并数组或者链表</strong></li>
<li>链表题的快慢指针。141 142两题。</li>
</ol>
<a id="more"></a>

<h2 id="夹逼型"><a href="#夹逼型" class="headerlink" title="夹逼型"></a>夹逼型</h2><h3 id="167-两数之和"><a href="#167-两数之和" class="headerlink" title="167:两数之和"></a>167:两数之和</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数，返回这两个数的下标。</span><br><span class="line">输入: numbers = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释: <span class="number">2</span> 与 <span class="number">7</span> 之和等于目标数 <span class="number">9</span> 。因此 index1 = <span class="number">1</span>, index2 = <span class="number">2</span> 。</span><br></pre></td></tr></table></figure>
<p>有序，自然是左右端点夹逼型</p>
<h3 id="633-平方数之和"><a href="#633-平方数之和" class="headerlink" title="633:平方数之和"></a>633:平方数之和</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c 。</span><br><span class="line">实例:</span><br><span class="line">输入：c = <span class="number">5</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="number">1</span> * <span class="number">1</span> + <span class="number">2</span> * <span class="number">2</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>有序，又是找两个满足某条件的点，自然双指针。这里为了不超时，可以让右指针从sqrt(x)开始。</li>
</ul>
<h3 id="345-反转元音字符"><a href="#345-反转元音字符" class="headerlink" title="345.反转元音字符"></a>345.反转元音字符</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;hello&quot;</span></span><br><span class="line">输出：<span class="string">&quot;holle&quot;</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入：<span class="string">&quot;leetcode&quot;</span></span><br><span class="line">输出：<span class="string">&quot;leotcede&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>双指针翻转字符</li>
</ul>
<h3 id="680-验证回文串"><a href="#680-验证回文串" class="headerlink" title="680.验证回文串"></a>680.验证回文串</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: <span class="string">&quot;aba&quot;</span></span><br><span class="line">输出: True</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: <span class="string">&quot;abca&quot;</span></span><br><span class="line">输出: True</span><br><span class="line">解释: 你可以删除c字符。</span><br></pre></td></tr></table></figure>
<p>判断回文串自然是夹逼型双指针，重点是我们夹逼到发现两个字符不相等时如何处理，由于只能删除一个，自然可以删除左边也可以删除右边，我们再去测试一下删除字符之后的部分串是否为回文串。所以我们两边都要试一下，有一个是就直接返回。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != s[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i++,j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != s[j])&#123;</span><br><span class="line">                <span class="comment">//两边都试一下</span></span><br><span class="line">                <span class="keyword">if</span>(test(s.substr(i+<span class="number">1</span>,j - i))) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(test(s.substr(i,j - i))) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++,j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="指针指向不同数组型"><a href="#指针指向不同数组型" class="headerlink" title="指针指向不同数组型"></a>指针指向不同数组型</h2><h3 id="88-归并两个有序数组"><a href="#88-归并两个有序数组" class="headerlink" title="88.归并两个有序数组"></a>88.归并两个有序数组</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</span><br><span class="line">说明：</span><br><span class="line">初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。</span><br><span class="line">你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span></span><br><span class="line">nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>],       n = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>指针分别指向两个数组的尾部，按照规则放入nums1数组。<strong>这就是双指针不一定非要放头部的反例，提一嘴，这个合并复杂度是o(m+n)</strong></li>
</ul>
<h3 id="524-通过删除字母匹配到字典里最长单词"><a href="#524-通过删除字母匹配到字典里最长单词" class="headerlink" title="524.通过删除字母匹配到字典里最长单词"></a>524.通过删除字母匹配到字典里最长单词</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s = <span class="string">&quot;abpcplea&quot;</span>, d = [<span class="string">&quot;ale&quot;</span>,<span class="string">&quot;apple&quot;</span>,<span class="string">&quot;monkey&quot;</span>,<span class="string">&quot;plea&quot;</span>]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line"><span class="string">&quot;apple&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>本质上是看能否在串s中找到一个在字典中出现过的子序列串，如果找到且有多个。就会返回最长，如果相等，就返回字典序小的那个</strong></p>
<p>野的方法就是找到串s的所有子序列，然后看他们是否在d中出现，加入一个集合后再筛选。这是从s找到符合d的东西。但是我们可以逆向思维，我们依次遍历d中的串，看他是否是s的子序列，这里判断是否为子序列我们就可以使用第二种类型的双指针了，这里是两个指针分别指向两个字符串的开头。</p>
<p><strong>为了优化，我们可以事先将d排序，按照先长度后字典序的方式排序，那样字典按需遍历时，找到的第一个符合条件的一定就是最终结果</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">com</span><span class="params">(<span class="built_in">string</span>&amp; s1,<span class="built_in">string</span>&amp; s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.size() != s2.size()) <span class="keyword">return</span> s1.size() &gt; s2.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s1.size() &amp;&amp; s1[i] == s2[i]) i++;</span><br><span class="line">        <span class="keyword">return</span> s1[i] &lt; s2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">findLongestWord</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">        sort(d.begin(),d.end(),com);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; d.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> s_cur = <span class="number">0</span>,d_cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(d_cur &lt; d[i].size() &amp;&amp; s_cur &lt; s.size())&#123;</span><br><span class="line">                <span class="keyword">if</span>(d[i][d_cur] == s[s_cur]) s_cur++,d_cur++;</span><br><span class="line">                <span class="keyword">else</span> s_cur++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(d_cur == d[i].size()) <span class="keyword">return</span> d[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h3><h2 id="滑动窗口型"><a href="#滑动窗口型" class="headerlink" title="滑动窗口型"></a>滑动窗口型</h2><h3 id="3-没有重复字符的字长子串"><a href="#3-没有重复字符的字长子串" class="headerlink" title="3.没有重复字符的字长子串"></a>3.没有重复字符的字长子串</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个字符串，请你找出其中不含有重复字符的 最长子串 的<span class="string">&quot;长度&quot;</span>。</span><br><span class="line">输入: s = <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">&quot;bbbbb&quot;</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;b&quot;</span>，所以其长度为 <span class="number">1</span>。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这里我们可以用双指针维护一个滑动窗口，滑动窗口内的字符必然要满足一个条件，我们在移动这个遍历用的指针遍历到新的元素时，必然要考虑到他对这个滑动窗口的影响，也就是对这个集合的影响，是新元素加入窗口、窗口扩大还是剔除窗口左端元素(<strong>剔除元素是为了维护窗口内的性质和我们的预期一致</strong>)，移动窗口(<strong>可以看到移动窗口其实就是对窗口左端点指针移动</strong>)，<strong>此时就可以用到集合论的思想，即循环不变式</strong></p>
</li>
<li><p>先定义好我们的窗口中的元素(集合)满足的条件：显然是集合中无重复元素，<strong>所以循环不变式(集合元素满足的条件)就是窗口中无重复元素</strong>。那么我们要使用一种方式记录这个窗口中是否有元素重复，此时我们想到了哈希表，以元素值为key，value标识这个元素出现的次数。<strong>当我们遍历用的指针i移动到下一个元素时，将这个元素加入窗口，对应的元素值++，如果发现加了之后hash[i] &gt; 1，说明这个窗口中有和新加入的这个元素一样的元素，我们就要移动窗口的左端点指针j，每移动一个将对应的hash值–，直到hash[i] == 1。在此过程中用窗口大小更新结果。</strong></p>
</li>
</ul>
<h3 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904.水果成篮"></a>904.水果成篮</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入一个数组Tree,数组的编号代表不同的树，Tree[i]的值表示第i棵树上结的水果。问你从任意一棵树开始，自左向右用两个体积无限大的篮子接水果，并且每个篮子只能放一种水果，最后返回你能采摘的水果数的最大数量。</span><br><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：我们可以收集 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]。</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>这题其实和上面那题一样，就是维护一个滑动窗口，使滑动窗口内只含有两种类型的水果，抽象出来就是让滑动窗口内只包含两种数，并最后求这个滑动窗口最长时的长度</strong></p>
</li>
<li><p>为了维护这个循环不变式，我们可以用哈希表来窗口内水果类型的个数和对应的每种类型水果的个数。自然我们就是要让这个哈希表的元素不超过2个。i移动时，加入一个新的元素使哈希表元素大于两个，我们就要移动j，使这个滑动窗口内完全丢掉一种水果(无论是哪种)，所以此时我们可以根据hash[j]的值是否为0来判断某种水果是否全没了。哪个先没了，把哪种水果从哈希表丢掉。</p>
</li>
</ul>
<h3 id="76-最小覆盖串"><a href="#76-最小覆盖串" class="headerlink" title="76.最小覆盖串"></a>76.最小覆盖串</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 <span class="string">&quot;&quot;</span> 。</span><br><span class="line"></span><br><span class="line">注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。</span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;ADOBECODEBANC&quot;</span>, t = <span class="string">&quot;ABC&quot;</span></span><br><span class="line">输出：<span class="string">&quot;BANC&quot;</span></span><br></pre></td></tr></table></figure>
<p>**这题也是滑动窗口，这个窗口的性质也即满足的条件是窗口内包含串t的所有字符，不需要顺序。所以我们要记录窗口内有效串的个数，来了一个新元素之后看是否会对我这个窗口有影响 如果当前窗口不包含t的所有字符，来了一个新的之后判断是否能让这个窗口包含t所有字符，如果能，我们想让窗口尽可能小点，移动窗口左端点，移动左端点的终止条件就是窗口内不包含t中的所有字符了。由于最后是要返回串，所以我们要记录最小满足条件的串的左端点和这个串的长度 **</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="comment">//记录t串出现的字符和出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; t.size();i++)&#123;</span><br><span class="line">            mp[t[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//窗口内有t有效字符的个数、最小子串的左边界、最小字串的长度</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>,min_l = <span class="number">0</span>,min_size = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;r &lt; s.size();r++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.count(s[r]))&#123;</span><br><span class="line">                <span class="comment">//有效字符个数只有mp[s[r]] &gt; 0时才算,去除重复字符的影响</span></span><br><span class="line">                <span class="keyword">if</span>(mp[s[r]] &gt; <span class="number">0</span>) cnt++;</span><br><span class="line">                mp[s[r]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获得了以r为右端点且包含t全部有效字符的最短子串</span></span><br><span class="line">            <span class="keyword">while</span>(cnt == t.size())&#123;</span><br><span class="line">                <span class="keyword">if</span>(mp.count(s[l]))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(++mp[s[l]] &gt; <span class="number">0</span>) cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(r - l + <span class="number">1</span> &lt; min_size)&#123;</span><br><span class="line">                    min_l = l;</span><br><span class="line">                    min_size = r - l + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_size == INT_MAX ? <span class="string">&quot;&quot;</span> : s.substr(min_l,min_size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><p>​        整数二分就主要使用acwing的模板就可以了，即自左向右找到第一个满足条件的点，自右向左找到第一个满足条件的点。小数二分比较简单。<strong>目前尚未总结出题型</strong></p>
<p>​        <strong>注意二分不一定要求数组有序，只要你能找到一次能排除一般元素的排他性条件就可以了。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左边第一个大于等于x的点，最后一定会停止，但是可能最后结果在逻辑上不满足条件</span></span><br><span class="line"><span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">	<span class="keyword">int</span> mid = i + j &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(arr[mid] &gt;= x) r = mid;</span><br><span class="line">	<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从右开始第一个小于等于x的点</span></span><br><span class="line"><span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">	<span class="keyword">int</span> mid = i + j + <span class="number">1</span>&gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(arr[mid] &lt;= x) l = mid;</span><br><span class="line">	<span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="整数二分模板题"><a href="#整数二分模板题" class="headerlink" title="整数二分模板题"></a>整数二分模板题</h2><h3 id="69-求平方根"><a href="#69-求平方根" class="headerlink" title="69.求平方根"></a>69.求平方根</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">计算并返回 x 的平方根，其中 x 是非负整数。</span><br><span class="line">由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</span><br><span class="line">输入: <span class="number">4</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">输入: <span class="number">8</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">说明: <span class="number">8</span> 的平方根是 <span class="number">2.82842</span>..., </span><br><span class="line">     由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure>
<ul>
<li>根据题意就是找到自左到右的第一个t，使t^2 &lt;= x；所以我们使用第一个模板，条件就是mid^2 &lt;= x</li>
</ul>
<h3 id="43-区间查找"><a href="#43-区间查找" class="headerlink" title="43.区间查找"></a>43.区间查找</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</span><br><span class="line"></span><br><span class="line">如果数组中不存在目标值 target，返回 [<span class="number">-1</span>, <span class="number">-1</span>]。</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">8</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">输入：nums = [], target = <span class="number">0</span></span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>模板题直接套，即找到第一个小于等于target的位置，如果这个位置的值不等于target，说明数组中没这个元素，直接结束。</li>
</ul>
<h3 id="81-搜索旋转数组"><a href="#81-搜索旋转数组" class="headerlink" title="81.搜索旋转数组"></a>81.搜索旋转数组</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">假设按照升序排序的数组在预先未知的某个点上进行了旋转。</span><br><span class="line">( 例如，数组 [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>] 可能变为 [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>] )。</span><br><span class="line">编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span>。</span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: nums = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">0</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: nums = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">3</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>这题我们可以采用查找分界点，也就是旋转点，然后根据分界点和target的大小关系选择到分界点的左端还是右端查找。如果旋转了，分界点的特点一定是第一个小于nums[0]的点。但是这题因为有重复元素，所以预处理去重。我们删去数组右端的点，直到右端的点小于nums[0]，接下来就可以二分查找第一个小于nums[0]的分界点了。</strong></li>
</ul>
<h3 id="540-有序数组的单一元素"><a href="#540-有序数组的单一元素" class="headerlink" title="540.有序数组的单一元素"></a>540.有序数组的单一元素</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。</span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">8</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>这一题可以用位运算(亦或)来做，但是也可以二分来做。我们找到的二分条件就是如果arr[mid] == arr[mid + 1],那么如果mid处包括之前没有那个只出现一次的元素，这个mid一定是偶数。否则这个只出现一次的数一定出现在mid右边。同理分析</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r)&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//注意边界条件</span></span><br><span class="line">            <span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= r &amp;&amp; nums[mid] == nums[mid+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!(mid % <span class="number">2</span>)) l =  mid + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mid - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[mid] == nums[mid - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(mid % <span class="number">2</span>) l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> nums[mid]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>​        目前还没有总结出动态规划的套路，记录一下到目前为止的一些思考</p>
<p>​        看了知乎的帖子之后【<a href="https://www.zhihu.com/question/291280715/answer/1570410869%E3%80%91%EF%BC%8C%E6%88%91%E6%98%8E%E7%99%BD%E4%BA%86DP%E7%9A%84%E5%81%9A%E9%A2%98%E4%B8%89%E9%83%A8%E6%9B%B2%EF%BC%9A">https://www.zhihu.com/question/291280715/answer/1570410869】，我明白了DP的做题三部曲：</a></p>
<ol>
<li>定义好状态，即创建一个多维数组，明确数组中每一个值的意义</li>
<li>确定好某些状态的初始值，即初始化数组中某些元素的值</li>
<li>确定转移方程，这个也是最难的一步，目前为止我觉得主要靠经验</li>
</ol>
<h2 id="知乎帖子总结"><a href="#知乎帖子总结" class="headerlink" title="知乎帖子总结"></a>知乎帖子总结</h2><h3 id="青蛙跳台阶"><a href="#青蛙跳台阶" class="headerlink" title="青蛙跳台阶"></a>青蛙跳台阶</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一维DP</span></span><br><span class="line"><span class="number">1.</span>dp[i]表示跳到第i层台阶的总次数</span><br><span class="line"><span class="number">2.</span>dp[<span class="number">0</span>] = <span class="number">0</span>,dp[<span class="number">1</span>] = <span class="number">1</span>,dp[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line"><span class="number">3.</span>dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</span><br><span class="line"></span><br><span class="line">机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</span><br><span class="line"></span><br><span class="line">问总共有多少条不同的路径？</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二维DP</span></span><br><span class="line"><span class="number">1.</span>dp[i][j]:到[i,j]这个位置可以有的路径数(i &gt;= <span class="number">0</span>,j &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="number">2.</span>dp[<span class="number">0</span>][<span class="number">1.</span>..m]都是<span class="number">1</span>，因为只能从左向右一条路走，dp[<span class="number">1.</span>..n][<span class="number">0</span>]都是<span class="number">1</span>，只能向下走，一个道理</span><br><span class="line"><span class="number">3.</span>dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64.最小路径和"></a>64.最小路径和</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</span><br><span class="line"></span><br><span class="line">说明：每次只能向下或者向右移动一步。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思路和上面一题一样，任意(i,j)这个点都只能从(i-1,j)和(i,j-1)来，所以我们只要取这两个之中的最小值即可</span></span><br><span class="line"><span class="number">1.</span>dp[i][j]:从(<span class="number">0</span>,<span class="number">0</span>)到(i,j)所有路径中路径之和最小的值</span><br><span class="line"><span class="number">2.</span>第<span class="number">0</span>行和第<span class="number">0</span>列的值都需要初始化</span><br><span class="line"><span class="number">3.</span>从(<span class="number">1</span>,<span class="number">1</span>)开始，dp[i][j] = min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]) + grid[i][j]</span><br></pre></td></tr></table></figure>
<h3 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72.编辑距离"></a>72.编辑距离</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</span><br><span class="line"></span><br><span class="line">你可以对一个单词进行如下三种操作：</span><br><span class="line"></span><br><span class="line">插入一个字符</span><br><span class="line">删除一个字符</span><br><span class="line">替换一个字符</span><br><span class="line"></span><br><span class="line">输入：word1 = <span class="string">&quot;horse&quot;</span>, word2 = <span class="string">&quot;ros&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 <span class="string">&#x27;h&#x27;</span> 替换为 <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">rorse -&gt; rose (删除 <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">rose -&gt; ros (删除 <span class="string">&#x27;e&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>这一题的转移方程和1143的LCS的思考方式特别像，两题一起看</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>dp[i][j]:word1的前i个字符组成的子串转换成word2的前j个字符的子串所要的最少操作次数</span><br><span class="line"><span class="number">2.</span>dp[<span class="number">0</span>][<span class="number">0.</span>..word2.size() - <span class="number">1</span>]都是当前遍历到的word2的子串的长度(一个长度为<span class="number">0</span>，转过去自然是另一个串的长度),dp[<span class="number">0.</span>..word1.size() - <span class="number">1</span>][<span class="number">0</span>]都是当前遍历到的word2的子串的长度</span><br><span class="line"><span class="number">3.</span>对于dp[i][j],如果word1[i] == word2[j],不用转了,那么dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">如果不等，那我们可以<span class="number">1.</span>删除word1的第i个位置，就是在dp[i<span class="number">-1</span>][j]的基础上又操作了一次;<span class="number">2.</span>删除word2的第j个位置，就是在dp[i][j<span class="number">-1</span>]的基础上又操作了一次 <span class="number">3.</span>将word1的i或者word2的j替换成和对方一样的(或者让其中某一个插入对方的字符)，就是在dp[i<span class="number">-1</span>][j<span class="number">-1</span>]的基础上又操作了一次。<span class="string">&quot;这三种情况都可以，所以我们自然要取其最小值&quot;</span>。</span><br><span class="line">所以此时dp[i][j] = min(min(dp[i<span class="number">-1</span>][j]+<span class="number">1</span>,dp[i][j<span class="number">-1</span>]+<span class="number">1</span>),dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="侯卫东"><a href="#侯卫东" class="headerlink" title="侯卫东"></a>侯卫东</h2><img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201212095101559.png" class>

<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201212095239839.png" class>

<img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201212095325250.png" class>

<img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201212095425147.png" class>

<p><strong>想转移方程时要考虑最后一步也就是考虑最后问题的解，假设他是最优解，那么最后规模的上一个规模的解也一定是最优解，可以用反证法证明。</strong></p>
<img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201212095728382.png" class>

<p><strong>这样我们就把原问题的接转换成了求规模更小的子问题的，更精确的说是当且问题的解可以在规模更小的子问题的解的基础上操作得到——想出这个操作就是转移方程(怎么由子问题解推出当前问题的解)。当然当前问题可能由多个子问题的解比较取优得到，不一定是只由一个子问题得到</strong></p>
<img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201212100118034.png" class>

<p><strong>由多个子问题的最优解比较得到当前问题最优解，这个过程就是转移方程</strong></p>
<img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201212100316975.png" class>

<img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201212104954598.png" class>

<p><strong>接下来就是考虑DP数组初始值和边界情况，比如数组越界时怎么处理。比如这里f(0)就是初始，用0个硬币就可以拼出</strong></p>
<img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201212105321719.png" class>

<p><strong>最后是考虑计算顺序，大部分是自左到右，当然还是要看你退出来的数之间的依赖关系</strong></p>
<h3 id="322-零钱兑换-其实也是背包问题"><a href="#322-零钱兑换-其实也是背包问题" class="headerlink" title="322.零钱兑换(其实也是背包问题)"></a>322.零钱兑换(其实也是背包问题)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line">你可以认为每种硬币的数量是无限的。</span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></span><br><span class="line">输出：<span class="number">3</span> </span><br><span class="line">解释：<span class="number">11</span> = <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：coins = [<span class="number">2</span>], amount = <span class="number">3</span></span><br><span class="line">输出：<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主要说一下这里初始值和处理边界值的方式，如果某个数量无法用基本硬币组成，也就是数组越界，我们用无穷大表示他，为了方便处理，把除0以外的其他位置都设置成无穷大。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>,<span class="number">0x3f3f3f3f</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        sort(coins.begin(),coins.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= amount;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; coins.size();j++)&#123;</span><br><span class="line">                <span class="comment">//如果没有越界，则如何处理</span></span><br><span class="line">                <span class="keyword">if</span>(i - coins[j] &gt;= <span class="number">0</span>) dp[i] = min(dp[i - coins[j]] + <span class="number">1</span>,dp[i]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[amount] &lt; <span class="number">0x3f3f3f</span>)  <span class="keyword">return</span> dp[amount];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="我的一些感悟"><a href="#我的一些感悟" class="headerlink" title="我的一些感悟"></a>我的一些感悟</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">在<span class="number">01</span>背包中，我们把状态f[i,j]称为一个选法集合。我们在思考转移方程时就要考虑当前这个状态可能会由哪些子问题转过来，当我们知道可能会由哪些子问题转过来之后，只需要在这些问题中取最大或最小值就可以了。</span><br><span class="line">一般在求f[i,j]时，多半是从f[i<span class="number">-1</span>]过来的，所以我们就可以知道要么是在前i<span class="number">-1</span>个问题选满了j个，第i个放不下， 要么就是前i<span class="number">-1</span>选满了，但是还能放下第i个元素，所以只会由f[i<span class="number">-1</span>,j]和f[i<span class="number">-1</span>,j-v[i]]过来</span><br><span class="line">在矩阵联城法中，f[i,j]表示(i,j)这个连乘所有的乘的方式的集合，但是最终都会化为两个矩阵相乘，所以我们只需要考虑(j - i + <span class="number">1</span>)所有连乘链组成的所有可能的两个矩阵就可以了。</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>上面的意思就是明确状态表示哪些集合，然后集合可以按照什么样的条件划分为若干类，这个就是做题经验了。每一小类的计算一般会用到子问题的解</strong></li>
</ul>
<h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h2><h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a>198.打家劫舍</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</span><br><span class="line"></span><br><span class="line">给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">1</span>) ，然后偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">3</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br><span class="line"><span class="comment">//相邻房子不能偷能偷到的最大价值</span></span><br></pre></td></tr></table></figure>
<img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201220144258139.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种状态的定义方式。</span></span><br><span class="line">偷第i个时，第i<span class="number">-1</span>个不能偷。而dp[i<span class="number">-1</span>]是包括偷第i<span class="number">-1</span>个的，所以我们只能在i<span class="number">-1</span>的基础上偷</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size() + <span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>];<span class="comment">//防止边界问题，从第2个开始算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nums.size();i++)&#123;</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-2</span>]+nums[i<span class="number">-1</span>],dp[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用股票那一题的状态定义方式</span></span><br><span class="line">dp[i][<span class="number">0</span>]:第i个不偷情况下的最大值</span><br><span class="line">dp[i][<span class="number">1</span>]:第i个偷情况下的最大值</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(nums.size() + <span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= nums.size();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(dp[nums.size()][<span class="number">0</span>],dp[nums.size()][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="213-打家劫舍Ⅱ"><a href="#213-打家劫舍Ⅱ" class="headerlink" title="213.打家劫舍Ⅱ"></a>213.打家劫舍Ⅱ</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</span><br><span class="line">给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。</span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：你不能先偷窃 <span class="number">1</span> 号房屋（金额 = <span class="number">2</span>），然后偷窃 <span class="number">3</span> 号房屋（金额 = <span class="number">2</span>）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//和上一题相比，这一题就是多了环形数组这个条件。怎么解决呢？我们发现如果偷了第一个，那么最后一个一定没法偷。同理偷最后一个第一个一定没法偷。</span></span><br><span class="line">所以根据这一互斥条件，讲原数组分为两个队列，一个包含<span class="number">1.</span>..n<span class="number">-1</span>这n<span class="number">-1</span>个元素(即可能偷第一个)，一个包含<span class="number">2.</span>..n这n<span class="number">-1</span>个元素(即不会偷第一个)。</span><br><span class="line"><span class="comment">//第一组可能偷第一个，也就是有可能不偷第一个。那么假设在第一组中，最大值的组合是不偷第一个，最后一个偷的是n-2,那么你是不是会想，此时在第一组要是可以偷第n个，这样价值会更大，而且满足了1 n互斥的关系。其实如果存在描述的这种情况他会在第二组中被检查到，我们函数的功能就是找到某个区域偷盗的最大值。而上面描述的那种情况如果存在，他肯定比第一组最大值大，但是他所扫描的区域实际上是2...n，这是一定会在第二组被找到的。所以这种做法是没问题的。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//创建两个DP数组，一个是偷第一个，一个不偷第一个</span></span><br><span class="line">        vector&lt;int&gt; dp1(nums.size()+1,0),dp2 = dp1;</span><br><span class="line">        <span class="comment">//dp1是一定偷第一个(则一定不会偷最后一个)，dp2是不偷第一个</span></span><br><span class="line">        dp1[<span class="number">1</span>] = nums[<span class="number">0</span>],dp2[<span class="number">2</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; nums.size();i++)&#123;</span><br><span class="line">            dp1[i] = max(dp1[i<span class="number">-1</span>],dp1[i<span class="number">-2</span>]+nums[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= nums.size();i++) dp2[i] = max(dp2[i<span class="number">-1</span>],dp2[i<span class="number">-2</span>]+nums[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">return</span> max(dp1[nums.size()<span class="number">-1</span>],dp2[nums.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空间优化版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        vector&lt;int&gt; dp1(2),dp2(2);</span><br><span class="line">        dp1[<span class="number">1</span>] = nums[<span class="number">0</span>],dp2[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = dp1[<span class="number">1</span>];</span><br><span class="line">            dp1[<span class="number">1</span>] = max(dp1[<span class="number">1</span>],dp1[<span class="number">0</span>]+nums[i<span class="number">-1</span>]);</span><br><span class="line">            dp1[<span class="number">0</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = dp2[<span class="number">1</span>];</span><br><span class="line">            dp2[<span class="number">1</span>] = max(dp2[<span class="number">1</span>],dp2[<span class="number">0</span>]+nums[i<span class="number">-1</span>]);</span><br><span class="line">            dp2[<span class="number">0</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(dp1[<span class="number">1</span>],dp2[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="413-等差数列划分"><a href="#413-等差数列划分" class="headerlink" title="413.等差数列划分"></a>413.等差数列划分</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">返回: <span class="number">3</span>, A 中有三个子等差数组: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] 以及自身 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]。</span><br><span class="line"><span class="comment">//规定连续的长度大于等于3的子数组为等差子数组，求给定数组中等差子数组的个数。</span></span><br></pre></td></tr></table></figure>
<img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201220180958000.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(A.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; A.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] - A[i - <span class="number">1</span>] == A[i - <span class="number">1</span>] - A[i - <span class="number">2</span>]) dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accumulate(dp.begin(),dp.end(),<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="746-最小花费爬楼梯"><a href="#746-最小花费爬楼梯" class="headerlink" title="746.最小花费爬楼梯"></a>746.最小花费爬楼梯</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从<span class="number">0</span>开始)。</span><br><span class="line"></span><br><span class="line">每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</span><br><span class="line"></span><br><span class="line">您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 <span class="number">0</span> 或 <span class="number">1</span> 的元素作为初始阶梯。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]表示能到i号阶梯的所有跳跃方式的集合,但是还没跳上i号阶梯</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size(),<span class="number">0x3f3f3f3f</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>,dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; cost.size();i++)&#123;</span><br><span class="line">            dp[i] = min(dp[i<span class="number">-2</span>] + cost[i<span class="number">-2</span>],dp[i<span class="number">-1</span>] + cost[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = dp[cost.size() - <span class="number">1</span>] + cost[cost.size() - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(n - <span class="number">1</span> &gt;= <span class="number">0</span>) res = min(dp[n<span class="number">-1</span>] + cost[n<span class="number">-1</span>],res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//改进版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵问题"><a href="#矩阵问题" class="headerlink" title="矩阵问题"></a>矩阵问题</h3><p>矩阵问题的一个特点就是状态的定义，我目前总结了一下常见的意义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.dp[i][j]代表以(i,j)为右下角的整个区域内满足某种条件的子集的集合</span><br><span class="line">2.dp[i][j]代表在1的基础上，所以子集中必须包含(i,j)这个点的集合，相当于在1的基础上缩小了(即固定住(i,j)这个点)。比如221题</span><br></pre></td></tr></table></figure>
<h4 id="174-地下城游戏"><a href="#174-地下城游戏" class="headerlink" title="174.地下城游戏"></a>174.地下城游戏</h4><img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201220144909804.png" class>

<p><strong>题意就是让你找到一个最小的HP值使你能走到终点，比如这里，第一个格子就要掉2HP，所以至少要3起步。总之就是勇士的血在路过每一个格子之后都不能低于1</strong></p>
<p><strong>这题是罕见的从右下向左上推</strong></p>
<img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201220151413079.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = d.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(d[<span class="number">0</span>].size()+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        dp[n][d[<span class="number">0</span>].size()] = d[n<span class="number">-1</span>][d[<span class="number">0</span>].size()<span class="number">-1</span>] &lt; <span class="number">0</span> ? -d[n<span class="number">-1</span>][d[<span class="number">0</span>].size()<span class="number">-1</span>] + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = d[<span class="number">0</span>].size()<span class="number">-1</span>;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[n - <span class="number">1</span>][i - <span class="number">1</span>] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(d[n<span class="number">-1</span>][i<span class="number">-1</span>] &gt;= dp[n][i+<span class="number">1</span>]) dp[n][i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[n][i] = dp[n][i+<span class="number">1</span>] - d[n<span class="number">-1</span>][i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> dp[n][i] = dp[n][i+<span class="number">1</span>] - d[n<span class="number">-1</span>][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =n - <span class="number">1</span>;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i - <span class="number">1</span>][d[<span class="number">0</span>].size() - <span class="number">1</span>] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(d[i<span class="number">-1</span>][d[<span class="number">0</span>].size()<span class="number">-1</span>] &gt;= dp[i+<span class="number">1</span>][d[<span class="number">0</span>].size()]) dp[i][d[<span class="number">0</span>].size()] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][d[<span class="number">0</span>].size()] = dp[i+<span class="number">1</span>][d[<span class="number">0</span>].size()] - d[i<span class="number">-1</span>][d[<span class="number">0</span>].size()<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> dp[i][d[<span class="number">0</span>].size()] = dp[i+<span class="number">1</span>][d[<span class="number">0</span>].size()] - d[i<span class="number">-1</span>][d[<span class="number">0</span>].size()<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上面是处理边界，</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = d[<span class="number">0</span>].size()<span class="number">-1</span>;j &gt;= <span class="number">1</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(d[i<span class="number">-1</span>][j<span class="number">-1</span>] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> val = min(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>]);</span><br><span class="line">                    <span class="keyword">if</span>(val &lt;= d[i<span class="number">-1</span>][j<span class="number">-1</span>]) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = val - d[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = min(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>]) - d[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="542-01矩阵"><a href="#542-01矩阵" class="headerlink" title="542.01矩阵"></a>542.01矩阵</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个由 <span class="number">0</span> 和 <span class="number">1</span> 组成的矩阵，找出每个元素到最近的 <span class="number">0</span> 的距离。</span><br><span class="line"></span><br><span class="line">两个相邻元素间的距离为 <span class="number">1</span> 。</span><br><span class="line">输入：</span><br><span class="line">[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure>
<p><strong>第一种方式就是BFS：不过我们的BFS是初始化时先将所有的值为0的点入队，并更新dist数组，然后把这所有的0点看作一个超级节点，也可以看成树中的根节点，然后以这个根节点开始DFS，那么第一次遇到的所有非0节点，他们距离0的距离就是dist[x] [y] + 1.然后把这些第一次更新的节点加入到队列，中依次再遍历周围找到新的节点。根据BFS的性质，BFS第一次遇到的点的层数一定是这个点到根节点的最短距离</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; updateMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dist(matrix.size(),<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(matrix[<span class="number">0</span>].size(),<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">using</span> PII = <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;PII&gt; que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; matrix.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; matrix[<span class="number">0</span>].size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!matrix[i][j])&#123;</span><br><span class="line">                    que.push(&#123;i,j&#125;);</span><br><span class="line">                    dist[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dist[i][j] = INT_MAX;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(que.size())&#123;</span><br><span class="line">            <span class="keyword">auto</span> q = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = q.first + dx[i];</span><br><span class="line">                <span class="keyword">int</span> y = q.second + dy[i];</span><br><span class="line">                <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; matrix.size() &amp;&amp; y &lt; matrix[<span class="number">0</span>].size())&#123;</span><br><span class="line">                    <span class="comment">//判断是否入过队列,非INT_MAX一定是访问过的</span></span><br><span class="line">                    <span class="keyword">if</span>(dist[x][y] &amp;&amp; dist[x][y] == INT_MAX)&#123;</span><br><span class="line">                        dist[x][y] = dist[q.first][q.second] + <span class="number">1</span>;</span><br><span class="line">                        que.push(&#123;x,y&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本题使用DP的话对任意一个状态他的集合要分为4类，但是无论是从上到下还是从下到上最多有两个方向也就是两类在计算这个状态之前被算出来了。所以我们选择从上到下一次，然后从下到上一次。两次更新。这样就更新到了所有方向</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; updateMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(matrix.size(),<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(matrix[<span class="number">0</span>].size(),<span class="number">0x3f3f3f3f</span>));</span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; matrix.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; matrix[<span class="number">0</span>].size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!matrix[i][j])&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>;k++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i + dx[k],y = j + dy[k];</span><br><span class="line">                    <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; matrix.size() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; matrix[<span class="number">0</span>].size())&#123;</span><br><span class="line">                        dp[i][j] = min(dp[x][y],dp[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = matrix.size() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = matrix[<span class="number">0</span>].size() - <span class="number">1</span>;j &gt;= <span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!matrix[i][j])&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>;k++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i + dx[k],y = j + dy[k];</span><br><span class="line">                    <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; matrix.size() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; matrix[<span class="number">0</span>].size())&#123;</span><br><span class="line">                        dp[i][j] = min(dp[x][y],dp[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关于动态规划为什么只考虑左上和右下就可以了。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">_ _ _ 0 _</span><br><span class="line">_ _ _ _ _</span><br><span class="line">_ _ 1 _ _</span><br><span class="line">_ _ _ _ _</span><br></pre></td></tr></table></figure>
<p>如上图，我们假设某个位置<code>(x,y)</code>离它最近的0只有一个，且是在它的右上角，在它“右1上2”的位置。这意味着距离中心1距离为“3=1+2”的范围内，所有的位置都是1（或者出界，我们暂时不考虑出界的情况，不影响结论）。</p>
<p>所以这张图一定是（不考虑左下方的出界情况，不影响）:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">? ? ? ?  1  ? ? ? ?</span><br><span class="line">? ? ? 1  1  0 ? ? ?</span><br><span class="line">? ? 1 1  1  1 1 ? ?</span><br><span class="line">? 1 1 1 &quot;1&quot; 1 1 1 ?</span><br><span class="line">? ? 1 1  1  1 1 ? ?</span><br><span class="line">? ? ? 1  1  1 ? ? ?</span><br><span class="line">? ? ? ?  1  ? ? ? ?</span><br></pre></td></tr></table></figure>
<p>所以我们来考虑它右一处标为X的位置，离这个位置最近的0，一定就是它“上二”方向的0：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">? ? ? ?  1  ? ? ? ?</span><br><span class="line">? ? ? 1  1  0 ? ? ?</span><br><span class="line">? ? 1 1  1  1 1 ? ?</span><br><span class="line">? 1 1 1 &quot;1&quot; X 1 1 ?</span><br><span class="line">? ? 1 1  1  1 1 ? ?</span><br><span class="line">? ? ? 1  1  1 ? ? ?</span><br><span class="line">? ? ? ?  1  ? ? ? ?</span><br></pre></td></tr></table></figure>
<p>所以在“考虑左上角的时候”，X处的位置可以记录到目标0的信息，X处的最短距离被正确记录了。</p>
<p>然后在“考虑右下角的时候”，X处的最短信息，正好又能被我们的中心“1”观察到，所以中心1间接地，记录到了目标0的最短距离。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">如图，从左上开始的第一遍会让<span class="number">0</span>为左上角的矩形区域全部记录到</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> / <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> / <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> / <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">从右下向左上遍历时，右下的区域又会把记录到的最短信息更新给左上半部分的区域</span><br></pre></td></tr></table></figure>
<h4 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221.最大正方形"></a>221.最大正方形</h4><img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20210121142416603.png" class>

<p><strong>题意就是在给定矩形矩阵中找到全由1构成的最大正方形的面积</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;对于矩阵搜索正方形或者长方形的题目，常见的做法是使用dp&quot;</span>。在这种题目里面一般定义dp[i][j]所代表的集合为以(i,j)为右下角的所有全是<span class="number">1</span>的正方形/矩形</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">状态计算</span><br><span class="line">令dp[i][j] = k</span><br><span class="line">dp[i<span class="number">-1</span>][j] &gt;= k - <span class="number">1</span></span><br><span class="line">dp[i][j<span class="number">-1</span>] &gt;= k - <span class="number">1</span></span><br><span class="line">dp[i<span class="number">-1</span>][j<span class="number">-1</span>] &gt;= k - <span class="number">1</span></span><br><span class="line">如果不满足上面的这个条件，以(i,j)为右下角的长度为k的矩形中绝对不可能全是<span class="number">1</span></span><br><span class="line">又因为dp[i][j]也只能从上说的三个方向的正方形延申过来，所以</span><br><span class="line">dp[i][j] = min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;如果dp[i-1][j],dp[i-1][j-1],dp[i][j-1]至少有一个为0，那么(i,j)的三个方向肯定有一个为0，那么没得大一统了，只能最多为1了。否则，看下图&quot;</span>。</span><br><span class="line">    所以两个条件一结合就是这个递推式了</span><br></pre></td></tr></table></figure>
<img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20210121161520853.png" class>

<img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20210121151146533.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size(),n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//dp一般从下标1开始，申请多一个方便处理边界，但还是要具体问题具体分析</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dp[i][j] = min(min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]),dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxlen = max(maxlen,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen*maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="1277-全为1的正方形子矩阵"><a href="#1277-全为1的正方形子矩阵" class="headerlink" title="1277.全为1的正方形子矩阵"></a>1277.全为1的正方形子矩阵</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：matrix =</span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出：<span class="number">15</span></span><br><span class="line">解释： </span><br><span class="line">边长为 <span class="number">1</span> 的正方形有 <span class="number">10</span> 个。</span><br><span class="line">边长为 <span class="number">2</span> 的正方形有 <span class="number">4</span> 个。</span><br><span class="line">边长为 <span class="number">3</span> 的正方形有 <span class="number">1</span> 个。</span><br><span class="line">正方形的总数 = <span class="number">10</span> + <span class="number">4</span> + <span class="number">1</span> = <span class="number">15.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">这一题我们只需要在<span class="number">221</span>题的基础上修改就可以了。dp[i][j]的值是以(i,j)为右下角的正方形的长，那么它<span class="string">&quot;也可以表示以(i,j)为右下角的正方形的个数&quot;</span>.所以最后我们把dp矩阵累加起来就可以了</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSquares</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size(),n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i<span class="number">-1</span>][j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j] = min(dp[i<span class="number">-1</span>][j],min(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>])) + <span class="number">1</span>;</span><br><span class="line">                res += dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="分割类问题"><a href="#分割类问题" class="headerlink" title="分割类问题"></a>分割类问题</h3><ul>
<li>顾名思义就是把一个数按要求拆分成几个部分，问拆分之后生成的最少部分数是多少。</li>
<li><strong>拆分类的题目都可以用dp来做，思路就和找零钱差不多</strong></li>
</ul>
<h4 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279.完全平方数"></a>279.完全平方数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定正整数 n，找到若干个完全平方数（比如 <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</span><br><span class="line">输入: n = <span class="number">12</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: <span class="number">12</span> = <span class="number">4</span> + <span class="number">4</span> + <span class="number">4.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思路和找零钱差不多，dp[i]表示拆分i需要的最少的完全平方数的个数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0x3f3f3f3f</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>,dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="built_in">sqrt</span>(i);j &gt;= <span class="number">1</span>;j--)&#123;</span><br><span class="line">                dp[i] = min(dp[i - j*j] + <span class="number">1</span>,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91.解码方法"></a>91.解码方法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</span><br><span class="line"><span class="string">&#x27;A&#x27;</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="string">&#x27;B&#x27;</span> -&gt; <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;Z&#x27;</span> -&gt; <span class="number">26</span></span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;226&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：它可以解码为 <span class="string">&quot;BZ&quot;</span> (<span class="number">2</span> <span class="number">26</span>), <span class="string">&quot;VF&quot;</span> (<span class="number">22</span> <span class="number">6</span>), 或者 <span class="string">&quot;BBF&quot;</span> (<span class="number">2</span> <span class="number">2</span> <span class="number">6</span>) 。</span><br><span class="line"><span class="comment">//问你数字有多少种解码方式</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dp[i]表示前i个字符的解码方式的个数，我们按照第i个字符是否独立编码划分集合(即是否和i-1结合)，一种是独立编码，另一种是与i-1结合编码。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(s.size()+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">//dp[1]和dp[2]是初始值需要特殊处理</span></span><br><span class="line">        dp[<span class="number">1</span>] = s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//看这个组成的两位数符不符合标准</span></span><br><span class="line">                <span class="keyword">if</span>(atoi(s.substr(<span class="number">0</span>,<span class="number">2</span>).c_str()) &lt;= <span class="number">26</span>) dp[<span class="number">2</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>] != <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(atoi(s.substr(<span class="number">0</span>,<span class="number">2</span>).c_str()) &lt;= <span class="number">26</span>) dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;=s.size();i++)&#123;</span><br><span class="line">            <span class="comment">//如果i号字符能单独存在</span></span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>] != <span class="string">&#x27;0&#x27;</span>) dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="comment">//如果i号字符能和i-1号结合</span></span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-2</span>] != <span class="string">&#x27;0&#x27;</span> &amp;&amp; atoi(s.substr(i<span class="number">-2</span>,<span class="number">2</span>).c_str()) &lt;= <span class="number">26</span>) dp[i] += dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a>139.单词拆分</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">拆分时可以重复使用字典中的单词。</span><br><span class="line">你可以假设字典中没有重复的单词。</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">&quot;leetcode&quot;</span>, wordDict = [<span class="string">&quot;leet&quot;</span>, <span class="string">&quot;code&quot;</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 返回 <span class="literal">true</span> 因为 <span class="string">&quot;leetcode&quot;</span> 可以被拆分成 <span class="string">&quot;leet code&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">这题也可以用dp，dp[i]的集合表示s的前i+<span class="number">1</span>个字符所有的拼接组合方式，值为这些组合方式中是否存在<span class="string">&quot;所有被拆分的部分都在字典中出现&quot;</span>这种情况。我们跟<span class="number">91</span>一样，根据第i号字符是否和i以前的字符组合来划分集合。</span><br></pre></td></tr></table></figure>
<img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20210121215532477.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">bool</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c:wordDict) mp[c] = <span class="literal">true</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="comment">//0号是初值</span></span><br><span class="line">        <span class="keyword">if</span>(mp[s.substr(<span class="number">0</span>,<span class="number">1</span>)]) dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; s.size();i++)&#123;</span><br><span class="line">            <span class="comment">//从i开始依次向前结合</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="comment">//如果[i-j+1,i]在字典出现，只需要再检查dp[i-j]是否能被成功拆分就可以了，如果</span></span><br><span class="line">                <span class="keyword">if</span>(mp[s.substr(i-j+<span class="number">1</span>,j)])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i &gt;= j) dp[i] = dp[i - j];</span><br><span class="line">                    <span class="keyword">else</span> dp[i] = <span class="literal">true</span>;<span class="comment">//特判j == i+1这种情况</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i]) <span class="keyword">break</span>;<span class="comment">//如果为true,说明存在某种拆分方式，直接退出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.size() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="背包类问题"><a href="#背包类问题" class="headerlink" title="背包类问题"></a>背包类问题</h3><p>01背包注意点</p>
<ul>
<li><strong>未优化的情况下，第二维都要从0开始，如果第i个货物放不下，就等于上一层。优化过后，逆着来，就相当于直接等于上一层，所以到j &gt;= v[i]为止就可以了</strong></li>
</ul>
<h4 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416.分割等和子集"></a>416.分割等和子集</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</span><br><span class="line">注意:</span><br><span class="line">每个数组中的元素不会超过 <span class="number">100</span></span><br><span class="line">数组的大小不会超过 <span class="number">200</span></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">5</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 数组可以分割成 [<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>] 和 [<span class="number">11</span>].</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">这一题用<span class="number">01</span>背包来做，我们定义dp[i][j]为前i个元素可以选出来的所有集合，他的值就是这些集合中是否存在和为j的这种集合。所以言下之意就是我们能否在前i个元素中找到和为j的目标集合k。<span class="string">&quot;我们根据这些子集中是否有第i个元素来将所有集合划分成两大类，然后我们只需要看这两大类子集中是否有和为j的子集就可以了。这两大类子集，第一类就是i-1个元素组成的所有子集，第二类就是就是第一类的所有集合中加入一个i号元素。如果第一大类有，那第二大类就没有，如果第二大类没有只需要检查第二大类，因为第二大类所有集合都有i，所以他们的和都有i号元素，那么对于第二大类只要检查有没有和为j - nums[i]的值就可以了。&quot;</span></span><br><span class="line">    事实上这样划分的集合也是不重不漏的，前i个元素的所有集合是由所有含i号元素的集合和不含i号元素的集合一起构成的</span><br></pre></td></tr></table></figure>
<img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20210122124208292.png" class>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.begin(),nums.end(),<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//奇数不可能</span></span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target  = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(nums.size()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(target+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">        <span class="comment">//初始值，后面的边界值处理需要</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= nums.size();i++) dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= nums.size();i++)&#123;</span><br><span class="line">            <span class="comment">//正规01背包未优化的写法，j应该从0开始</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= target;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= nums[i<span class="number">-1</span>]) dp[i][j] = dp[i][j] || dp[i<span class="number">-1</span>][j-nums[i<span class="number">-1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.size()][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.begin(),nums.end(),<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//奇数不可能</span></span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target  = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(nums.size()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(target+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">        <span class="comment">//初始值，后面的边界值处理需要</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= nums.size();i++) dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= nums.size();i++)&#123;</span><br><span class="line">            <span class="comment">//这里也是01背包未优化，但是j不是从0开始也是对的，我不知道为什么</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = nums[i<span class="number">-1</span>];j &lt;= target;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] || dp[i<span class="number">-1</span>][j-nums[i<span class="number">-1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.size()][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化为一维，倒着来</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.begin(),nums.end(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target  = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(target+<span class="number">1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = target;j &gt;= nums[i<span class="number">-1</span>];j--)&#123;</span><br><span class="line">                dp[j] = dp[j] || dp[j-nums[i<span class="number">-1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="474-1和0"><a href="#474-1和0" class="headerlink" title="474.1和0"></a>474.1和0</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</span><br><span class="line">请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 <span class="number">0</span> 和 n 个 <span class="number">1</span> 。</span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：strs = [<span class="string">&quot;10&quot;</span>, <span class="string">&quot;0001&quot;</span>, <span class="string">&quot;111001&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>], m = <span class="number">5</span>, n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最多有 <span class="number">5</span> 个 <span class="number">0</span> 和 <span class="number">3</span> 个 <span class="number">1</span> 的最大子集是 &#123;<span class="string">&quot;10&quot;</span>,<span class="string">&quot;0001&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>&#125; ，因此答案是 <span class="number">4</span> 。</span><br><span class="line">其他满足题意但较小的子集包括 &#123;<span class="string">&quot;0001&quot;</span>,<span class="string">&quot;1&quot;</span>&#125; 和 &#123;<span class="string">&quot;10&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>&#125; 。&#123;<span class="string">&quot;111001&quot;</span>&#125; 不满足题意，因为它含 <span class="number">4</span> 个 <span class="number">1</span> ，大于 n 的值 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">01b</span>背包，只不过这次相当于有两个包的限制，所以是多维<span class="number">01</span>背包</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; dp(strs.size()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>)));</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">one</span><span class="params">(strs.size()+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">zero</span><span class="params">(strs.size()+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; strs.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; strs[i].size();k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[i][k] == <span class="string">&#x27;1&#x27;</span>) one[i+<span class="number">1</span>]++;</span><br><span class="line">                <span class="keyword">else</span> zero[i+<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= strs.size();i++)&#123;</span><br><span class="line">            <span class="comment">//01背包未优化都要从0开始</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= m;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= n;k++)&#123;</span><br><span class="line">                    dp[i][j][k] = dp[i<span class="number">-1</span>][j][k];</span><br><span class="line">                    <span class="keyword">if</span>(j &gt;= zero[i] &amp;&amp; k &gt;= one[i])</span><br><span class="line">                        dp[i][j][k] = max(dp[i<span class="number">-1</span>][j-zero[i]][k-one[i]]+<span class="number">1</span>,dp[i][j][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[strs.size()][m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">one</span><span class="params">(strs.size()+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">zero</span><span class="params">(strs.size()+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; strs.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; strs[i].size();k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[i][k] == <span class="string">&#x27;1&#x27;</span>) one[i+<span class="number">1</span>]++;</span><br><span class="line">                <span class="keyword">else</span> zero[i+<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= strs.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m;j &gt;= zero[i];j--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = n;k &gt;= one[i];k--)&#123;</span><br><span class="line">                    dp[j][k] = max(dp[j-zero[i]][k-one[i]]+<span class="number">1</span>,dp[j][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="字符串编辑"><a href="#字符串编辑" class="headerlink" title="字符串编辑"></a>字符串编辑</h3><ul>
<li>**双字符串题(72 1143 10)**的dp[i] [j]表示第一个字符串的前i个字符和第二个串的前j个字符</li>
</ul>
<h4 id="72-编辑距离-1"><a href="#72-编辑距离-1" class="headerlink" title="72.编辑距离"></a>72.编辑距离</h4><h4 id="650-只有两个键的键盘"><a href="#650-只有两个键的键盘" class="headerlink" title="650.只有两个键的键盘"></a>650.只有两个键的键盘</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">最初在一个记事本上只有一个字符 <span class="string">&#x27;A&#x27;</span>。你每次可以对这个记事本进行两种操作：</span><br><span class="line">Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。</span><br><span class="line">Paste (粘贴) : 你可以粘贴你上一次复制的字符。</span><br><span class="line">给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 <span class="string">&#x27;A&#x27;</span>。输出能够打印出 n 个 <span class="string">&#x27;A&#x27;</span> 的最少操作次数。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: <span class="number">3</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释:</span><br><span class="line">最初, 我们只有一个字符 <span class="string">&#x27;A&#x27;</span>。</span><br><span class="line">第 <span class="number">1</span> 步, 我们使用 Copy All 操作。</span><br><span class="line">第 2 步, 我们使用 Paste 操作来获得 &#x27;AA&#x27;。</span><br><span class="line">第 3 步, 我们使用 Paste 操作来获得 &#x27;AAA&#x27;。</span><br></pre></td></tr></table></figure>
<img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20210122183731787.png" class>

<p>*<em>主要是考虑合数i = a</em>b表示i个A可以由a个b时的状态粘贴过来，也可以由b个a状态粘贴过来，取最小值**</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0x3f3f3f3f</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>,dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j &lt;= <span class="built_in">sqrt</span>(i);j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i] = min(min(dp[i],dp[j] + i / j),dp[i/j]+j);             </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == <span class="number">0x3f3f3f3f</span>) dp[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="10-正则表达式的匹配"><a href="#10-正则表达式的匹配" class="headerlink" title="10.正则表达式的匹配"></a>10.正则表达式的匹配</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 <span class="string">&#x27;.&#x27;</span> 和 <span class="string">&#x27;*&#x27;</span> 的正则表达式匹配。</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;.&#x27;</span> 匹配任意单个字符</span><br><span class="line"><span class="string">&#x27;*&#x27;</span> 匹配零个或多个前面的那一个元素</span><br><span class="line">所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：s = <span class="string">&quot;aa&quot;</span> p = <span class="string">&quot;a&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：<span class="string">&quot;a&quot;</span> 无法匹配 <span class="string">&quot;aa&quot;</span> 整个字符串。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">只要是涉及到双串(无论是匹配或者是其他操作)，dp时他们的状态数组都是同一种方式，dp[i][j]</span><br><span class="line">这题dp[i][j]还是表示S串的前i个字符和P串的前j个字符是否匹配</span><br><span class="line">操作还是类似于LCS，对尾部进行判断</span><br><span class="line">    <span class="number">1.</span>P[j] == S[i] || p[j] == <span class="string">&#x27;.&#x27;</span>，那么dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">    <span class="number">2.</span>P[j] == <span class="string">&#x27;*&#x27;</span></span><br><span class="line">    此时若*前面的字符和S[i]不相等,那么可以把*和其前面的字符一起消掉,即dp[i][j]=dp[i][j]||dp[i][j<span class="number">-2</span>]</span><br><span class="line">    如果*前面的字符x和s[i]相等，但是s[i<span class="number">-1</span>],s[i<span class="number">-2</span>]...可能都与x相等，这个时候就要考虑消去p的几个才能匹配了，所以我们要把所有可能要消去的元素都枚举一遍，看看是否能成功。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(s.size()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(p.size()+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//这里主要是初始化p串不为空，s为空但是也能匹配的这种特殊情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; p.size();i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i] == <span class="string">&#x27;*&#x27;</span>) dp[<span class="number">0</span>][i+<span class="number">1</span>] = dp[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= p.size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">&#x27;.&#x27;</span>) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> k = i;</span><br><span class="line">                    <span class="comment">//这里是*前面的元素和S[i]不相等或者相等时却不消去S[i]的情况</span></span><br><span class="line">                    dp[i][j] = dp[i][j] || dp[i][j<span class="number">-2</span>];</span><br><span class="line">                    <span class="comment">//下面枚举消去连续相等的1、2、3...个</span></span><br><span class="line">                    <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; (s[k<span class="number">-1</span>] == p[j<span class="number">-2</span>] || p[j<span class="number">-2</span>] == <span class="string">&#x27;.&#x27;</span>))&#123;</span><br><span class="line">                        dp[i][j] = dp[i][j] || dp[k<span class="number">-1</span>][j<span class="number">-2</span>];</span><br><span class="line">                        k--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.size()][p.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="股票买卖"><a href="#股票买卖" class="headerlink" title="股票买卖"></a>股票买卖</h3><ul>
<li><p>给定一支股票的价格数组，问你怎么买卖这支股票利润最该</p>
</li>
<li><p>一次买入，接着卖出才算一次交易</p>
</li>
<li><p><a href="https://leetcode-cn.com/circle/article/qiAgHn/">https://leetcode-cn.com/circle/article/qiAgHn/</a> 这个非常详细，他介绍的状态模板非常好用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只有今天买入股票才会减少最大交易次数</span></span><br><span class="line">T[i][k][<span class="number">0</span>] 表示在第 i 天结束时，最多进行 k 次交易且在进行操作后持有 <span class="number">0</span> 份股票的情况下可以获得的最大收益；</span><br><span class="line">T[i][k][<span class="number">1</span>] 表示在第 i 天结束时，最多进行 k 次交易且在进行操作后持有 <span class="number">1</span> 份股票的情况下可以获得的最大收益。</span><br><span class="line"><span class="comment">//今天不持股，1.昨天也不持股，今天啥也不做(那今天允许的最大交易次数为k,昨天允许的最大交易次数也为) 2.昨天持股，今天卖掉，但是不影响最大交易次数(今天允许的最大交易次数为k，今天只是卖掉，所以昨天允许的最大交易次数也为k)。因为只有今天买入才会影响交易次数</span></span><br><span class="line">T[i][k][<span class="number">0</span>] = max(T[i - <span class="number">1</span>][k][<span class="number">0</span>], T[i - <span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line"><span class="comment">//今天持股，1.昨天就持股，今天啥也不做(那么你最大交易次数为k,昨天最大交易次数还是3) 2.昨天不持股，今天买入，要花掉一次交易次数。(前i天最大只能交易k次，你第i天交易了一次，那么前i-1天最大只能交易k-1次)</span></span><br><span class="line">T[i][k][<span class="number">1</span>] = max(T[i - <span class="number">1</span>][k][<span class="number">1</span>], T[i - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="121-股票买卖最佳时机Ⅰ"><a href="#121-股票买卖最佳时机Ⅰ" class="headerlink" title="121.股票买卖最佳时机Ⅰ"></a>121.股票买卖最佳时机Ⅰ</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</span><br><span class="line"></span><br><span class="line">如果你<span class="string">&quot;最多只允许完成一笔交易（即买入和卖出一支股票一次）&quot;</span>，设计一个算法来计算你所能获取的最大利润。</span><br><span class="line">注意：你不能在买入股票前卖出股票。</span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: 在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出，最大利润 = <span class="number">6</span><span class="number">-1</span> = <span class="number">5</span> 。</span><br><span class="line">     注意利润不能是 <span class="number">7</span><span class="number">-1</span> = <span class="number">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line"><span class="comment">//注意本题只能买入卖出股票一次，也就是只能交易一次，而每次交易都是从买入开始的，所以买入股票之后才是减少了一次交易，所以交易一次后的状态就是持有股票</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">这一题是最多只卖买一次</span><br><span class="line">推导状态转移方程：</span><br><span class="line"></span><br><span class="line">dp[i][<span class="number">0</span>]：规定了今天不持股，有以下两种情况：</span><br><span class="line">昨天不持股，今天什么都不做；</span><br><span class="line">昨天持股，今天卖出股票（现金数增加），</span><br><span class="line">dp[i][<span class="number">1</span>]：规定了今天持股，有以下两种情况：</span><br><span class="line">昨天持股，今天什么都不做（现金数与昨天一样）；</span><br><span class="line">昨天不持股，今天买入股票（注意：只允许交易一次，因此今天买入股票就是第一次也是最后一次买，所以dp[i][<span class="number">1</span>]就是今天股票价格的相反数）。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(prices.size()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>,dp[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= prices.size();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i<span class="number">-1</span>]);</span><br><span class="line">            <span class="comment">//只有一次交易，所以买入股票也是第一次买入，所以获得利润一定是这次股票金额的相反数</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>],-prices[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.size()][<span class="number">0</span>];<span class="comment">//肯定是最后天不持股前最多，因为只能买入一次，所以今天还有股票，钱一定是负数，还没卖</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//滚动数组优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>,dp[<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= prices.size();i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>] = max(dp[<span class="number">0</span>],dp[<span class="number">1</span>]+prices[i<span class="number">-1</span>]);</span><br><span class="line">            dp[<span class="number">1</span>] = max(dp[<span class="number">1</span>],-prices[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="122-股票买卖最佳时机Ⅱ"><a href="#122-股票买卖最佳时机Ⅱ" class="headerlink" title="122.股票买卖最佳时机Ⅱ"></a>122.股票买卖最佳时机Ⅱ</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本题允许多次交易</span></span><br><span class="line">给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</span><br><span class="line">设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</span><br><span class="line">注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">3</span> 天（股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span><span class="number">-1</span> = <span class="number">4</span> 。</span><br><span class="line">     随后，在第 <span class="number">4</span> 天（股票价格 = <span class="number">3</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">6</span><span class="number">-3</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(prices.size()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>,dp[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= prices.size();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i<span class="number">-1</span>]);</span><br><span class="line">            <span class="comment">//多次交易和一次交易的区别就在这里，多次交易今天买股票就有可能不是第一次交易了</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.size()][<span class="number">0</span>];<span class="comment">//最后一定是没有钱套在股票里面利润高</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空间优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>,dp[<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= prices.size();i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>] = max(dp[<span class="number">0</span>],dp[<span class="number">1</span>]+prices[i<span class="number">-1</span>]);</span><br><span class="line">            dp[<span class="number">1</span>] = max(dp[<span class="number">1</span>],dp[<span class="number">0</span>]-prices[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="123-股票买卖最佳时机Ⅲ"><a href="#123-股票买卖最佳时机Ⅲ" class="headerlink" title="123.股票买卖最佳时机Ⅲ"></a>123.股票买卖最佳时机Ⅲ</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</span><br><span class="line">设计一个算法来计算你所能获取的最大利润。你最多可以完成 <span class="string">&quot;两笔&quot;</span> 交易。</span><br><span class="line">注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里用到的就是k=2时的递推模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; dp(prices.size()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(<span class="number">3</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>)));</span><br><span class="line">        <span class="comment">//这个初始化很重要，无论是最大交易次数为几次，第一天</span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = - prices[<span class="number">0</span>],dp[<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= prices.size();i++)&#123;</span><br><span class="line">            <span class="comment">//其实这里顺着逆着都可以，因为他用到都是昨天的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j &gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">0</span>],dp[i<span class="number">-1</span>][j][<span class="number">1</span>]+prices[i<span class="number">-1</span>]);</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>]-prices[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;zu</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.size()][<span class="number">2</span>][<span class="number">0</span>];<span class="comment">//自然是最后没有钱套在里面钱最多</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空间优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(<span class="number">3</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = - prices[<span class="number">0</span>],dp[<span class="number">2</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= prices.size();i++)&#123;</span><br><span class="line">            <span class="comment">//因为j=2和j=1是独立的空间，所以从后向前和从前向后都一样</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">2</span>;j++)&#123;</span><br><span class="line">                dp[j][<span class="number">0</span>] = max(dp[j][<span class="number">0</span>],dp[j][<span class="number">1</span>]+prices[i<span class="number">-1</span>]);</span><br><span class="line">                dp[j][<span class="number">1</span>] = max(dp[j][<span class="number">1</span>],dp[j<span class="number">-1</span>][<span class="number">0</span>]-prices[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="188-股票买卖最佳时机Ⅳ"><a href="#188-股票买卖最佳时机Ⅳ" class="headerlink" title="188.股票买卖最佳时机Ⅳ"></a>188.股票买卖最佳时机Ⅳ</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</span><br><span class="line">设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</span><br><span class="line">注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这一题就是上面可以2次交易的一般推广版，只要注意k=1时要特殊处理就行了.下面是优化过后的代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">maxProfit1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>,dp[<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= prices.size();i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>] = max(dp[<span class="number">0</span>],dp[<span class="number">1</span>]+prices[i<span class="number">-1</span>]);</span><br><span class="line">            dp[<span class="number">1</span>] = max(dp[<span class="number">1</span>],-prices[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> maxProfit1(prices);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(k+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++) dp[i][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= prices.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= k;j++)&#123;</span><br><span class="line">                dp[j][<span class="number">0</span>] = max(dp[j][<span class="number">0</span>],dp[j][<span class="number">1</span>]+prices[i<span class="number">-1</span>]);</span><br><span class="line">                dp[j][<span class="number">1</span>] = max(dp[j][<span class="number">1</span>],dp[j<span class="number">-1</span>][<span class="number">0</span>]-prices[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a>309. 最佳买卖股票时机含冷冻期</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</span><br><span class="line">设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</span><br><span class="line">你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br><span class="line">卖出股票后，你无法在第二天买入股票 (即冷冻期为 <span class="number">1</span> 天)。</span><br><span class="line">示例:</span><br><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br><span class="line"><span class="comment">//这题还是官方题解比较清晰</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关于冷冻期，只有卖出股票之后才是冷冻期，才会影响股票的购入，所以冷冻期一定之和购入股票有关系，而购入股票只有在持有股票这种状态才有，所有我们要到持有股票态dp[i][1]思考</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty() || prices.size() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(prices.size()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>,dp[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">2</span>][<span class="number">0</span>] = max(dp[<span class="number">1</span>][<span class="number">0</span>],dp[<span class="number">1</span>][<span class="number">1</span>]+prices[<span class="number">1</span>]);</span><br><span class="line">        dp[<span class="number">2</span>][<span class="number">1</span>] = max(dp[<span class="number">1</span>][<span class="number">1</span>],dp[<span class="number">1</span>][<span class="number">0</span>]-prices[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= prices.size();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i<span class="number">-1</span>]);</span><br><span class="line">            <span class="comment">/*现在考虑的是今天结束后你持有股票</span></span><br><span class="line"><span class="comment">            1.昨天结束后你就有股票，今天啥也没干</span></span><br><span class="line"><span class="comment">            2.你昨天结束之后没有，但是今天要买(所以昨天结束后一定未持股)，那么昨天要么是冷冻期，要么就是前天就没有然后昨天又没买。是否有冷冻期取决于前天到底是否卖出了股票，你前天卖出去了，昨天冷冻期，导致未持股。前天你本来就没股票，然后你昨天也没股票，昨天又没买。</span></span><br><span class="line"><span class="comment">            综上，我们只需要保证前天结束之后你没股票，从这个状态过来就可以，所以对于前天而言，我们只需要这一种决策就可以了。因为你前天结束之后没股票，不管他是怎么没的，在我们的要求下昨天都不会买。所以在i-2天没股票的情况下过来，昨天结束之后没股票的钱是等于前天结束之后没股票的钱的。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="string">&quot;最新总结，如果你想第i天买股票，那么i-1天必须没股票，但是如果从i-1天直接过来的话会有问题：因为你i-1天不持股的最大价值dp[i-1][0]可能是由于你第i-1天卖出去导致，也有可能是你第i-1天没股，啥也不动(即i-1天之前就获得了最大值)。如果如果dp[i-1][0]是由于第i-1天卖掉股票得到的，会导致今天冷冻期，结果你还买了，违反了冷冻期。所以我们要让第i天买的时候绝对不是冷冻期，所以冷冻期最多在i-1天。所以如果从i-2天过来就不会有这儿问题。为什么呢？因为i-2天之后就铁没股票的(我们从dp[i-2][0]调过来)，然后第i天要买，不管i-2天是怎么弄得，就算有冷冻期，冷冻期也只在第i-1天，对第i天一定影响都没有。还有就是我们从dp[i-2][0]过来之后，要保证第i买股票，所以i-1天必定没股票，也就是第i-1天什么都不操作。在这两层约束下，dp[i-1][0] = dp[i-2][0]的。所以调过来是没问题的&quot;</span></span><br><span class="line">                <span class="string">&quot;保证i天不是冷冻期且第i天能买&quot;</span>-&gt;第i<span class="number">-1</span>天绝对没卖且第i<span class="number">-1</span>天结束后没股票-&gt;那么i<span class="number">-1</span>天开始就没股票-&gt;那么只能从i<span class="number">-2</span>天后没股票这个状态过来，即dp[i<span class="number">-2</span>][<span class="number">0</span>]。</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-2</span>][<span class="number">0</span>]-prices[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.size()][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="124-二叉树的最大路径和"><a href="#124-二叉树的最大路径和" class="headerlink" title="124.二叉树的最大路径和"></a>124.二叉树的最大路径和</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个非空二叉树，返回其最大路径和。</span><br><span class="line"></span><br><span class="line">本题中，路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</span><br><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">       <span class="number">1</span></span><br><span class="line">      / \</span><br><span class="line">     <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure>
<img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201225003706680.png" class>

<p><strong>如图，对这样的一棵一般性的树，根的左右孩子都有两条分支。我们只要求A左子树上包括根节点在内最大单侧分支。A右子树的最大单侧分支。再将他们和根节点加起来得到一个值。这三个值最大值就是我们的结果</strong></p>
<img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201225090815684.png" class>

<p>我们写一个函数，返回的就是root左孩子两个圈的最大值v1和右孩子两个圈的最大值v2。这样整个树路径最大值。只可能在。v1,v2,v1+v2之间取了。考虑到v1,v2都可能为负数，如果是负数对整个最大路径没有增益，所以可以用0来处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//返回包括root在内的左右斜枝的的路径的最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxOneSide</span><span class="params">(TreeNode* root,<span class="keyword">int</span> &amp;value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = maxOneSide(root-&gt;left,value);</span><br><span class="line">        <span class="keyword">int</span> right = maxOneSide(root-&gt;right,value);</span><br><span class="line">        <span class="keyword">int</span> lmr = max(<span class="number">0</span>,left) + max(<span class="number">0</span>,right) + root-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> ret = max(<span class="number">0</span>,max(left,right)) + root-&gt;val;</span><br><span class="line">        value = max(value,max(ret,lmr));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value =INT_MIN;</span><br><span class="line">        maxOneSide(root,value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>实习准备</title>
    <url>/2021/04/02/%E5%AE%9E%E4%B9%A0%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<h1 id="C-语法"><a href="#C-语法" class="headerlink" title="C++语法"></a>C++语法</h1><h2 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h2><h3 id="Override和final"><a href="#Override和final" class="headerlink" title="Override和final"></a>Override和final</h3><p><strong>首先了解c++中的隐藏、重载、覆盖（重写）的区别</strong></p>
<p><strong>成员函数</strong>被重载的特征：</p>
<ol>
<li><strong>相同的范围，在同一个作用域中，且处于同一级作用域</strong>（这里就是在同一个类中）</li>
<li>函数名字相同；</li>
<li>参数不同；</li>
<li>virtual关键字可有可无。(<strong>同一个类中，virtual不是重载依据</strong>)</li>
</ol>
<a id="more"></a>

<p>成员函数被覆盖是指<strong>派生类函数覆盖基类函数</strong>，特征是：</p>
<ol>
<li>不同的范围（分别位于派生类与基类）；</li>
<li>函数名字相同；</li>
<li>父子类函数参数相同；</li>
<li><strong>基类函数必须有virtual关键字。</strong></li>
</ol>
<p><strong>覆盖是针对虚函数来说的。父类有一个虚函数，子类继承时定义一个和父类虚函数同名且同参数的函数(可以不带static)，此时我们称子类覆盖了基类函数</strong></p>
<p>成员函数被隐藏的特征：</p>
<ol>
<li><p>如果派生类的函数与基类的函数同名，但是<strong>参数不同</strong>。此时，<strong>不论有无virtual关键字</strong>，基类的所有同名函数都将被隐藏（注意别与重载混淆）。</p>
</li>
<li><p>如果派生类的函数与基类的函数同名，并且<strong>参数也相同</strong>，但是基类函数<strong>没有virtual关键字</strong>。此时，基类的函数被隐藏（注意别与覆盖混淆）。</p>
</li>
</ol>
<p>final：可以用来修饰<strong>虚函数</strong>或者类，分别表示派生类不应当覆盖(重写)父类被final修饰的虚函数、被final修饰的类不可被继承。**(非虚函数不能用final标识符修饰)**</p>
<p><strong>类被final修饰，该类不能被继承</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> <span class="keyword">final</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> :</span> A1 &#123; &#125;; <span class="comment">// “B1”: 无法从“A1”继承，因为它已被声明为“final”</span></span><br></pre></td></tr></table></figure>
<p><strong>父类虚函数被final修饰，子类不能重写父类对应的虚函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">final</span> </span>&#123;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> :</span> A1</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//“A1::func”: 声明为“final”的函数无法被“B1::func”重写</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>override：当子类中的虚函数被override修饰时，表示子类应当覆盖(重写)基类中的虚函数。这个可以让编译器帮忙确认父类是否有和”子类中被override修饰的虚函数”相同的函数签名(<strong>virtual不算在函数签名中，所以子类被override修饰的虚函数没有virtual也可以</strong>)，没有相同签名说明子类没有重写父类的虚函数(<strong>即函数参数或名字写错了</strong>)。可以防止因疏忽把本来的想重写的基类的虚函数在派生类中声明为隐藏。(<strong>override也不可以修饰非虚函数</strong>)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">double</span> b, <span class="keyword">bool</span> c)</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">double</span> b, <span class="keyword">bool</span> c)</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">bool</span> z)</span> <span class="keyword">override</span></span>&#123;&#125;;<span class="comment">//错误，父类没有找到相同的函数签名</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    Derived d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Move语义和右值引用"><a href="#Move语义和右值引用" class="headerlink" title="Move语义和右值引用"></a>Move语义和右值引用</h3><p>Move语义就是类中实现了偷取右值对象内容的一种成员函数</p>
<p><strong>左值、右值：</strong></p>
<p>​        在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为<strong>纯右值</strong>、<strong>将亡值</strong>。在c++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。举个例子，int a = b+c, a 就是左值，其有变量名为a，通过&amp;a可以获取该变量的地址；<strong>表达式</strong>b+c、<strong>函数</strong>int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。</p>
<p><strong>纯右值、将亡值：</strong></p>
<p>​        在理解C++11的右值前，先看看C++98中右值的概念：C++98中右值是纯右值，纯右值指的是临时变量值、不跟对象关联的字面量值。临时变量指的是<strong>非引用返回</strong>的函数返回值、表达式(<strong>由类对象组成的表达式也是右值</strong>)等(<strong>其实类的临时对象应该是属于临时变量的，当右值，但是编译器会把它当作左值，所以这里我们不要考虑类的临时对象</strong>)，例如函数int func()的返回值，表达式a+b；不跟对象关联的字面量值，例如true，2，”C”等。</p>
<p>​        C++11对C++98中的右值进行了扩充。在C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）。其中纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和不跟对象关联的字面量值；将亡值则是C++11新增的<strong>跟右值引用相关的表达式</strong>，这样表达式通常是将要被移动的对象（移为他用），比如返回<strong>右值引用T&amp;&amp;的函数返回值</strong>、<strong>std::move的返回值</strong>，或者转换为T&amp;&amp;的类型转换函数的返回值。</p>
<p>​        将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值(<strong>盗取即让对方和其关联的内存断开联系，然后我来和这块内存建立联系</strong>)。但是必须确保其他变量不再被使用、或即将被销毁时(<strong>也可以用std::move(左值)将变量强制转换为右值，告诉编译器这个左值变量不再被使用</strong>)，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。</p>
<p><strong>左值引用、右值引用：</strong></p>
<p>​        左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值对象(<strong>纯右值或将亡值</strong>)进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。</p>
<p>​        右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存(<strong>引用不会被分配内存</strong>)，只是该对象的一个别名。左值引用是<strong>具名变量</strong>的别名，而右值引用则是<strong>不具名（匿名）变量</strong>的别名。</p>
<p>​        左值引用不能绑定到右值对象上，右值引用也不能绑定到左值对象上。<br>​    <strong>例外</strong>：如果<strong>左值引用</strong>是const类型的，则其可以绑定到右值对象上。</p>
<p>​        左值引用通常也不能绑定到右值，但<strong>常量左值引用是个“万能”的引用类型</strong>。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值引用只能接受非常量左值对其进行初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;a = <span class="number">2</span>;       # 左值引用绑定到右值，编译失败</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;        # 非常量左值</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;c = b; # 常量左值引用绑定到非常量左值，编译通过</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> d = <span class="number">2</span>;  # 常量左值</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;e = c; # 常量左值引用绑定到常量左值，编译通过</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;b =<span class="number">2</span>;  # 常量左值引用绑定到右值，编程通过</span><br></pre></td></tr></table></figure>
<p>​        右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，需要**std::move()**将左值强制转换为右值，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r1 = c;             <span class="comment">// 编译失败</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r2 = <span class="built_in">std</span>::move(a);  <span class="comment">// 编译通过</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r3 = <span class="number">3</span>;             <span class="comment">// 编译通过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; b = a;</span><br><span class="line"><span class="keyword">int</span>&amp; c = a;<span class="comment">//左值引用可以指向左值引用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​        右值引用变量是个左值，而右值引用只能指向右值对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; k = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; c = k; <span class="comment">//error，右值引用不能指向右值引用变量(右值引用变量是个左指)，只能指向右值对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int&amp; &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int&amp;&amp; &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;</span><br><span class="line">	func(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">2</span>; </span><br><span class="line">	<span class="keyword">int</span>&amp;&amp; b = <span class="number">2</span>;<span class="comment">//b这个右值引用变量是个左值</span></span><br><span class="line">	func(a);<span class="comment">//int&amp; </span></span><br><span class="line">	func(b);<span class="comment">//int&amp; ,因为右值引用变量是个左指</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        由于右值引用只能绑定到右值对象上，而右值对象又是短暂的、即将销毁的。也就是说右值引用有一个重要性质：只能绑定到即将销毁的对象上。只要能够绑定右值的引用类型，都能够延长右值的生命期。</p>
<p><strong>右值引用一般和移动拷贝构造函数、移动赋值函数搭配在一起使用，主要是解决部分容器扩张时的效能问题，比如vector会动态增长，当获得一片新的内存时，要把原先内存的值拷贝过去，如果调用拷贝构造函数开销会比较大。而用移动拷贝构造函数，只需要修改指针，开销比较小。还有就是deque如果在中间插入这种情况，移动拷贝构造也能减小开销。其他的容器不会涉及到容器元素挪动，性能上影响不太大</strong></p>
<p>在C++11中，拷贝/移动构造函数实际上有以下3个版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">type(T &amp;)</span><br><span class="line">type(<span class="keyword">const</span> T &amp;)</span><br><span class="line">type(T&amp;&amp;)<span class="comment">//移动拷贝构造不能是const的，否则他无法偷取内存</span></span><br></pre></td></tr></table></figure>
<p>举例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> CCtor;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init_data</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">		data = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">memcpy</span>(data, s, len);</span><br><span class="line">		data[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	MyString(<span class="keyword">const</span> <span class="keyword">char</span>* str):len(<span class="built_in">strlen</span>(str)) &#123;</span><br><span class="line">		init_data(str);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//左值引用拷贝构造函数,深拷贝</span></span><br><span class="line">	MyString(<span class="keyword">const</span> MyString&amp; str):len(str.len) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Ctor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		init_data(str.data);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//右值引用拷贝构造函数,偷右值的内容。也称为移动构造函数</span></span><br><span class="line">	MyString(MyString&amp;&amp; str)<span class="keyword">noexcept</span> :len(str.len) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Move Ctor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		data = str.data;</span><br><span class="line">		str.len = <span class="number">0</span>;</span><br><span class="line">		str.data = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~MyString() &#123;</span><br><span class="line">		<span class="comment">//右值引用拷贝构造函数会将临时对象的指针断开，把指针置为空，所以临时对象析构时要检查指针是否已为空</span></span><br><span class="line">		<span class="keyword">if</span> (data != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span>[] data;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span>* data;</span><br><span class="line">	<span class="keyword">size_t</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">MyString <span class="title">str</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">	MyString s1 = MyString(str);<span class="comment">//类的临时对象比较特殊，被编译器当作左值处理的，一般不需要考虑</span></span><br><span class="line">	MyString s2 = <span class="built_in">std</span>::move(str);<span class="comment">//将左值转换为右值，调用移动构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>完美转发</strong></p>
<p><strong>forward的作用</strong></p>
<p>std::forward被称为<strong>完美转发</strong>，它的作用是保持原来的<code>值</code>属性不变。啥意思呢？通俗的讲就是，如果原来的值是左值，经std::forward处理后该值还是左值；如果原来的值是右值，经std::forward处理后它还是右值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int&amp; &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int&amp;&amp; &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;</span><br><span class="line">	func(i);<span class="comment">//调用的的是int&amp;，因为右值引用变量i是个左值，而我们原本想转发的变量是个右值，所以这是个不完美转发。我们想调用的是int&amp;&amp;版本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;</span><br><span class="line">	func(<span class="built_in">std</span>::forward&lt;<span class="keyword">int</span>&gt;(i));<span class="comment">//使用std::forward&lt;T&gt;(variable)，这个就是将变量完美转发，保持原有变量的属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">	func(a);<span class="comment">//int&amp;</span></span><br><span class="line">	func(<span class="number">1</span>);<span class="comment">//int&amp;&amp;</span></span><br><span class="line">	forward(<span class="number">2</span>);<span class="comment">//int&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p><a href="https://avdancedu.com/9683d88/">https://avdancedu.com/9683d88/</a>  </p>
<h4 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h4><p>​        C++98的auto_ptr，不支持多个auto_ptr指向同一块堆区空间。当将一个auto_ptr赋值给另一个auto_ptr时，让原来的auto_ptr(赋值者)指向空地址（nullptr)，新的auto_ptr指向堆空间。</p>
<h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><p>​        unique_ptr为了解决auto_ptr的问题，阻止了指针对于堆区空间的传递性。它将其拷贝构造函数及赋值操作符全部隐藏起来，即不允许智能指针之间的拷贝或者赋值，这样就不会有auto_ptr的问题了。</p>
<p>​        但是unique_ptr可以对右值进行转移，即提供了<strong>但提供了移动语义</strong>。即允许将声明为右值的unique_ptr的数据移动到当前unique_ptr中。</p>
<h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><p>​        共享智能指针的特点就是有一个指向引用计数器变量的指针，当对智能指针进行拷贝或者赋值时，会对引用计数进行修改。只有当智能指针的引用计数变为0时，才允许对堆区空间进行释放。</p>
<p>智能指针类将一个计数器类与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。</p>
<ol>
<li>每次创建指针类的新对象时，初始化指针并将引用计数置为1；</li>
<li>当指针对象初始化另一个指针对象时，拷贝构造函数拷贝指针并增加与之相应的引用计数；</li>
<li>对一个指针对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；</li>
<li>调用指针析构函数时，减少引用计数（如果引用计数减至0，则删除所指基础对象）。</li>
</ol>
<p>​        下面是自定义的共享智能指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">share_ptr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//即使是空指针，引用计数也为1。为了以后析构不出问题</span></span><br><span class="line">	share_ptr(T* ptr = <span class="literal">nullptr</span>) :_ptr(ptr),count(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	share_ptr(share_ptr&lt;T&gt;&amp; p):_ptr(p._ptr),count(p.count) &#123;</span><br><span class="line">		(*count)++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T* <span class="keyword">operator</span>-&gt; () &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">		<span class="keyword">return</span> *_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝赋值函数</span></span><br><span class="line">	share_ptr&amp; <span class="keyword">operator</span>=(share_ptr&lt;T&gt;&amp; p) &#123;</span><br><span class="line">		<span class="comment">//1.断开原有连接</span></span><br><span class="line">		--(*count);</span><br><span class="line">		release();</span><br><span class="line">		<span class="comment">//2.和新的指针建立连接</span></span><br><span class="line">		count = p.count;</span><br><span class="line">		(*count)++;</span><br><span class="line">		_ptr = p._ptr;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放只能指针指向的堆区空间和引用计数指向的堆区空间</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (*count == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;堆区空间被释放&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">delete</span> count;</span><br><span class="line">			<span class="keyword">delete</span> _ptr;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前指针引用计数为：&quot;</span> &lt;&lt; *count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~share_ptr() &#123;</span><br><span class="line">		<span class="comment">//如果引用计数为0，则释放堆区空间</span></span><br><span class="line">		--(*count);</span><br><span class="line">		release();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span>* count;</span><br><span class="line">	T* _ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>共享智能指针存在的问题：当场景为<strong>循环引用</strong>时，会存在内存泄漏问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;B&gt; p_b;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;A&gt; p_a;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">share_ptr&lt;A&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line">		<span class="function">share_ptr&lt;B&gt; <span class="title">b</span><span class="params">(<span class="keyword">new</span> B)</span></span>;</span><br><span class="line">		a-&gt;p_b = b;<span class="comment">//b的引用计数变为2，b中的p_a原先指向的空间已经被析构</span></span><br><span class="line">		b-&gt;p_a = a;<span class="comment">//a的引用计数为2，a中的p_b原先指向的空间已经被析构</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当程序结束时，b先析构，b析构时会将引用计数-1，此时b的引用计数变为1，所以此时不会去释放b指向的那块堆区内存空间，而b指向的那块堆区内存空间中存放的是一个B类对象，这个B类对象有一个智能指针p_a。他的智能指针指向的是变量a的堆区内存空间。所以如果b指向的这块堆区空间不释放就会导致a的堆区引用计数至少为1.所以a的堆区得不到释放。同理a的堆区得不到释放，就会还有一个只能指针指向b的堆区，所以b的堆区也永远不会被释放。</span></span><br></pre></td></tr></table></figure>


<h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><p>​        weak_ptr就是专门为了解决这个问题而出现的。实际上weak_ptr不能单独称为一个智能指针，它必须与一个shared_ptr关联然后一起使用，起到辅助share_ptr的作用，不能直接指向一个堆区对象。辅助类weak_ptr的数据成员是一个<strong>计数器类指针</strong>和一个<strong>基础对象指针</strong>。</p>
<p>​        我们分析一下问题：上面shared_ptr的内存泄漏是因为两个指针的引用计数都为2。所以我们只需要让每个a和b这两个指针的引用计数都是1就可以了。这样就能正常释放堆区空间，但是b中的p_a也指向了a所指向的堆区内存空间，我们的原本循环引用的目的是想也可以通过b中的p_a访问a堆区的内存空间。</p>
<p>​        所以我们总结需求就是在b-&gt;p_a = a的同时又不想增加a堆区的引用计数，因此我们提出了weak_ptr，引出weak_ptr之后，每个shared_ptr对象将记录两个引用，一个是原本的shared_ptr引用，我们也称为强引用，还有一个就是新提出的weak_ptr引用，也称为弱引用。将p_a定义为weak_ptr类型，<code>weak_ptr&lt;A&gt; p_a</code> ;b-&gt;p_a = a时不会增加a的强引用计数，但是会增加a的弱引用计数。弱引用计数对shared_ptr管理的堆区释放没有影响。</p>
<p>​        当我们想通过弱指针访问他关联的强指针堆区时，可以通过lock函数将其转换为强指针来访问。</p>
<p><strong>说白了弱指针就是提供了另一种可以访问强指针管理的堆区的方法，同时还不会影响共享强指针管理空间的计数。比如说堆区空间是个房子，强指针就是进出这个房子的钥匙，多个强指针就是多个不同的钥匙，他们都可以进入这个房子。而弱指针就是配了一把假钥匙，也可以访问房子。但是统计局不会记录假钥匙，当一个强指针被析构，真钥匙就销毁一把，当统计局记录到真钥匙全部被销毁时，直接炸了房子，根本不管假钥匙。所以假钥匙要访问房子时还是检查房子是否被炸了，也就是用expired检查房子还在不在。所以我么感觉weak_ptr的计数没什么用</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Counter():s(<span class="number">0</span>),w(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> s; <span class="comment">//存放share_ptr引用计数，称为强指针引用计数</span></span><br><span class="line">        <span class="keyword">int</span> w; <span class="comment">//存放weak_ptr引用计数，称为弱指针引用计数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">WeakPtr</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SharedPtr &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//friend class WeakPtr&lt;T&gt;;</span></span><br><span class="line">        <span class="keyword">void</span> _release()&#123;</span><br><span class="line">            _cnt-&gt;s--;</span><br><span class="line">            <span class="comment">//还是根据shared_ptr计数决定是否释放堆区空间，我认为这里可以直接由强指针把堆区的计数对象给释放了，弱指针脱离强指针就没什么用了。</span></span><br><span class="line">            <span class="keyword">if</span>(_cnt-&gt;s &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">                <span class="keyword">if</span>(_cnt-&gt;w &lt;<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">delete</span> _cnt;</span><br><span class="line">                    _cnt=<span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T * _ptr;</span><br><span class="line">        Counter * _cnt;<span class="comment">//两个引用计数，一个指向强指针，一个指向弱指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakPtr</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        WeakPtr():_ptr(<span class="literal">nullptr</span>), _cnt(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        ~WeakPtr()&#123;</span><br><span class="line">            _release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakPtr(WeakPtr&lt;T&gt; &amp; weakptr):_ptr(weakptr._ptr), _cnt(weakptr._cnt)&#123;</span><br><span class="line">            _cnt-&gt;w++;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">/*强指针拷贝构造弱指针，同样是指向相同的堆区空间，但是不增加shared_ptr的引用计数*/</span></span><br><span class="line">        WeakPtr(SharedPtr&lt;T&gt; &amp; sharedptr):_ptr(sharedptr._ptr), _cnt(sharedptr._cnt)&#123;</span><br><span class="line">            _cnt-&gt;w++;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//弱指针赋值给weak_ptr，不增加shared_ptr引用计数</span></span><br><span class="line">        WeakPtr &amp; <span class="keyword">operator</span>=(WeakPtr&lt;T&gt; &amp; weakptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;weakptr)&#123;</span><br><span class="line">                _release();</span><br><span class="line">                _ptr = weakptr._ptr;</span><br><span class="line">                _cnt = weakptr._cnt;</span><br><span class="line">                _cnt-&gt;w++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//强指针赋值给weak_ptr，不增加shared_ptr计数</span></span><br><span class="line">        WeakPtr &amp; <span class="keyword">operator</span>=(SharedPtr&lt;T&gt; &amp; sharedptr)&#123;</span><br><span class="line">            _release();</span><br><span class="line">            _ptr = sharedptr._ptr;</span><br><span class="line">            _cnt = sharedptr._cnt;</span><br><span class="line">            _cnt-&gt;w++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//弱指针提升为shared_ptr</span></span><br><span class="line">        <span class="function">SharedPtr&lt;T&gt; <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> SharedPtr&lt;T&gt;(*<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//判断该指针是否为空，即检测对象空间是否被释放</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">expired</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(_cnt &amp;&amp; _cnt-&gt;s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;empty &quot;</span>&lt;&lt;_cnt-&gt;s&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//friend class SharedPtr&lt;T&gt;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">void</span> _release()&#123;</span><br><span class="line">            <span class="keyword">if</span>(_cnt)&#123;</span><br><span class="line">                _cnt-&gt;w--;<span class="comment">//析构时weak_ptr计数-1</span></span><br><span class="line">                <span class="keyword">if</span>(_cnt-&gt;w &lt; <span class="number">1</span> &amp;&amp; _cnt-&gt;s &lt;<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">delete</span> cnt;</span><br><span class="line">                        _cnt=<span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T * _ptr;</span><br><span class="line">        Counter * _cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    WeakPtr&lt;Node&gt; _prev;</span><br><span class="line">    WeakPtr&lt;Node&gt; _next;</span><br><span class="line"></span><br><span class="line">    ~Node()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;delete :&quot;</span> &lt;&lt;<span class="keyword">this</span>&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">SharedPtr&lt;Node&gt; <span class="title">cur</span><span class="params">(<span class="keyword">new</span>(Node))</span></span>;</span><br><span class="line">    <span class="function">SharedPtr&lt;Node&gt; <span class="title">next</span><span class="params">(<span class="keyword">new</span>(Node))</span></span>;</span><br><span class="line">    cur-&gt;_next = next;<span class="comment">//next堆区空间的shared_ptr计数仍为1，weak_ptr计数也为1</span></span><br><span class="line">    next-&gt;_prev = cur;<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shared_ptr的代码主要做出了如下修改</p>
<ol>
<li>以前只有一个计数变量，然在变成了两个(成了一个计数器)，一个是SharedPtr本身的计数，另一个是WeakPtr的计数；</li>
<li><code>_ptr</code>和<code>_cnt</code>的释放都是在SharedPtr中完成的，WeakPtr不做具体的释放工作。</li>
</ol>
<p>​        当一个weak_ptr所观察的shared_ptr要释放它的资源时，它会把相关的weak_ptr的指针设置为空，防止weak_ptr持有悬空的指针。</p>
<p>​        weak_ptr并不拥有资源的所有权，所以不能直接使用资源。</p>
<p>​        weak_ptr并没有重载-&gt; 和 * 操作符，所以我们不能通过他来直接使用资源，我们可以通过lock来获得一个shared_ptr对象来对资源进行使用，如果引用的资源已经释放，lock()函数将返回一个存储空指针的shared_ptr。 所以我们要在使用前用expired函数用来判断资源是否失效。    </p>
<p>​        另外在WeakPtr中仅会对Counter对象的w字段操作，也就是说多个weak_ptr指向同一个堆空间时，<strong>仅操作Counter中的w字段。</strong></p>
<ol>
<li>weak_ptr虽然是一个模板类，但是不能用来直接创建指向堆区的对象。即不能单独使用</li>
<li>weak_ptr设计之初就是为了服务于shared_ptr的，所以不增加shared_ptr引用计数就是它的核心功能。</li>
<li>不允许weak_ptr到shared_ptr的转换</li>
<li>由于不知道什么之后weak_ptr所指向的对象就会被析构掉，所以使用之前请先使用expired函数检测一下。</li>
</ol>
<p><strong>一句话总结，weak_ptr这个辅助类就是专门为解决循环引用提出的，循环引用是想通过引用指针也可以访问shared_ptr记录的堆区空间，但是又不会增加shared_ptr的引用计数。</strong></p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>lambad其实就是一种匿名函数类型,基本形式如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture <span class="built_in">list</span>](parameter <span class="built_in">list</span>) <span class="keyword">mutable</span>-&gt; <span class="keyword">return</span> type &#123;statement&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>[capture list]：捕捉列表。捕捉列表总是出现在lambda函数的开始处。事实上，**[]是lambda引出符<strong>。编译器根据该引出符判断接下来的代码是否是lambda函数(**所以[]不可省略</strong>)。捕捉列表能够捕捉上下文中的变量以供lambda函数使用。</li>
<li>(parameters list)：参数列表。与普通函数的参数列表一致。如果不需要参数传递，则<strong>可以连同括号()一起省略。</strong></li>
<li>mutable：默认情况下，lambda函数总是一个const函数，即不能对其捕获的上下文变量修改，无论是值传递方式捕获还是引用传递方式捕获。mutable可以取消其常量性。在使用该修饰符时，**参数列表不可省略，即使参数为空，也要加()**，里面可以不写参数。</li>
<li><code>-&gt;return type</code>：返回类型。用追踪返回类型形式声明函数的返回类型。出于方便，<strong>不需要返回值的时候也可以连同符号-&gt;一起省略。</strong>此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。</li>
<li>{statement}：函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。不能省略</li>
</ul>
<p>语法上，<strong>捕捉列表由多个捕捉项组成</strong>，并以逗号分割。捕捉列表有如下几种形式：</p>
<p>❑ [var]表示值传递方式捕捉变量var。</p>
<p>❑ [=]表示值传递方式捕捉所有父作用域的变量（包括this）。</p>
<p>❑ [&amp;var]表示引用传递捕捉变量var。</p>
<p>❑ [&amp;]表示引用传递捕捉所有父作用域的变量（包括this）。</p>
<p>❑ [this]表示值传递方式捕捉当前的this指针。</p>
<p>通过一些组合，捕捉列表可以表示更复杂的意思。比如：</p>
<p>❑ [=, &amp;a, &amp;b]表示以引用传递的方式捕捉变量a和b，值传递方式捕捉其他所有变量。</p>
<p>❑ [&amp;, a, this]表示以值传递的方式捕捉变量a和this，引用传递方式捕捉其他所有变量。</p>
<p><strong>但是不可以对一个变量进行两次相同方式的捕获，如下</strong></p>
<p>❑ [=, a]这里=已经以值传递方式捕捉了所有变量，捕捉a重复。</p>
<p>❑ [&amp;, &amp;this]这里&amp;已经以引用传递方式捕捉了所有变量，再捕捉this也是一种重复。</p>
<p>下面是几个例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[]&#123;&#125;;  <span class="comment">//最简单的表达式</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	[a]()<span class="keyword">mutable</span> &#123;<span class="comment">//值传递捕获不会对捕获的母值修改</span></span><br><span class="line">		a++;<span class="comment">//有mutable才能对捕获的值进行修改</span></span><br><span class="line">	&#125;();<span class="comment">//这是个函数类型，如果想直接调用就可以在类型后面直接加参数就可以了 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">auto</span> f = [=]()<span class="keyword">mutable</span> -&gt;<span class="keyword">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;;<span class="comment">//自动推导出匿名函数类型</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; f() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        必须指出的是，依照现行C++11标准，在块作用域({}括住的就是块作用域)以外(比如全局作用域)的lambda函数<strong>捕捉列表必须为空</strong>，并且不能只以匿名函数形式存在(不能在全局作用域光秃秃的写一个lambda表达式)，一般需要auto func = lambda表达式。</p>
<p>​        而在块作用域中的lambda函数仅能捕捉父作用域中的自动变量，捕捉任何非父作用域或者是非自动变量（如静态变量等）都会导致编译器报错。在现行C++11标准中，捕捉列表仅能捕捉父作用域的自动变量，而对超出这个范围的变量，是不能被捕捉的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	[a] &#123;&#125;;<span class="comment">//error，不能捕获静态变量</span></span><br></pre></td></tr></table></figure>
<p>​        所有<strong>lambda在声明时就确定了初始状态，即声明时就将捕获的变量确定了，且拷贝的值不可被更改。之后的每次调用相同的lambda表达式时，他们的初始状态都是相同的。这一点主要针对值传递捕获</strong>，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> f1 = [a]&#123;<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;&#125;;<span class="comment">//值传递，声明时确定了a的值就是1，所以lambda表达式初始状态a = 1</span></span><br><span class="line">	<span class="keyword">auto</span> f2 = [&amp;a]&#123;<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">	a += <span class="number">1</span>;</span><br><span class="line">	f1();<span class="comment">//1，因为lambda初始状态已被确定</span></span><br><span class="line">	f2();<span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两点需要程序员注意之外，还有一点就是拷贝本身。这点跟函数参数按值方式传递是一样的，如果不想带来过大的传递开销的话，可以<strong>采用引用传递的方式传递参数。</strong></p>
<p>lambda函数可以看成仿函数的一种语法糖，而lambda的捕获列表就类似于仿函数类中成员变量。一般编译器会把lambda表达式转换成一个仿函数对象</p>
<h3 id="constexpr常量表达式"><a href="#constexpr常量表达式" class="headerlink" title="constexpr常量表达式"></a>constexpr常量表达式</h3><p><strong>所有constexpr对象都是const的，但是不是所有的const对象都是constexpr的。比如有const的类对象，但是const的类对象不是常量表达式</strong></p>
<h4 id="一-constexpr和常量表达式"><a href="#一-constexpr和常量表达式" class="headerlink" title="一. constexpr和常量表达式"></a>一. constexpr和常量表达式</h4><p>　　常量表达式（const expression）是指<strong>值不会改变</strong>并且在<strong>编译过程就能得到计算结果的表达式</strong>。显然，字面值属于常量表达式，用<strong>常量表达式初始化的const对象也是常量表达式。</strong></p>
<p>　　一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_files = <span class="number">20</span>;       <span class="comment">// max_files是常量表达式  </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> limit = max_files + <span class="number">1</span>;    <span class="comment">// limit是常量表达式  </span></span><br><span class="line"><span class="keyword">int</span> staff_size = <span class="number">27</span>;                <span class="comment">// staff_size不是常量表达式  </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sz = get_size();      <span class="comment">// sz不是常量表达式 </span></span><br></pre></td></tr></table></figure>

<p>　　尽管staff_size的初始值是个字面值常量，但由于它的数据类型只是一个普通int而非const int，所以它不属于常量表达式。另一方面，尽管sz本身是一个常量，但它的具体值直到运行时才能获取到，所以也不是常量表达式。</p>
<p>　　C++11新标准引出了关键字constexpr，constexpr可以用来修饰变量、函数、构造函数，这些我们都称为表达式。constexpr修饰一个表达式相当于告诉编译器这个表达式就是一个<strong>常量表达式(值不可修改)**，表达式的值编译期间就可以算出来，给编译器自信去优化，在编译期间计算出值。当然，</strong>常量表达式的值也确实要是编译期间能算出来的值。**</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf = <span class="number">20</span>;          <span class="comment">// 20是常量表达式  </span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> limit = mf + <span class="number">1</span>;   <span class="comment">// mf + 1是常量表达式  </span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sz = size();      <span class="comment">// 只有当size是一个constexpr函数时才是一条正确的声明语句 </span></span><br></pre></td></tr></table></figure>
<p>​        <strong>被constexpr修饰的变量类型必须有所限制</strong>，因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为”字面值类型”（literal type）。到目前为止接触过的数据类型中， 内置数据类型、引用和指针都属于字面值类型。自定义类Sales_item、IO库、string类型则不属于字面值类型，<strong>也就不能被定义成constexpr</strong>。</p>
<h4 id="二-constexpr修饰指针"><a href="#二-constexpr修饰指针" class="headerlink" title="二.constexpr修饰指针"></a>二.constexpr修饰指针</h4><p>​        尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。</p>
<p>　　值得一提的是，函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针。同样，允许函数定义一类有效范围超出函数本身的变量（即局部静态变量），这类变量和定义在函数体之外的变量一样也有固定地址。因此，constexpr引用能绑定到这样的变量上，constexpr指针也能指向这样的变量。</p>
<p>​        指针和constexpr必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">nullptr</span>;         <span class="comment">// p是常量的指针  </span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *q = <span class="literal">nullptr</span>;     <span class="comment">// q指针本身是个常量表达式，也就是指向不能改变</span></span><br></pre></td></tr></table></figure>

<p>　　p和q的类型相差甚远，p是一个指向常量的指针，而q是一个常量指针，其中的关键在于constexpr把它所定义的对象置为了顶层const。</p>
<p>​        与其他常量指针类似，constexpr指针既可以指向常量也可以指向一个非常量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *np = <span class="literal">nullptr</span>;    <span class="comment">// np是一个指向整数的常量指针，其值为空  </span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> i = <span class="number">42</span>;       <span class="comment">// i的类型是整型常量  </span></span><br><span class="line"><span class="comment">// i和j都必须定义在函数体之外  </span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;i;    <span class="comment">// p 是常量指针，指向整型常量i  </span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *p1 = &amp;j;         <span class="comment">// p1是常量指针，指向整数j </span></span><br></pre></td></tr></table></figure>
<h4 id="三-constexpr修饰函数"><a href="#三-constexpr修饰函数" class="headerlink" title="三.constexpr修饰函数"></a>三.constexpr修饰函数</h4><p>​        constexpr修饰的函数，简单的来说，如果其传入的参数可以在编译时期计算出来，那么这个函数就会产生编译时期的值，此时这个函数是<strong>常量表达式</strong>。但是，传入的参数如果不能在编译时期计算出来，那么constexpr修饰的函数就和普通函数一样了，此时不是常量表达式。所以constexpr修饰的函数可以是常量表达式，也可以不是。取决于你传入的值是否为常量表达式。(<strong>但是constexpr函数一定要有返回值</strong>)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> <span class="title">scale</span><span class="params">(<span class="keyword">size_t</span> cnt)</span></span>&#123;<span class="keyword">return</span> new_sz() * cnt;&#125;</span><br><span class="line"></span><br><span class="line">当形参cnt传递过来的是一个常量时，scale函数才会返回一个常量表达式。</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[scale(<span class="number">2</span>)];<span class="comment">//正确，返回的是一个常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">2</span>; <span class="keyword">int</span> a2[scale(i)];<span class="comment">//错误，传递的是非常量，所以函数也就不是常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> z =  scale(i);        <span class="comment">// error,传递的是非常量，所以函数是非常量表达式，而z是常量表达式，只能用常量表达式初始化</span></span><br></pre></td></tr></table></figure>
<p>​        constexpr函数在编译的过程中被隐式的指定为内联函数。</p>
<h2 id="常见的问题"><a href="#常见的问题" class="headerlink" title="常见的问题"></a>常见的问题</h2><h3 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h3><ul>
<li>new是C++关键字(new既是关键字也是运算符)，需要编译器支持，可以被重载；malloc是库函数</li>
<li>malloc需要指定分配内存块的大小，new不需要，直接指定分配元素的类型即可。</li>
<li>new做两件事，分别是分配内存(一般调用malloc)和调用类的构造函数，而malloc只是分配内存。</li>
<li>new返回的是所分配对象类型的指针，无需强制转换。而malloc返回的是void*类型的指针</li>
</ul>
<h3 id="内存泄漏和内存溢出"><a href="#内存泄漏和内存溢出" class="headerlink" title="内存泄漏和内存溢出"></a>内存泄漏和内存溢出</h3><ul>
<li>内存泄漏：是指程序在申请内存后，没有释放已申请的内存空间，那么这段内存无法再被使用，长此以往，内存将会被分配殆尽，造成内存溢出——即没有内存可被分配。</li>
<li>内存溢出：指程序申请内存时，没有足够的内存供申请者使用</li>
</ul>
<p><strong>所以内存泄漏的堆积最终会导致内存溢出</strong></p>
<h3 id="C-4种类型转换"><a href="#C-4种类型转换" class="headerlink" title="C++4种类型转换"></a>C++4种类型转换</h3><p>C++提供了四个转换运算符：</p>
<ul>
<li>const_cast <new_type>  (expression)</new_type></li>
<li>static_cast <new_type> (expression)</new_type></li>
<li>reinterpret_cast <new_type> (expression)</new_type></li>
<li>dynamic_cast <new_type> (expression)</new_type></li>
</ul>
<p><strong>static_cast</strong></p>
<p>类似C风格的强制转换，进行无条件转换，静态类型转换：</p>
<p>1）基类和子类之间的转换：其中子类指针转换为父类指针是安全的，但父类指针转换为子类指针是不安全的（基类和子类之间的动态类型转换建议用dynamic_cast）。</p>
<p>2）基本数据类型转换，enum，struct，int，char，float等。static_cast不能进行无关类型（如非基类和子类）指针之间的转换。</p>
<p>3）把任何类型的表达式转换成void类型。</p>
<p>4）static_cast不能去掉类型的const、volatile属性（用const_cast）。</p>
<p>注：</p>
<p>顶层const：表示指针本身是个常量。如：int *const p；</p>
<p>底层const：表示指针所指的对象是一个常量。如：int const *p；</p>
<p><strong>const_cast</strong></p>
<p>该运算符只能改变运算对象的底层const。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">int</span>&amp; b = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(a);</span><br><span class="line">	b = <span class="number">20</span>;<span class="comment">//段错误，因为全局作用域的const变量是放在.rodata节中的,不可修改</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;<span class="comment">//局部const变量放在栈上，const只是编译器层面限制，实际也是可以修改的</span></span><br><span class="line">	<span class="keyword">int</span>&amp; b = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(a);</span><br><span class="line">	b = <span class="number">20</span>;<span class="comment">//可以修改，但是属于未定义行为，因为去掉const，a本身也是属于常量，不能够修改</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//10 20，发生了常量折叠</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常量折叠：上面我们让b指向了a这段内存，对b的赋值确实也修改了这段内存的值。但是，在编译器编译时，编译器将所有输出a的地方，都将a替换成了立即数10，类似于宏替换。所以才会导致两个值不同。所以编译器是不希望我们修改const修饰的值，即使他们所在内存可以修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	const int a &#x3D; 1;</span><br><span class="line">006525E8  mov         dword ptr [a],1  </span><br><span class="line">	const int b &#x3D; 2;</span><br><span class="line">006525EF  mov         dword ptr [b],2  </span><br><span class="line">	const int c &#x3D; 3;</span><br><span class="line">006525F6  mov         dword ptr [c],3  </span><br><span class="line">	cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">006525FD  mov         esi,esp  </span><br><span class="line">006525FF  push        offset std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (06512A8h)  </span><br><span class="line">00652604  mov         edi,esp  </span><br><span class="line">00652606  push        3  		&#x2F;&#x2F;直接将const变量替换成了立即数3</span><br><span class="line">00652608  push        offset string &quot; &quot; (0659B30h)  </span><br><span class="line">0065260D  mov         ebx,esp  </span><br><span class="line">0065260F  push        2  </span><br><span class="line">00652611  push        offset string &quot; &quot; (0659B30h)  </span><br><span class="line">00652616  mov         eax,esp  </span><br><span class="line">00652618  push        1  </span><br><span class="line">0065261A  mov         ecx,dword ptr [__imp_std::cout (065D0D8h)]  </span><br></pre></td></tr></table></figure>


<p><strong>如果我们不想修改const变量的值，那我们又为什么要去const呢？</strong></p>
<p>原因是，我们可能调用了一个参数不是const的函数，而我们要传进去的实际参数确实const的，但是我们知道这个函数是不会对参数做修改的。于是我们就需要使用const_cast去除const限定，以便函数能够接受这个实际参数。</p>
<p><strong>3.dynamic_cast</strong></p>
<p>前提条件：当我们将dynamic_cast用于某种类型的指针或引用时，<strong>只有该类型含有虚函数时(实现多态)，才能进行这种转换。</strong>否则，编译器会报错。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dynamic_cast</span>运算符的调用形式如下所示：</span><br><span class="line"></span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;type*&gt;(e)  <span class="comment">//e是指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;type&amp;&gt;(e)  <span class="comment">//e是左值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;type&amp;&amp;&gt;(e)<span class="comment">//e是右值</span></span><br></pre></td></tr></table></figure>
<p>运行时类型识别（以区别以上三个均在编译时识别），用于<strong>将基类的指针或引用安全地转换成派生类的指针或引用。(即向下转型，因为向上转型总是成功)</strong></p>
<p>对指针进行dynamic_cast，失败返回null，成功返回正常cast后的对象指针；<br>对引用进行dynamic_cast，失败抛出一个异常bad_cast，成功返回正常cast后的对象引用。 </p>
<p>对于“向上转换”（即派生类指针或引用类型转换为其基类类型），<strong>无论是指针还是引用向上转换都是安全地</strong>。</p>
<p>对于“向下转型”有两种情况：</p>
<p>一种是基类指针所指对象是派生类类型的，这种转换是安全的；</p>
<p>另一种是基类指针所指对象为基类类型，在这种情况下dynamic_cast在运行时做检查，转换失败，返回结果为0；</p>
<p>在引用上，dynamic_cast依旧是常用于“安全的向下转型”。与指针一样，引用的向下转型也可以分为两种情况，与指针不同的是，并不存在空引用，所以引用的dynamic_cast检测失败时会抛出一个bad_cast异常。</p>
<p><strong>4、reinterpret_cast</strong></p>
<p>仅重新解释类型，但没有进行二进制的转换：</p>
<p>1）转换的类型必须是一个指针，应用、算术类型、函数指针或者成员指针。</p>
<p>2）在比特级别上进行转换，可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。但不能将非32bit的实例转成指针。<br>3） 最普通的用途就是在函数指针类型之间进行转换。<br>4） 很难保证移植性。</p>
<p><strong>总结</strong></p>
<p>去const属性用const_cast</p>
<p>基本类型转换用static_cast</p>
<p>多态类之间的类型转换用dynamic_cast</p>
<p>不同类型的指针类型转换用reinterpret_cast</p>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>http协议相当于web应用沟通的一种方式。传输的数据和沟通用的http报文都是以ASCII码格式的文件(明文传递)通过TCP作为传输层协议传输过去的，但是沟通用的http报文是有固定格式的。</p>
<p>1.HTTP协议主要用于web应用，是<strong>应用层协议</strong> 。HTTP协议一般用于B/S架构。浏览器作为HTTP客户端通过<strong>URL</strong>向HTTP服务端即WEB服务器发送所有请求。</p>
<p>2.HTTP是一个基于TCP协议来传递数据的协议(事先要建立TCP链接)。</p>
<p>3.WEB服务器与本地浏览器传输的文件称为web页面，web页面由对象组成。对象可以是<strong>HTML</strong>文件、图片、视频、音频文件。一般web页面包含一个基本的HTML文件，这个基本的HTML文件会引用其他对象，比如图片，文件。</p>
<p>4.http协议是无状态的</p>
<h3 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h3><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</p>
<ul>
<li>URI：Uniform Resource Identifier 统一资源<strong>标识</strong>符</li>
<li>URL：Uniform Resource Location 统一资源<strong>定位</strong>符</li>
</ul>
<p>URI 是用来<strong>标示</strong> 一个具体的资源的，我们可以通过 URI 知道一个资源是什么。 </p>
<p>URL 则是用来<strong>定位</strong>具体的资源的，标示了一个具体的资源位置。互联网上的每个文件都有一个唯一的URL。<code>URL</code>（统一资源定位符）是一种特殊种类的<code>URI</code>，包含了用于查找的资源的足够的信息，我们一般常用的就是<code>URL</code>，</p>
<h3 id="持续与非持续连接"><a href="#持续与非持续连接" class="headerlink" title="持续与非持续连接"></a><strong>持续与非持续连接</strong></h3><ol>
<li><p>非持续连接：每次建立TCP连接之后只通过http协议传递一个对象，传完就断开连接。所以多个对象需要建立多次连接</p>
</li>
<li><p>持续连接：建立一次TCP连接，可以传输多个对象</p>
<p>​        带流水线：收到一个对象之后才能才能发送下一个请求。</p>
<p>​        不带流水线：每遇到一个引用之后就立刻发出http请求，可以连续发出多个请求，服务器端也可以连续发送多个对象。</p>
</li>
</ol>
<p><strong>HTTP/1.1的默认模式使用带流水线的持久连接。</strong></p>
<h3 id="HTTP报文组成"><a href="#HTTP报文组成" class="headerlink" title="HTTP报文组成"></a><strong>HTTP报文组成</strong></h3><p><strong>请求报文构成</strong></p>
<ol>
<li>请求行：包括请求方法、URL、协议及版本</li>
<li>请求头，比如cookie，请求主机域名等信息。</li>
<li>请求正文(请求体)，可以发送用户登录用户名，密码等信息。</li>
</ol>
<p><strong>响应报文构成</strong></p>
<ol>
<li>状态行：协议及版本、状态码、短语</li>
<li>响应头</li>
<li>响应正文</li>
</ol>
<h3 id="常见请求方法"><a href="#常见请求方法" class="headerlink" title="常见请求方法"></a>常见请求方法</h3><ul>
<li>GET:请求指定的页面信息，返回页面实体。</li>
<li>POST:POST表示可能修改变服务器上的资源的请求 （例如提交表单或者上传文件）。数据被包含在请求体中。</li>
<li>PUT:从客户端向服务器传送的数据取代指定的文档的内容。</li>
<li>DELETE:请求服务器删除指定的页面。</li>
</ul>
<p><strong>post和get的区别：</strong></p>
<ul>
<li>都包含请求头请求行，get请求体为空，post请求body是要提交的内容。</li>
<li>get多用来查询，请求参数放在url中，不会对服务器上的内容产生作用。post用来提交，如把账号密码放入请求body中。</li>
<li>GET是直接添加到URL后面的，直接就可以在URL中看到内容，而POST是放在报文内部的，用户无法直接看到。</li>
<li>GET提交的数据长度是有限制的，因为URL长度有限制，具体的长度限制视浏览器而定。而POST没有。</li>
</ul>
<h3 id="http响应响应状态码"><a href="#http响应响应状态码" class="headerlink" title="http响应响应状态码"></a>http响应响应状态码</h3><p><strong>状态码分类</strong>：</p>
<ul>
<li>1XX- 信息型，表示服务器收到请求，需要请求者继续操作。</li>
<li>2XX- 成功型，表示请求成功收到，理解并处理。</li>
<li>3XX - 重定向，需要进一步的操作以完成请求。</li>
<li>4XX - 客户端错误，请求包含语法错误或无法完成请求。</li>
<li>5XX - 服务器错误，服务器在处理请求的过程中发生了错误。</li>
</ul>
<p><strong>常见状态码</strong>：</p>
<ul>
<li>200 OK - 客户端请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL，新的URL会放在响应报文的首部行中。</li>
<li>302 - 临时跳转</li>
<li>400 Bad Request - 客户端请求有语法错误，不能被服务器所理解</li>
<li>404 - 请求资源不存在，可能是输入了错误的URL。</li>
<li>500 - Internal Server Error：服务器内部发生错误，无法完成请求</li>
<li>503 Server Unavailable - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常。</li>
</ul>
<h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>http使用明文传输数据，很容易被抓包获取信息。所以引出了https</p>
<p>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL或TLS，通过 SSL证书来<strong>验证服务器的身份</strong>，<strong>并为</strong>浏览器和服务器之间的<strong>通信进行加密</strong>。</p>
<p>TLS和SSL的关系：并列关系。</p>
<p>SSL（Secure Socket Layer，安全套接字层）：SSL 协议位于传输层协议与各种应用层协议之间，为数据通讯提供安全支持。</p>
<p>TLS（Transport Layer Security，传输层安全）：其前身是 SSL，TLS是更为安全的升级版 SSL。由于 SSL 这一术语更为常用，因此我们仍然将我们的安全证书称作 SSL。</p>
<img src="/2021/04/02/%E5%AE%9E%E4%B9%A0%E5%87%86%E5%A4%87/image-20210401151301825.png" alt="image-20210401151301825" style="zoom:50%;">

<h3 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h3><p>​        <strong>对称加密</strong>：特点是文件加密和解密使用相同的密钥，运用对称加密有一个前提就是在发送信息前双方都必须知道加密的规则。</p>
<p>​        <strong>非对称加密：</strong>非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果将其中任意一把向外发布，那么这把就是公有密钥，为发布的就是私有密钥。用共有密钥加密的数据只能用对应的私有密钥解密。</p>
<p>​        非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。甲方只能用其专用密钥解密由其公用密钥加密后的任何信息。</p>
<p>​        对称加密解密的速度比较快，适合数据比较长时的使用。非对称加密和解密花费的时间长、速度相对较慢，只适合对少量数据的使用。</p>
<h3 id="通信加密（解决数据被窃取问题）"><a href="#通信加密（解决数据被窃取问题）" class="headerlink" title="通信加密（解决数据被窃取问题）"></a><strong>通信加密（解决数据被窃取问题）</strong></h3><p>​        因为HTTP不对通信内容进行加密处理，所以衍生了SSL加密技术协议，SSL采用<strong>混合加密</strong>（同时使用非对称加密和对称加密）的方式建立起安全的HTTP通信，经过加密后的内容即使被窃听了，窃听的人也无法解密对应的数据。</p>
<h3 id="数字证书（解决身份伪装问题）"><a href="#数字证书（解决身份伪装问题）" class="headerlink" title="数字证书（解决身份伪装问题）"></a><strong>数字证书（解决身份伪装问题）</strong></h3><p>​        HTTP不会对通信的双方进行进行身份的验证所以身份有可能被伪装造成安全问题，所以为了解决这个问题所以产生了数字证书，数字证书的使用流程大概如下：</p>
<p>1、服务器首先向一个大家都信任的第三方机构申请一个身份证书。</p>
<p>2、客户端向服务器建立通信之前首先向服务器请求获得服务器的证书。</p>
<p>3、服务器收到请求后把数字证书发送给客户端。</p>
<p>4、客户端获得服务器的证书之后，然后与可信任的第三方机构证书进行验证，验证通过后则进行正常的内容通信。</p>
<h3 id="数字签名（解决数据篡改问题）"><a href="#数字签名（解决数据篡改问题）" class="headerlink" title="数字签名（解决数据篡改问题）"></a><strong>数字签名（解决数据篡改问题）</strong></h3><p>Http不会对数据的完整性进行验证，这样会造成就算通信的过程中数据被别人恶意篡改了</p>
<p>，通信的双方也没办法知道，所以就有了数字签名技术。</p>
<p>数字签名主要有两个作用，一是验证数据是否为意料中的对象所发出的，二是对数据的完整性进行验证，验证数据是否被篡改过：</p>
<p>1、对需要发送的数据进行摘要</p>
<p>对数据进行摘要主要目的是确认数据的完整性，发送方首先根据约定的哈希算法把数据进行哈希，得到一个哈希值，因为两个数据有任何一点不相同都会得出不同的哈希值，所以把对数据内容进行哈希得到哈希值作为数据的摘要发给对方；</p>
<p>然后对方收到数据后，首先自己也按照约定的哈希算法把接收到的数据内容进行哈希得到一个哈希值，然后把自己的哈希值与发送过来的摘要信息进行比对，根据哈希值是否一致来确认数据的完整性。</p>
<p>2、对摘要信息进行签名</p>
<p>对摘要进行签名的目的主要是对确认数据发送人的身份，签名技术是使用非对称加密的原理，</p>
<p>非对称加密是使用一个密钥对（一个公钥，一个私钥），公钥加密只能由私钥解密，私钥加密只能由公钥解密； 公钥是公布出来的密钥，私钥由自己安全保管不外泄，所以在私钥不泄漏情况下，我们通过私钥其实就可以确认发送数据方的身份。</p>
<p>那么我们想要对A发送过来的数据进行身份验证，那么我们只需要用A的公钥对数据进行解密即可（如果可以解密，那么就说明该数据是A用自己的私钥进行加密过的，而A的私钥又只有A自己拥有）</p>
<h3 id="HTTPS通信流程"><a href="#HTTPS通信流程" class="headerlink" title="HTTPS通信流程"></a><strong>HTTPS通信流程</strong></h3><p>HTTPS通信主要包括几个节点，发起请求、验证身份、协商秘钥、加密会话</p>
<p>1、客户端向服务端发起建立HTTPS请求。</p>
<p>2、服务器向客户端发送数字证书。</p>
<p>3、客户端验证数字证书，证书验证通过后客户端生成会话密钥（双向验证则此处客户端也会向服务器发送证书）。</p>
<p>4、服务器生成会话密钥（双向验证此处服务端也会对客户端的证书验证）。</p>
<p>5、客户端与服务端开始进行加密会话。</p>
<h4 id="第一步：客户端向服务端发起请求"><a href="#第一步：客户端向服务端发起请求" class="headerlink" title="第一步：客户端向服务端发起请求"></a><strong>第一步：客户端向服务端发起请求</strong></h4><p>（1）客户端生成随机数R1 发送给服务端；</p>
<p>（2）告诉服务端自己支持哪些加密算法；</p>
<h4 id="第二步：服务器向客户端发送数字证书"><a href="#第二步：服务器向客户端发送数字证书" class="headerlink" title="第二步：服务器向客户端发送数字证书"></a><strong>第二步：服务器向客户端发送数字证书</strong></h4><p>（1）服务端生成随机数R2;</p>
<p>（2）从客户端支持的加密算法中选择一种双方都支持的加密算法（此算法用于后面的会话密钥生成）;</p>
<p>（3）服务端生成把证书、随机数R2、会话密钥生成算法，一同发给客户端;</p>
<h4 id="第三步：客户端验证数字证书。"><a href="#第三步：客户端验证数字证书。" class="headerlink" title="第三步：客户端验证数字证书。"></a><strong>第三步：客户端验证数字证书。</strong></h4><p>（1）验证证书的可靠性，先用CA的公钥解密被加密过后的证书,能解密则说明证书没有问题，然后通过证书里提供的摘要算法进行对数据进行摘要，然后通过自己生成的摘要与服务端发送的摘要比对。</p>
<p>（2）验证证书合法性，包括证书是否吊销、是否到期、域名是否匹配，通过后则进行后面的流程</p>
<p>（3）获得证书的公钥、会话密钥生成算法、随机数R2</p>
<p>（4）生成一个随机数R3。</p>
<p>（5）根据会话秘钥算法使用R1、R2、R3生成会话秘钥。</p>
<p>（6）用服务端证书的公钥加密随机数R3并发送给服务端。</p>
<h4 id="第四步：服务器得到会话密钥"><a href="#第四步：服务器得到会话密钥" class="headerlink" title="第四步：服务器得到会话密钥"></a><strong>第四步：服务器得到会话密钥</strong></h4><p>（1）服务器用私钥解密客户端发过来的随机数R3</p>
<p>（2）根据会话秘钥算法使用R1、R2、R3生成会话秘钥</p>
<h4 id="第五步：客户端与服务端进行加密会话"><a href="#第五步：客户端与服务端进行加密会话" class="headerlink" title="第五步：客户端与服务端进行加密会话"></a><strong>第五步：客户端与服务端进行加密会话</strong></h4><p>（1）客户端发送加密数据给服务端</p>
<p>发送加密数据：客户端加密数据后发送给服务端。</p>
<p>（2）服务端响应客户端</p>
<p>解密接收数据：服务端用会话密钥解密客户端发送的数据；</p>
<p>加密响应数据：用会话密钥把响应的数据加密发送给客户端。</p>
<p>（3）客户端解密服务端响应的数据</p>
<p>解密数据：客户端用会话密钥解密响应数据；</p>
<h2 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h2><p>暂时看不进去，不看了</p>
<h2 id="输入URL发生了什么"><a href="#输入URL发生了什么" class="headerlink" title="输入URL发生了什么"></a>输入URL发生了什么</h2><p>当用户在浏览器中输入域名并按下回车键后</p>
<ol>
<li>浏览器会解析URL获得主机名、端口号、协议类型、资源路径等，确定是HTTP协议之后准备利用解析出来得信息依次生成http请求报文和TCP同步报文段。</li>
<li>根据域名获取ip地址。浏览器会检查缓存中有没有这个域名对应的解析过的IP地址，如果有，这个解析过程就结束了，直接拿到IP进行访问。这个浏览器缓存域名是有限制的，除了缓存大小有限制，缓存的时间也有限制，通常情况下由TTL属性来设置。</li>
<li>如果用户浏览器缓存中没有，浏览器会查找操作系统中是否有这个域名对应的DNS解析结果。windows中c:/windows/system32/drivers/etc/hosts文件设置，linux中/etc/hosts文件中设置。当解析到这个配置文件中的某个域名时，操作系统会在缓存中缓存这个解析结果。（修改文件后不立即生效的原因）</li>
<li>当前面两步都不能解析时，操作系统会把这个域名发送给设置的DNS服务器（简称LDNS）-local缩写，一般是本地区的域名服务器也可以是自己设置的域名服务器地址，如果命中，那解析就此结束并返回IP并标记为<strong>非权威服务器的应答</strong>。如是学校的互联网，那么你的DNS服务器肯定在你的学校，如果你是一个小区接入互联网，那这个DNS就是提供给你接入互联网的应用供应商，即电信或联通。windows中能用ipconfig查看DNS服务器地址，linux中cat /etc/resolv.conf查看DNS Server。<strong>这个过程都是调用解析器函数，如gethostbyname完成得。</strong></li>
<li>如果LDNS没有命中，LDNS就会向Root Server域名服务器请求解析。LDNS会从<strong>配置文件</strong>里面读取13个根域名服务器的地址（这些地址是不变的，直接在BIND的配置文件中），然后像其中一台发起请求。</li>
<li>根服务器拿到这个请求后，知道他是com.这个顶级域名下的，所以就会返回com.域中的NS记录，一般来说是13台主机名和IP（主域名服务器地址即gTLD-国际顶级域名服务器地址），返回给本地域名服务器即LDNS，</li>
<li>LDNS再向上一步返回的其中一台gTLD服务器发送请求。com.域的服务器（gTLD）发现你这请求是baidu.com这个域的，一查发现了这个域的NS（一般就是你注册的域名服务器），那就返回给你，你再去查。</li>
<li>LDNS接受gTLD返回的域服务器地址（即域名服务提供商的域服务器）并向其中一台再次发起请求，在baidu.com的域下面查了下有www的这台主机，就把这个IP返回给你了。</li>
<li>LDNS接受返回的IP和TLL值</li>
<li>LDNS缓存这个域名和IP的对应关系，缓存时间有TLL控制</li>
<li>LDNS把解析的结果返回给用户，用户根据TLL值缓存在本地系统缓存中，域名解析结束。</li>
<li>根据解析出来的IP地址创建将TCP同步报文段封装成IP数据报。</li>
<li>根据目的IP地址查询本地路由表获得下一跳IP地址</li>
<li>根据下一跳IP地址查找ARP缓存获得下一跳主机的MAC地址。如果ARP缓存没有，则使用ARP协议根据下一跳设备的IP地址来获取对应的MAC地址</li>
<li>然后封装成帧发送出去。</li>
<li>最终同步报文段会发送到服务器端，然后开始剩下的两次握手，建立TCP连接。</li>
<li>发送HTTP请求报文请求数据</li>
<li>服务器端发送http响应报文，然后再发送请求的web文件。</li>
<li>接着通信</li>
<li>通信完四次挥手断开TCP连接</li>
</ol>
<h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h2><p><strong>连接方面区别</strong></p>
<ul>
<li><strong>TCP</strong>:有连接，提供可靠传输服务，保证传输的数据无差错，不丢失，不重复，且按序到达。</li>
<li><strong>UDP</strong>：无连接，尽最大努力交付，即不保证可靠交付。</li>
</ul>
<p><strong>传输效率的区别</strong></p>
<ul>
<li>TCP传输效率相对较低。</li>
<li>UDP传输效率高。</li>
</ul>
<p><strong>连接对象数量的区别</strong></p>
<ul>
<li>TCP连接只能是点到点、一对一的。</li>
<li>UDP支持一对一，一对多，多对一和多对多的交互通信。</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>UDP：<strong>面向报文</strong>，适用于对实时性有较高的通信；eg: 实时视频会议等。</li>
<li>TCP: <strong>面向字节</strong>，对数据准确性要求高，速度可以相对较慢的。eg: 文件传输、邮件的发送与接收等。</li>
</ul>
<p>TCP首部20B，UDP首部8B</p>
<h3 id="TCP的若干问题"><a href="#TCP的若干问题" class="headerlink" title="TCP的若干问题"></a>TCP的若干问题</h3><p>TCP保证可靠传输</p>
<p><strong>TCP协议保证数据传输可靠性的方式主要有：</strong></p>
<ul>
<li>校验和</li>
<li>确认应答与序列号</li>
<li>超时重传:发送一个报文段就为这个报文段创建一个定时器，如果定时器超时就重传该数据。</li>
<li>流量控制:发送方发送速率过快时，接收方可以在确认报文段中填入接收窗口大小来限制发送发发送速率。</li>
<li>拥塞控制：</li>
</ul>
<p>1.慢开始加拥塞避免<br>        每过一个RTT，就将拥塞窗口变为以前的两倍，直到拥塞窗口变为threshold，开始加法增大(这个阶段叫拥塞避免)。直到超时发生拥塞，将拥塞窗口变为1，设置新threshold为发生拥塞时拥塞窗口的一半。然后继续慢开始算法</p>
<p>2.快重传和快恢复<br>        前面也是慢开始+加法增大，快重传是指当连续收到3个重复确认报文段时，认为拥塞发生。设置新threshold为发生拥塞时拥塞窗口的一半，快恢复是把拥塞窗口也设置为原先threshold的一半， 然后执行拥塞避免算法(加法增大)，使拥塞窗口缓慢增大。</p>
<p>服务器端为什么需要<code>TIME__WAIT</code>状态？</p>
<ol>
<li>客户端关闭之后，就可以把原先客户端的端口号再分配出去了，但是新的客户端进程用了这个端口号会接收到原先连接的客户端发来的信息(比如因为网络延迟比服务器端FIN报文段晚到的携带数据的报文段)。新的连接肯定无法处理。为了防止这种情况，我们需要<code>TIME__WAIT</code>状态，这个状态客户端的端口号不能再被分配出去，也就是不能被占用。</li>
<li><code>TIME__WAIT</code>状态的时间时2MSL，2MSL之后网络上绝对没有原先连接的任何报文段数据了。所以新的连接不用担心有原先连接的报文段数据发过来了</li>
</ol>
<h1 id="Linux服务器编程"><a href="#Linux服务器编程" class="headerlink" title="Linux服务器编程"></a>Linux服务器编程</h1><h2 id="Linux指令操作"><a href="#Linux指令操作" class="headerlink" title="Linux指令操作"></a>Linux指令操作</h2><p>1.Linux中查看cpu和内存的占用率怎么看？使用top命令</p>
<p><img src="/2021/04/02/%E5%AE%9E%E4%B9%A0%E5%87%86%E5%A4%87/image-20210401235508373.png" alt="image-20210401235508373"></p>
<p>2.Linux中ps -aux是什么意思？</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>显示所有进程（包括其他用户的进程）</td>
</tr>
<tr>
<td>u</td>
<td>用户以及其他详细信息</td>
</tr>
<tr>
<td>x</td>
<td>显示没有控制终端的进程</td>
</tr>
</tbody></table>
<h2 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h2><h3 id="管道-匿名管道-通信"><a href="#管道-匿名管道-通信" class="headerlink" title="管道(匿名管道)通信"></a>管道(匿名管道)通信</h3><ul>
<li>使用pipe函数创建的管道都称为<strong>匿名管道</strong>,所以一般pipe都指匿名管道</li>
<li>匿名管道通信主要是父进程先创建管道文件，然后fork，那么父子进程就会共享相同的文件描述符指针，这样才能共享</li>
</ul>
<p>​        管道(pipe)是一种最基本的 IPC 机制， 作用于**有血缘关系(主要是父子进程，比如两个bash创建的进程之间就没有血缘关系)**的进程之间 ，完成数据传递。调用 pipe 系统函数即可创建 一个管道。有如下特质：</p>
<ul>
<li><p>其本质是一个伪文件 实为内核缓冲区 )</p>
</li>
<li><p>由两个文件描述符引用，一个表示读端，一个表示写端。</p>
</li>
<li><p>规定数据从管道的写端流入管道，从读端流出。</p>
</li>
</ul>
<p>管道的原理 : 管道实为内核使用<strong>环形队列</strong>(队列只能一端写一端读)机制，借助内核缓冲区实现。</p>
<p>管道的局限性：<br>① 数据不能进程自己写入之后，再由自己读出。必须由其他进程读出<br>② 管道中数据不可反复读取。一旦读走，管道中不再存在。<br>③ 采用半双工通信方式，数据同一时刻只能在单方向上流动。</p>
<h3 id="FIFO-命名管道"><a href="#FIFO-命名管道" class="headerlink" title="FIFO(命名管道)"></a>FIFO(命名管道)</h3><p>​        FIFO常被称为命名管道，以区分管道(pipe) 。pipe只能 用于“有血缘关系”的进程间。但通过 FIFO ,<strong>不相关的进程也能交换数据。</strong>但是FIFO同样也只能半双工通信？<strong>这个我目前不确定</strong>，并且<strong>符合数据读完就消失得特点(这个特点记住就可以)**。(**除了读写方式，其他都和pipe一样，所以也可以一个读端多个写端、一个写端多个读端</strong>)<br>​        FIFO 是 Linux 基础文件类型中的一种 。但， <strong>FIFO 文件在磁盘上没有数据块</strong>，<strong>仅仅一个文件标识符来标识内核中一段内存(目前知道FIFO本质上也是内存就可以了)。</strong>各进程可以打开这个文件进行 read /write 实际上是在读写内核通道 ，这样就实现了进程间通信。</p>
<p>​        一旦使用 mkfifo 创建了一个 FIFO 就可以使用 open 打开它，常见的文件 I/O 函数都可用于 fifo 。如 close 、 read 、write 、 unlink 等 。</p>
<p>​        <strong>操作时我们就可以直接把FIFO文件当作一个普通文件，使用open打开，然后用read/write一端读这个文件，一端写这个文件就可以实现通信了</strong></p>
<p>​        <strong>但是管道文件必须事先存在，即被创建好</strong></p>
<h3 id="共享存储映射-mmap"><a href="#共享存储映射-mmap" class="headerlink" title="共享存储映射(mmap)"></a>共享存储映射(mmap)</h3><h3 id="存储映射I-O"><a href="#存储映射I-O" class="headerlink" title="存储映射I/O"></a>存储映射I/O</h3><p>​        存储映射 I/O (Memory mapped I / O) 使一个<strong>磁盘文件</strong>与存储空间中的一个<strong>缓冲区</strong>相映射 。 于是当从缓冲区中取数据就相当于读文件中的相应字节 。与此类似，将数据存入缓冲区则相应的字节就自动写入文件 。 这样,就可在不使用read 和 write 函数的情况下，<strong>使用地址</strong> （指针）对内存缓冲区读写来完成 I/O 操作。</p>
<p>​    使用这种方法 <strong>首先要创建一个用来映射的文件</strong>，然后通知内核将指定文件映射到存储区域中 。这个映射工作可以通过 mmap 函数来实现 。</p>
<img src="/2021/04/02/%E5%AE%9E%E4%B9%A0%E5%87%86%E5%A4%87/image-20210316200642741.png" alt="image-20210316200642741" style="zoom:67%;">



<h2 id="僵尸进程与孤儿进程"><a href="#僵尸进程与孤儿进程" class="headerlink" title="僵尸进程与孤儿进程"></a>僵尸进程与孤儿进程</h2><p><strong>僵尸进程</strong></p>
<p>​        一个子进程结束运行时，父进程未能正确回收，这个子进程就是僵尸进程。<strong>子进程已经结束运行了，但是父进程没有回收(未使用wait或者waitpid)，子进程残留的PCB就属于僵尸进程，如果父进程结束，这个僵尸子进程会托管给init进程，由init进程收尸，如果父进程一直不结束，僵尸进程就一直存在，占用资源</strong>。任何一个子进程(init除外)在exit()之后，并非马上就消失掉，还残留一个PCB资源未被回收，等待父进程回收处理。这是每个子进程在结束时都要经过的阶段。如果子进程在exit()(<strong>或者其他方式终止之后</strong>)之后，父进程没有来得及处理，那么保留的那段信息就不会释放，其进程号和PCB就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免</p>
<p><strong>孤儿进程</strong></p>
<p>​        父进程先于子进程结束(<strong>父进程结束之前子进程还在运行</strong>)，则子进程成为孤儿进程。此时子进程被init进程(pid为1)收养，称为 init 进程领养孤儿进程。<strong>孤儿进程还是一个在运行的、活的进程</strong></p>
<h2 id="epoll、select、poll（优点、缺点、实现）"><a href="#epoll、select、poll（优点、缺点、实现）" class="headerlink" title="epoll、select、poll（优点、缺点、实现）"></a>epoll、select、poll（优点、缺点、实现）</h2><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="红黑树和AVL树"><a href="#红黑树和AVL树" class="headerlink" title="红黑树和AVL树"></a>红黑树和AVL树</h2><p>1、红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。</p>
<p>2、平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。</p>
<h1 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h1><h2 id="从boot到解析内核文件"><a href="#从boot到解析内核文件" class="headerlink" title="从boot到解析内核文件"></a>从boot到解析内核文件</h2><ol>
<li>从引导盘CHS格式下的1号扇区读取MBR到0x7c00,再跳转到0x7c00处开始执行</li>
<li>MBR将loader读取到0x900处。读取磁盘主要是向IDE0口的命令寄存器发送命令，然后查看状态寄存器，准备完毕后再读取数据。然后再跳转到loader中执行，我们设置好的loader的入口地址是0xc00</li>
<li>利用bios的0x15号中断读取内存布局，并存储到0xb00处。将来管理内存池时要用到</li>
<li>打开A20，开启保护模式(设置CR0最低位为1)，lgdt，刷新流水线(流水线中存放着16位的指令)。</li>
<li>将内核读取到0x70000处。</li>
<li>设置内核页目录表和页表。页目录表放在物理地址0x10000处，0x10100是内核第一个页表的起始地址。0 768 PDE设置相同的内容，都是0x10100的这个页表。769~1022PDE依次对应于0x10200开始的页表。1023PDE就是页目录表本身的物理页框。将页目录表起始物理地址放到CR3中，然后开启分页(CR0的最高位)，开启分页后，地址就成了虚拟地址(线性地址)。</li>
<li>解析内核，根据ELF程序头表的信息，将每个segment放置到为其分配的虚拟地址中去。</li>
<li>跳转到内核程序的入口地址0xc0001500。链接时-Ttext 0xc0001500设置的选项</li>
</ol>
<p>PTE高20位是物理页框，低12位是属性。主要有U/S位和P位。</p>
<h2 id="初始化PIC-可编程中断控制器"><a href="#初始化PIC-可编程中断控制器" class="headerlink" title="初始化PIC(可编程中断控制器)"></a>初始化PIC(可编程中断控制器)</h2><p>我们初始化的是8259A芯片，8259A可以级联，个人计算机只有2片8259A，主片的IRQ7口连着从片</p>
<img src="/2021/04/02/%E5%AE%9E%E4%B9%A0%E5%87%86%E5%A4%87/image-20210406135150378.png" alt="image-20210406135150378" style="zoom:67%;">

<p>8259A的中断请求信号通过8259A的INT口发送到CPU的INTR口，CPU的INTA口会发送中断响应信号到8259A的INTA口。中断请求信号都是通过控制总线发的，中断向量号是通过数据总线发的。</p>
<p><strong>8259A的工作流程：</strong></p>
<ol>
<li>各个IRQ口接收到中断请求,经过IMR筛选后放到IRR中(每个IRQ口对应到寄存器中的一位)</li>
<li>再由PR(优先级仲裁器)进行中断判优。默认是IRQ0~IRQ7优先级依次下降</li>
<li>中断判优之后选出的中断请求信号通过INT发送给CPU的INTR口</li>
<li>CPU发出中断响应信号给8259A(INTA-&gt;INTA),8259A设置ISR对应位为1，表示该中断请求正在接收服务。</li>
<li>8259A再发送中断向量号给CPU</li>
<li>若为手工EOI模式接着中断处理程序会发送EOI信号给8259A(主片和从片都要发)，表示中断处理完毕，将ISR对应位置为0。</li>
</ol>
<p><strong>初始化8259A</strong></p>
<p>8259A有两个寄存器组，初始化命令寄存器组(ICW1<del>ICW4)和操作命令寄存器组(OCW1</del>OCW3)。</p>
<p>ICW1~ICW4的初始化顺序必须按序进行</p>
<ol>
<li>ICW1：设置8259A连接方式，单片还是多片级联</li>
<li>ICW2：设置起始中断向量号</li>
<li>ICW3：级联时设置主片的那个IRQ口连接从片</li>
<li>ICW4：可以设置结束中断是手动还是自动方式</li>
</ol>
<p>OCW1的设置顺序可以乱序</p>
<ol>
<li>OCW1：即中断屏蔽字，会送到IMR中</li>
<li>OCW2：设置优先级模式</li>
</ol>
<p><strong>中断门描述符</strong></p>
<p>有中断处理程序的选择子和偏移量。还有这个门描述符的DPL，这个DPL是能访问这个门描述符的最低特权级。</p>
<p>8253也就是定时计数器</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>我们将整个的物理内存平分为物理内存池和用户内存池两部分。内核虚拟内存池</p>
<h3 id="连续物理页的分配"><a href="#连续物理页的分配" class="headerlink" title="连续物理页的分配"></a>连续物理页的分配</h3><p>我们采用位图来管理连续物理页的分配，每一位对应一个物理页框。采用首次适应算法。即从头开始扫描。连续物理页分配之后需要在页表中建立映射，</p>
<h3 id="小块内存的分配"><a href="#小块内存的分配" class="headerlink" title="小块内存的分配"></a>小块内存的分配</h3><p>将一个物理页看作一个arena，即小块内存仓库，内存仓库中所有的内存块大小相同。物理页起始地址处是arena元信息。记录内存块描述符的起始地址。还有这个arena可用的剩余内存块数量。arena的空闲内存块都挂在这个内存块描述符的空闲队列上</p>
<h2 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h2><p>TSS用来记录当前任务的内核栈偏移量，当发生中断时涉及到特权级切换时会从TSS中取得内核栈的首地址</p>
<h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><h2 id="键盘、磁盘驱动"><a href="#键盘、磁盘驱动" class="headerlink" title="键盘、磁盘驱动"></a>键盘、磁盘驱动</h2><h3 id="磁盘驱动"><a href="#磁盘驱动" class="headerlink" title="磁盘驱动"></a>磁盘驱动</h3><p>​        一般的主板有2个IDE通道，我们要用数据结构记录每个通道的寄存器的起始端口号，以及本通道的中断向量号(IDE0是IRQ14——vec_no是14 + 0x20，IDE1是IRQ15——vec_no是15 + 0x20)，我们为每个通道都注册一个中断处理程序(一个通道的两个磁盘发出的中断信号相同)。</p>
<p><strong>从硬盘读写数据的步骤</strong></p>
<ol>
<li>向给定通道设置好寄存器状态字，如读写的起始扇区、扇区数、哪个磁盘。</li>
<li>发送读或写命令给对应寄存器</li>
<li>将自己阻塞，换下CPU。直到磁盘发来中断信号，说明磁盘准备完毕，由磁盘中断处理程序将该进程唤醒。</li>
<li>进程开始读写数据</li>
</ol>
<p>注意每个通道有两个磁盘，所以我们要保证对通道的互斥访问。不能先访问主盘，将寄存器对应位设置为0，然后访问从盘，又将寄存器对应位改为0。当主盘发出中断请求信号时，此时却读的是寄存器中的从盘。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="格式化分区——创建文件系统"><a href="#格式化分区——创建文件系统" class="headerlink" title="格式化分区——创建文件系统"></a>格式化分区——创建文件系统</h3><p>每个分区对应一个文件系统，每个文件系统有一个超级块，这个超级块记录这个文件系统的元信息。</p>
<img src="/2021/04/02/%E5%AE%9E%E4%B9%A0%E5%87%86%E5%A4%87/image-20210406161005153.png" alt="image-20210406161005153" style="zoom:67%;">

<p>我们初始化文件系统需要</p>
<ol>
<li>根据从分区中读取的扇区数，计算出该分区可用的数据块的数量以及各个元信息的数据。</li>
<li>内存中创建超级块，将上面计算好的元信息写入到超级块中。(<strong>超级块中有一个魔数，标识该分区是否有文件系统</strong>)</li>
<li>将超级块写入分区的1号扇区——LBA格式</li>
<li>将其他元信息写入磁盘上对应位置</li>
<li>将根目录写入磁盘，根目录就放在空闲数据块的第一块中。inode数据的第0个元素就是根目录的inode。</li>
</ol>
<p><img src="/2021/04/02/%E5%AE%9E%E4%B9%A0%E5%87%86%E5%A4%87/../../application/Typora%E5%9B%BE%E7%89%87%E5%8C%85/typora-user-images/image-20210406170335139-1617898658557.png" alt="image-20210406170335139"></p>
<p><strong>什么是inode：</strong></p>
<p>inode就是描述一个文件在磁盘中存储属性的结构体，块指针就是每个块的起始扇区号。</p>
<img src="/2021/04/02/%E5%AE%9E%E4%B9%A0%E5%87%86%E5%A4%87/image-20210406192928281.png" alt="image-20210406192928281" style="zoom:67%;">

<p>目录文件和普通的数据文件的区别就在于文件数据块中的内容，目录文件的数据块中是一个个的目录项。每个目录项记录一个文件的inode号、文件名、类型。</p>
<img src="/2021/04/02/%E5%AE%9E%E4%B9%A0%E5%87%86%E5%A4%87/image-20210406193318782.png" alt="image-20210406193318782" style="zoom:67%;">

<h3 id="挂载分区-文件系统"><a href="#挂载分区-文件系统" class="headerlink" title="挂载分区(文件系统)"></a>挂载分区(文件系统)</h3><pre><code>     我们这里不像mount命令将某个分区挂载到默认分区的某个目录下。一般安装OS，都是先选择挂在到哪个分区中，然后对这个分区用某种文件系统进行格式化。最后将OS安装到这个文件系统的磁盘中。</code></pre>
<p>​        挂载文件系统的本质就是把文件系统的元信息(<strong>超级块</strong>，<strong>空闲块位图</strong>，<strong>inode位图</strong>)读到内存，这样硬盘资源的变化都可以用内存中的元信息来跟踪，</p>
<h3 id="进程读写文件"><a href="#进程读写文件" class="headerlink" title="进程读写文件"></a>进程读写文件</h3><p>一个进程读写文件的基本步骤</p>
<ol>
<li>通过进程文件描述符表的文件描述符的内容定位到所打开文件在打开文件表中的下标。</li>
<li>打开文件表中会有对应文件的inode的指针，这个文件的inode会在内存中</li>
<li>通过inode我们可以找到磁盘文件的内容</li>
</ol>
<img src="/2021/04/02/%E5%AE%9E%E4%B9%A0%E5%87%86%E5%A4%87/image-20210406215449587.png" alt="image-20210406215449587" style="zoom:67%;">

<p>​        每个文件可以被多个进程多次打开，每次打开都是占用一个打开文件表表项。打开文件表表项中会记录当前这个打开文件的读写位置。但是同一个文件的表项中的inode指针都指向inode全局队列中的同一个inode节点。</p>
<p>​        一个分区所有打开的文件的inode都在这个分区结构的全局队列中，这个全局队列在内核空间中，是所有进程、线程共享的。 当查找与i个inode，发现不在时，要将其读入到内核空间，加入到全局队列中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint32_t</span> fd_pos;      <span class="comment">// 记录当前文件操作的偏移地址,以0为起始,最大为文件大小-1</span></span><br><span class="line">   <span class="keyword">uint32_t</span> fd_flag;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">fd_inode</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="进程创建文件"><a href="#进程创建文件" class="headerlink" title="进程创建文件"></a>进程创建文件</h3><ol>
<li>创建一个新的inode</li>
<li>为文件分配一个空闲数据块</li>
<li>将空闲数据块起始扇区记录到inode中</li>
<li>在文件所在目录的数据块中添加一个目录项</li>
<li>将信息同步到磁盘</li>
</ol>
<h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><h3 id="fork的实现"><a href="#fork的实现" class="headerlink" title="fork的实现"></a>fork的实现</h3><p>父进程fork出子进程主要是将父进程的所有资源复制一份，包括PCB、程序体(代码和数据)、用户栈、页目录表、页表。</p>
<p><strong>1.为子进程创建页目录表</strong></p>
<p><strong>2.复制PCB</strong></p>
<ol>
<li>将父进程的PCB复制给子进程的PCB，为子进程重新分配pid，重新设置可运行时间片(加满)，为子进程PCB的内存块描述符数据初始化(否则继承自父进程，还是父进程的虚拟地址，访问会导致缺页异常)</li>
<li>为子进程的虚拟地址池结构进行初始化，为子进程在内核空间重新分配一片内存作为管理其虚拟地址池的位图。注意是在内核空间申请的，所以</li>
</ol>
<p><strong>3.复制程序体和用户栈</strong></p>
<p>​        先将父进程的页目录表和页表复制一份。</p>
<p>​        将父进程用户空间(0~3G)中所有被占用的页(P位为1)都复制到子进程中(所以要扫描父进程的用户虚拟地址池位图，看哪一页被占用)，注意复制过来时，子进程需要重新申请物理页框，然后将物理页框和PTE建立映射建立映射。因为父子进程有不同的页目录表。所以我们先把父进程被使用的页复制到内核区域的一个缓冲区(占一页)，然后再把内核缓冲区的数据复制到子进程中。</p>
<p><strong>4.在子进程PCB中构造新的中断栈，将子进程中断栈中eax设置为0，子进程的返回值</strong></p>
<p><strong>5.更新子进程文件描述符表中除3个标准文件以外文件的打开次数(+1)</strong></p>
<p>父进程fork的返回值为子进程的pid值</p>
<h3 id="实现cow"><a href="#实现cow" class="headerlink" title="实现cow"></a>实现cow</h3><p>​        在上面fork的过程中，先复制PCB(内核栈在里面)、用户栈、复制页目录表和页表。但是复制页表和页目录表(页目录表的内核空间PDE还是相同的，这在申请时就赋值好了)时，所有用地地址空间的PTE中，物理页框号还是和父进程的物理页框号相同，也就是映射到了同一片物理地址空间。但是子进程的PTE的R/W位要设置为只读，也就是0。此时子进程可以共享父进程的程序体，</p>
<p>​        发生page fault时，CR2寄存器存放的就是发生page fault的虚拟地址。此时我们检查对应的PTE的P位是否存在，如果存在，那就是这个页是只读，且在用户态访问了。此时在缺页中断处理程序中，我们要为子进程的所有PTE重新映射新的物理页框，并将PTE的R/W位改为1。(涉及到复制的问题，我们也可以在内核空间申请一片缓冲区，然后将PTE与新的物理页款建立映射，然后再将内核缓冲区的数据复制过来。<strong>注意此时要扫描子进程的用户空间的所有PTE，也可以根据用户空间虚拟地址位图，将所有被分配的虚拟页都复制一份</strong>)</p>
<h1 id="项目遇到的一些问题"><a href="#项目遇到的一些问题" class="headerlink" title="项目遇到的一些问题"></a>项目遇到的一些问题</h1><ol>
<li>显存写数据清空所有字符导致光标不亮</li>
<li>C++和nasm符号不一致</li>
</ol>
]]></content>
  </entry>
</search>
