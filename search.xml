<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode题型总结</title>
      <link href="2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
      <url>2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>​        目前刷到的双指针题目主要有三种</p><ol><li>夹逼型：左右指针初始时分别指向左端点和右端点，然后根据某种条件向中间夹，<strong>一般这种情况要求数组有序(无序比如翻转数组)</strong></li><li>双指针维护滑动窗口类型：即指针p逐个向后遍历，指针q要按某种条件移动，指针(q,p)就维护了一个区间，这个区间会不断移动，也叫做滑动窗口。这个窗口不一定是有固定长度的，具体要看题目的条件。<strong>1.滑动窗口的条件可以用循环不变式来约束，即用集合的思想来思考 2.滑动窗口内必须是连续的(求解的问题必须是连续的)，如果结果可能非连续(比如求最长子序列)，无法用滑动窗口</strong></li><li>两个指针指向不同的数组：两个指针指向不同的数组，按照某种条件移动两个指针。这个指针初始化时不一定要指针两个数组的开头，也可以指向两个数组的末尾。<strong>常常用来合并数组或者链表</strong></li><li>链表题的快慢指针。141 142两题。</li></ol><a id="more"></a><h2 id="夹逼型"><a href="#夹逼型" class="headerlink" title="夹逼型"></a>夹逼型</h2><h3 id="167-两数之和"><a href="#167-两数之和" class="headerlink" title="167:两数之和"></a>167:两数之和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数，返回这两个数的下标。</span><br><span class="line">输入: numbers = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释: <span class="number">2</span> 与 <span class="number">7</span> 之和等于目标数 <span class="number">9</span> 。因此 index1 = <span class="number">1</span>, index2 = <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><p>有序，自然是左右端点夹逼型</p><h3 id="633-平方数之和"><a href="#633-平方数之和" class="headerlink" title="633:平方数之和"></a>633:平方数之和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c 。</span><br><span class="line">实例:</span><br><span class="line">输入：c = <span class="number">5</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="number">1</span> * <span class="number">1</span> + <span class="number">2</span> * <span class="number">2</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure><ul><li>有序，又是找两个满足某条件的点，自然双指针。这里为了不超时，可以让右指针从sqrt(x)开始。</li></ul><h3 id="345-反转元音字符"><a href="#345-反转元音字符" class="headerlink" title="345.反转元音字符"></a>345.反转元音字符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="string">&quot;hello&quot;</span></span><br><span class="line">输出：<span class="string">&quot;holle&quot;</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入：<span class="string">&quot;leetcode&quot;</span></span><br><span class="line">输出：<span class="string">&quot;leotcede&quot;</span></span><br></pre></td></tr></table></figure><ul><li>双指针翻转字符</li></ul><h3 id="680-验证回文串"><a href="#680-验证回文串" class="headerlink" title="680.验证回文串"></a>680.验证回文串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: <span class="string">&quot;aba&quot;</span></span><br><span class="line">输出: True</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: <span class="string">&quot;abca&quot;</span></span><br><span class="line">输出: True</span><br><span class="line">解释: 你可以删除c字符。</span><br></pre></td></tr></table></figure><p>判断回文串自然是夹逼型双指针，重点是我们夹逼到发现两个字符不相等时如何处理，由于只能删除一个，自然可以删除左边也可以删除右边，我们再去测试一下删除字符之后的部分串是否为回文串。所以我们两边都要试一下，有一个是就直接返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != s[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i++,j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != s[j])&#123;</span><br><span class="line">                <span class="comment">//两边都试一下</span></span><br><span class="line">                <span class="keyword">if</span>(test(s.substr(i+<span class="number">1</span>,j - i))) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(test(s.substr(i,j - i))) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++,j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="指针指向不同数组型"><a href="#指针指向不同数组型" class="headerlink" title="指针指向不同数组型"></a>指针指向不同数组型</h2><h3 id="88-归并两个有序数组"><a href="#88-归并两个有序数组" class="headerlink" title="88.归并两个有序数组"></a>88.归并两个有序数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</span><br><span class="line">说明：</span><br><span class="line">初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。</span><br><span class="line">你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span></span><br><span class="line">nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>],       n = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure><ul><li>指针分别指向两个数组的尾部，按照规则放入nums1数组。<strong>这就是双指针不一定非要放头部的反例，提一嘴，这个合并复杂度是o(m+n)</strong></li></ul><h3 id="524-通过删除字母匹配到字典里最长单词"><a href="#524-通过删除字母匹配到字典里最长单词" class="headerlink" title="524.通过删除字母匹配到字典里最长单词"></a>524.通过删除字母匹配到字典里最长单词</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s = <span class="string">&quot;abpcplea&quot;</span>, d = [<span class="string">&quot;ale&quot;</span>,<span class="string">&quot;apple&quot;</span>,<span class="string">&quot;monkey&quot;</span>,<span class="string">&quot;plea&quot;</span>]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line"><span class="string">&quot;apple&quot;</span></span><br></pre></td></tr></table></figure><p><strong>本质上是看能否在串s中找到一个在字典中出现过的子序列串，如果找到且有多个。就会返回最长，如果相等，就返回字典序小的那个</strong></p><p>野的方法就是找到串s的所有子序列，然后看他们是否在d中出现，加入一个集合后再筛选。这是从s找到符合d的东西。但是我们可以逆向思维，我们依次遍历d中的串，看他是否是s的子序列，这里判断是否为子序列我们就可以使用第二种类型的双指针了，这里是两个指针分别指向两个字符串的开头。</p><p><strong>为了优化，我们可以事先将d排序，按照先长度后字典序的方式排序，那样字典按需遍历时，找到的第一个符合条件的一定就是最终结果</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">com</span><span class="params">(<span class="built_in">string</span>&amp; s1,<span class="built_in">string</span>&amp; s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.size() != s2.size()) <span class="keyword">return</span> s1.size() &gt; s2.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s1.size() &amp;&amp; s1[i] == s2[i]) i++;</span><br><span class="line">        <span class="keyword">return</span> s1[i] &lt; s2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">findLongestWord</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">        sort(d.begin(),d.end(),com);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; d.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> s_cur = <span class="number">0</span>,d_cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(d_cur &lt; d[i].size() &amp;&amp; s_cur &lt; s.size())&#123;</span><br><span class="line">                <span class="keyword">if</span>(d[i][d_cur] == s[s_cur]) s_cur++,d_cur++;</span><br><span class="line">                <span class="keyword">else</span> s_cur++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(d_cur == d[i].size()) <span class="keyword">return</span> d[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h3><h2 id="滑动窗口型"><a href="#滑动窗口型" class="headerlink" title="滑动窗口型"></a>滑动窗口型</h2><h3 id="3-没有重复字符的字长子串"><a href="#3-没有重复字符的字长子串" class="headerlink" title="3.没有重复字符的字长子串"></a>3.没有重复字符的字长子串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串，请你找出其中不含有重复字符的 最长子串 的<span class="string">&quot;长度&quot;</span>。</span><br><span class="line">输入: s = <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">&quot;bbbbb&quot;</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;b&quot;</span>，所以其长度为 <span class="number">1</span>。</span><br></pre></td></tr></table></figure><ul><li><p>这里我们可以用双指针维护一个滑动窗口，滑动窗口内的字符必然要满足一个条件，我们在移动这个遍历用的指针遍历到新的元素时，必然要考虑到他对这个滑动窗口的影响，也就是对这个集合的影响，是新元素加入窗口、窗口扩大还是剔除窗口左端元素(<strong>剔除元素是为了维护窗口内的性质和我们的预期一致</strong>)，移动窗口(<strong>可以看到移动窗口其实就是对窗口左端点指针移动</strong>)，<strong>此时就可以用到集合论的思想，即循环不变式</strong></p></li><li><p>先定义好我们的窗口中的元素(集合)满足的条件：显然是集合中无重复元素，<strong>所以循环不变式(集合元素满足的条件)就是窗口中无重复元素</strong>。那么我们要使用一种方式记录这个窗口中是否有元素重复，此时我们想到了哈希表，以元素值为key，value标识这个元素出现的次数。<strong>当我们遍历用的指针i移动到下一个元素时，将这个元素加入窗口，对应的元素值++，如果发现加了之后hash[i] &gt; 1，说明这个窗口中有和新加入的这个元素一样的元素，我们就要移动窗口的左端点指针j，每移动一个将对应的hash值–，直到hash[i] == 1。在此过程中用窗口大小更新结果。</strong></p></li></ul><h3 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904.水果成篮"></a>904.水果成篮</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入一个数组Tree,数组的编号代表不同的树，Tree[i]的值表示第i棵树上结的水果。问你从任意一棵树开始，自左向右用两个体积无限大的篮子接水果，并且每个篮子只能放一种水果，最后返回你能采摘的水果数的最大数量。</span><br><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：我们可以收集 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]。</span><br></pre></td></tr></table></figure><ul><li><p><strong>这题其实和上面那题一样，就是维护一个滑动窗口，使滑动窗口内只含有两种类型的水果，抽象出来就是让滑动窗口内只包含两种数，并最后求这个滑动窗口最长时的长度</strong></p></li><li><p>为了维护这个循环不变式，我们可以用哈希表来窗口内水果类型的个数和对应的每种类型水果的个数。自然我们就是要让这个哈希表的元素不超过2个。i移动时，加入一个新的元素使哈希表元素大于两个，我们就要移动j，使这个滑动窗口内完全丢掉一种水果(无论是哪种)，所以此时我们可以根据hash[j]的值是否为0来判断某种水果是否全没了。哪个先没了，把哪种水果从哈希表丢掉。</p></li></ul><h3 id="76-最小覆盖串"><a href="#76-最小覆盖串" class="headerlink" title="76.最小覆盖串"></a>76.最小覆盖串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 <span class="string">&quot;&quot;</span> 。</span><br><span class="line"></span><br><span class="line">注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。</span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;ADOBECODEBANC&quot;</span>, t = <span class="string">&quot;ABC&quot;</span></span><br><span class="line">输出：<span class="string">&quot;BANC&quot;</span></span><br></pre></td></tr></table></figure><p>**这题也是滑动窗口，这个窗口的性质也即满足的条件是窗口内包含串t的所有字符，不需要顺序。所以我们要记录窗口内有效串的个数，来了一个新元素之后看是否会对我这个窗口有影响 如果当前窗口不包含t的所有字符，来了一个新的之后判断是否能让这个窗口包含t所有字符，如果能，我们想让窗口尽可能小点，移动窗口左端点，移动左端点的终止条件就是窗口内不包含t中的所有字符了。由于最后是要返回串，所以我们要记录最小满足条件的串的左端点和这个串的长度 **</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="comment">//记录t串出现的字符和出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; t.size();i++)&#123;</span><br><span class="line">            mp[t[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//窗口内有t有效字符的个数、最小子串的左边界、最小字串的长度</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>,min_l = <span class="number">0</span>,min_size = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;r &lt; s.size();r++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.count(s[r]))&#123;</span><br><span class="line">                <span class="comment">//有效字符个数只有mp[s[r]] &gt; 0时才算,去除重复字符的影响</span></span><br><span class="line">                <span class="keyword">if</span>(mp[s[r]] &gt; <span class="number">0</span>) cnt++;</span><br><span class="line">                mp[s[r]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获得了以r为右端点且包含t全部有效字符的最短子串</span></span><br><span class="line">            <span class="keyword">while</span>(cnt == t.size())&#123;</span><br><span class="line">                <span class="keyword">if</span>(mp.count(s[l]))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(++mp[s[l]] &gt; <span class="number">0</span>) cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(r - l + <span class="number">1</span> &lt; min_size)&#123;</span><br><span class="line">                    min_l = l;</span><br><span class="line">                    min_size = r - l + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_size == INT_MAX ? <span class="string">&quot;&quot;</span> : s.substr(min_l,min_size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><p>​        整数二分就主要使用acwing的模板就可以了，即自左向右找到第一个满足条件的点，自右向左找到第一个满足条件的点。小数二分比较简单。<strong>目前尚未总结出题型</strong></p><p>​        <strong>注意二分不一定要求数组有序，只要你能找到一次能排除一般元素的排他性条件就可以了。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左边第一个大于等于x的点，最后一定会停止，但是可能最后结果在逻辑上不满足条件</span></span><br><span class="line"><span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = i + j &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(arr[mid] &gt;= x) r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从右开始第一个小于等于x的点</span></span><br><span class="line"><span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = i + j + <span class="number">1</span>&gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(arr[mid] &lt;= x) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="整数二分模板题"><a href="#整数二分模板题" class="headerlink" title="整数二分模板题"></a>整数二分模板题</h2><h3 id="69-求平方根"><a href="#69-求平方根" class="headerlink" title="69.求平方根"></a>69.求平方根</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">计算并返回 x 的平方根，其中 x 是非负整数。</span><br><span class="line">由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</span><br><span class="line">输入: <span class="number">4</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">输入: <span class="number">8</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">说明: <span class="number">8</span> 的平方根是 <span class="number">2.82842</span>..., </span><br><span class="line">     由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure><ul><li>根据题意就是找到自左到右的第一个t，使t^2 &lt;= x；所以我们使用第一个模板，条件就是mid^2 &lt;= x</li></ul><h3 id="43-区间查找"><a href="#43-区间查找" class="headerlink" title="43.区间查找"></a>43.区间查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</span><br><span class="line"></span><br><span class="line">如果数组中不存在目标值 target，返回 [<span class="number">-1</span>, <span class="number">-1</span>]。</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">8</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">输入：nums = [], target = <span class="number">0</span></span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><ul><li>模板题直接套，即找到第一个小于等于target的位置，如果这个位置的值不等于target，说明数组中没这个元素，直接结束。</li></ul><h3 id="81-搜索旋转数组"><a href="#81-搜索旋转数组" class="headerlink" title="81.搜索旋转数组"></a>81.搜索旋转数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">假设按照升序排序的数组在预先未知的某个点上进行了旋转。</span><br><span class="line">( 例如，数组 [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>] 可能变为 [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>] )。</span><br><span class="line">编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span>。</span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: nums = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">0</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: nums = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">3</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li><strong>这题我们可以采用查找分界点，也就是旋转点，然后根据分界点和target的大小关系选择到分界点的左端还是右端查找。如果旋转了，分界点的特点一定是第一个小于nums[0]的点。但是这题因为有重复元素，所以预处理去重。我们删去数组右端的点，直到右端的点小于nums[0]，接下来就可以二分查找第一个小于nums[0]的分界点了。</strong></li></ul><h3 id="540-有序数组的单一元素"><a href="#540-有序数组的单一元素" class="headerlink" title="540.有序数组的单一元素"></a>540.有序数组的单一元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。</span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">8</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>这一题可以用位运算(亦或)来做，但是也可以二分来做。我们找到的二分条件就是如果arr[mid] == arr[mid + 1],那么如果mid处包括之前没有那个只出现一次的元素，这个mid一定是偶数。否则这个只出现一次的数一定出现在mid右边。同理分析</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r)&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//注意边界条件</span></span><br><span class="line">            <span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= r &amp;&amp; nums[mid] == nums[mid+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!(mid % <span class="number">2</span>)) l =  mid + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mid - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[mid] == nums[mid - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(mid % <span class="number">2</span>) l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> nums[mid]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>​        目前还没有总结出动态规划的套路，记录一下到目前为止的一些思考</p><p>​        看了知乎的帖子之后【<a href="https://www.zhihu.com/question/291280715/answer/1570410869%E3%80%91%EF%BC%8C%E6%88%91%E6%98%8E%E7%99%BD%E4%BA%86DP%E7%9A%84%E5%81%9A%E9%A2%98%E4%B8%89%E9%83%A8%E6%9B%B2%EF%BC%9A">https://www.zhihu.com/question/291280715/answer/1570410869】，我明白了DP的做题三部曲：</a></p><ol><li>定义好状态，即创建一个多维数组，明确数组中每一个值的意义</li><li>确定好某些状态的初始值，即初始化数组中某些元素的值</li><li>确定转移方程，这个也是最难的一步，目前为止我觉得主要靠经验</li></ol><h2 id="知乎帖子总结"><a href="#知乎帖子总结" class="headerlink" title="知乎帖子总结"></a>知乎帖子总结</h2><h3 id="青蛙跳台阶"><a href="#青蛙跳台阶" class="headerlink" title="青蛙跳台阶"></a>青蛙跳台阶</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维DP</span></span><br><span class="line"><span class="number">1.</span>dp[i]表示跳到第i层台阶的总次数</span><br><span class="line"><span class="number">2.</span>dp[<span class="number">0</span>] = <span class="number">0</span>,dp[<span class="number">1</span>] = <span class="number">1</span>,dp[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line"><span class="number">3.</span>dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br></pre></td></tr></table></figure><h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</span><br><span class="line"></span><br><span class="line">机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</span><br><span class="line"></span><br><span class="line">问总共有多少条不同的路径？</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维DP</span></span><br><span class="line"><span class="number">1.</span>dp[i][j]:到[i,j]这个位置可以有的路径数(i &gt;= <span class="number">0</span>,j &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="number">2.</span>dp[<span class="number">0</span>][<span class="number">1.</span>..m]都是<span class="number">1</span>，因为只能从左向右一条路走，dp[<span class="number">1.</span>..n][<span class="number">0</span>]都是<span class="number">1</span>，只能向下走，一个道理</span><br><span class="line"><span class="number">3.</span>dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64.最小路径和"></a>64.最小路径和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</span><br><span class="line"></span><br><span class="line">说明：每次只能向下或者向右移动一步。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路和上面一题一样，任意(i,j)这个点都只能从(i-1,j)和(i,j-1)来，所以我们只要取这两个之中的最小值即可</span></span><br><span class="line"><span class="number">1.</span>dp[i][j]:从(<span class="number">0</span>,<span class="number">0</span>)到(i,j)所有路径中路径之和最小的值</span><br><span class="line"><span class="number">2.</span>第<span class="number">0</span>行和第<span class="number">0</span>列的值都需要初始化</span><br><span class="line"><span class="number">3.</span>从(<span class="number">1</span>,<span class="number">1</span>)开始，dp[i][j] = min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]) + grid[i][j]</span><br></pre></td></tr></table></figure><h3 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72.编辑距离"></a>72.编辑距离</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</span><br><span class="line"></span><br><span class="line">你可以对一个单词进行如下三种操作：</span><br><span class="line"></span><br><span class="line">插入一个字符</span><br><span class="line">删除一个字符</span><br><span class="line">替换一个字符</span><br><span class="line"></span><br><span class="line">输入：word1 = <span class="string">&quot;horse&quot;</span>, word2 = <span class="string">&quot;ros&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 <span class="string">&#x27;h&#x27;</span> 替换为 <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">rorse -&gt; rose (删除 <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">rose -&gt; ros (删除 <span class="string">&#x27;e&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>这一题的转移方程和1143的LCS的思考方式特别像，两题一起看</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>dp[i][j]:word1的前i个字符组成的子串转换成word2的前j个字符的子串所要的最少操作次数</span><br><span class="line"><span class="number">2.</span>dp[<span class="number">0</span>][<span class="number">0.</span>..word2.size() - <span class="number">1</span>]都是当前遍历到的word2的子串的长度(一个长度为<span class="number">0</span>，转过去自然是另一个串的长度),dp[<span class="number">0.</span>..word1.size() - <span class="number">1</span>][<span class="number">0</span>]都是当前遍历到的word2的子串的长度</span><br><span class="line"><span class="number">3.</span>对于dp[i][j],如果word1[i] == word2[j],不用转了,那么dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">如果不等，那我们可以<span class="number">1.</span>删除word1的第i个位置，就是在dp[i<span class="number">-1</span>][j]的基础上又操作了一次;<span class="number">2.</span>删除word2的第j个位置，就是在dp[i][j<span class="number">-1</span>]的基础上又操作了一次 <span class="number">3.</span>将word1的i或者word2的j替换成和对方一样的(或者让其中某一个插入对方的字符)，就是在dp[i<span class="number">-1</span>][j<span class="number">-1</span>]的基础上又操作了一次。<span class="string">&quot;这三种情况都可以，所以我们自然要取其最小值&quot;</span>。</span><br><span class="line">所以此时dp[i][j] = min(min(dp[i<span class="number">-1</span>][j]+<span class="number">1</span>,dp[i][j<span class="number">-1</span>]+<span class="number">1</span>),dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="侯卫东"><a href="#侯卫东" class="headerlink" title="侯卫东"></a>侯卫东</h2><img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201212095101559.png" class><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201212095239839.png" class><img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201212095325250.png" class><img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201212095425147.png" class><p><strong>想转移方程时要考虑最后一步也就是考虑最后问题的解，假设他是最优解，那么最后规模的上一个规模的解也一定是最优解，可以用反证法证明。</strong></p><img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201212095728382.png" class><p><strong>这样我们就把原问题的接转换成了求规模更小的子问题的，更精确的说是当且问题的解可以在规模更小的子问题的解的基础上操作得到——想出这个操作就是转移方程(怎么由子问题解推出当前问题的解)。当然当前问题可能由多个子问题的解比较取优得到，不一定是只由一个子问题得到</strong></p><img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201212100118034.png" class><p><strong>由多个子问题的最优解比较得到当前问题最优解，这个过程就是转移方程</strong></p><img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201212100316975.png" class><img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201212104954598.png" class><p><strong>接下来就是考虑DP数组初始值和边界情况，比如数组越界时怎么处理。比如这里f(0)就是初始，用0个硬币就可以拼出</strong></p><img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201212105321719.png" class><p><strong>最后是考虑计算顺序，大部分是自左到右，当然还是要看你退出来的数之间的依赖关系</strong></p><h3 id="322-零钱兑换-其实也是背包问题"><a href="#322-零钱兑换-其实也是背包问题" class="headerlink" title="322.零钱兑换(其实也是背包问题)"></a>322.零钱兑换(其实也是背包问题)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line">你可以认为每种硬币的数量是无限的。</span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></span><br><span class="line">输出：<span class="number">3</span> </span><br><span class="line">解释：<span class="number">11</span> = <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：coins = [<span class="number">2</span>], amount = <span class="number">3</span></span><br><span class="line">输出：<span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要说一下这里初始值和处理边界值的方式，如果某个数量无法用基本硬币组成，也就是数组越界，我们用无穷大表示他，为了方便处理，把除0以外的其他位置都设置成无穷大。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>,<span class="number">0x3f3f3f3f</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        sort(coins.begin(),coins.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= amount;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; coins.size();j++)&#123;</span><br><span class="line">                <span class="comment">//如果没有越界，则如何处理</span></span><br><span class="line">                <span class="keyword">if</span>(i - coins[j] &gt;= <span class="number">0</span>) dp[i] = min(dp[i - coins[j]] + <span class="number">1</span>,dp[i]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[amount] &lt; <span class="number">0x3f3f3f</span>)  <span class="keyword">return</span> dp[amount];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="我的一些感悟"><a href="#我的一些感悟" class="headerlink" title="我的一些感悟"></a>我的一些感悟</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在<span class="number">01</span>背包中，我们把状态f[i,j]称为一个选法集合。我们在思考转移方程时就要考虑当前这个状态可能会由哪些子问题转过来，当我们知道可能会由哪些子问题转过来之后，只需要在这些问题中取最大或最小值就可以了。</span><br><span class="line">一般在求f[i,j]时，多半是从f[i<span class="number">-1</span>]过来的，所以我们就可以知道要么是在前i<span class="number">-1</span>个问题选满了j个，第i个放不下， 要么就是前i<span class="number">-1</span>选满了，但是还能放下第i个元素，所以只会由f[i<span class="number">-1</span>,j]和f[i<span class="number">-1</span>,j-v[i]]过来</span><br><span class="line">在矩阵联城法中，f[i,j]表示(i,j)这个连乘所有的乘的方式的集合，但是最终都会化为两个矩阵相乘，所以我们只需要考虑(j - i + <span class="number">1</span>)所有连乘链组成的所有可能的两个矩阵就可以了。</span><br></pre></td></tr></table></figure><ul><li><strong>上面的意思就是明确状态表示哪些集合，然后集合可以按照什么样的条件划分为若干类，这个就是做题经验了。每一小类的计算一般会用到子问题的解</strong></li></ul><h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h2><h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a>198.打家劫舍</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</span><br><span class="line"></span><br><span class="line">给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">1</span>) ，然后偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">3</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br><span class="line"><span class="comment">//相邻房子不能偷能偷到的最大价值</span></span><br></pre></td></tr></table></figure><img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201220144258139.png" class><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种状态的定义方式。</span></span><br><span class="line">偷第i个时，第i<span class="number">-1</span>个不能偷。而dp[i<span class="number">-1</span>]是包括偷第i<span class="number">-1</span>个的，所以我们只能在i<span class="number">-1</span>的基础上偷</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size() + <span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>];<span class="comment">//防止边界问题，从第2个开始算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nums.size();i++)&#123;</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-2</span>]+nums[i<span class="number">-1</span>],dp[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用股票那一题的状态定义方式</span></span><br><span class="line">dp[i][<span class="number">0</span>]:第i个不偷情况下的最大值</span><br><span class="line">dp[i][<span class="number">1</span>]:第i个偷情况下的最大值</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(nums.size() + <span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= nums.size();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(dp[nums.size()][<span class="number">0</span>],dp[nums.size()][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="213-打家劫舍Ⅱ"><a href="#213-打家劫舍Ⅱ" class="headerlink" title="213.打家劫舍Ⅱ"></a>213.打家劫舍Ⅱ</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</span><br><span class="line">给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。</span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：你不能先偷窃 <span class="number">1</span> 号房屋（金额 = <span class="number">2</span>），然后偷窃 <span class="number">3</span> 号房屋（金额 = <span class="number">2</span>）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和上一题相比，这一题就是多了环形数组这个条件。怎么解决呢？我们发现如果偷了第一个，那么最后一个一定没法偷。同理偷最后一个第一个一定没法偷。</span></span><br><span class="line">所以根据这一互斥条件，讲原数组分为两个队列，一个包含<span class="number">1.</span>..n<span class="number">-1</span>这n<span class="number">-1</span>个元素(即可能偷第一个)，一个包含<span class="number">2.</span>..n这n<span class="number">-1</span>个元素(即不会偷第一个)。</span><br><span class="line"><span class="comment">//第一组可能偷第一个，也就是有可能不偷第一个。那么假设在第一组中，最大值的组合是不偷第一个，最后一个偷的是n-2,那么你是不是会想，此时在第一组要是可以偷第n个，这样价值会更大，而且满足了1 n互斥的关系。其实如果存在描述的这种情况他会在第二组中被检查到，我们函数的功能就是找到某个区域偷盗的最大值。而上面描述的那种情况如果存在，他肯定比第一组最大值大，但是他所扫描的区域实际上是2...n，这是一定会在第二组被找到的。所以这种做法是没问题的。</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//创建两个DP数组，一个是偷第一个，一个不偷第一个</span></span><br><span class="line">        vector&lt;int&gt; dp1(nums.size()+1,0),dp2 = dp1;</span><br><span class="line">        <span class="comment">//dp1是一定偷第一个(则一定不会偷最后一个)，dp2是不偷第一个</span></span><br><span class="line">        dp1[<span class="number">1</span>] = nums[<span class="number">0</span>],dp2[<span class="number">2</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; nums.size();i++)&#123;</span><br><span class="line">            dp1[i] = max(dp1[i<span class="number">-1</span>],dp1[i<span class="number">-2</span>]+nums[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= nums.size();i++) dp2[i] = max(dp2[i<span class="number">-1</span>],dp2[i<span class="number">-2</span>]+nums[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">return</span> max(dp1[nums.size()<span class="number">-1</span>],dp2[nums.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空间优化版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        vector&lt;int&gt; dp1(2),dp2(2);</span><br><span class="line">        dp1[<span class="number">1</span>] = nums[<span class="number">0</span>],dp2[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = dp1[<span class="number">1</span>];</span><br><span class="line">            dp1[<span class="number">1</span>] = max(dp1[<span class="number">1</span>],dp1[<span class="number">0</span>]+nums[i<span class="number">-1</span>]);</span><br><span class="line">            dp1[<span class="number">0</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = dp2[<span class="number">1</span>];</span><br><span class="line">            dp2[<span class="number">1</span>] = max(dp2[<span class="number">1</span>],dp2[<span class="number">0</span>]+nums[i<span class="number">-1</span>]);</span><br><span class="line">            dp2[<span class="number">0</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(dp1[<span class="number">1</span>],dp2[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="413-等差数列划分"><a href="#413-等差数列划分" class="headerlink" title="413.等差数列划分"></a>413.等差数列划分</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">返回: <span class="number">3</span>, A 中有三个子等差数组: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] 以及自身 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]。</span><br><span class="line"><span class="comment">//规定连续的长度大于等于3的子数组为等差子数组，求给定数组中等差子数组的个数。</span></span><br></pre></td></tr></table></figure><img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201220180958000.png" class><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(A.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; A.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] - A[i - <span class="number">1</span>] == A[i - <span class="number">1</span>] - A[i - <span class="number">2</span>]) dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accumulate(dp.begin(),dp.end(),<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="746-最小花费爬楼梯"><a href="#746-最小花费爬楼梯" class="headerlink" title="746.最小花费爬楼梯"></a>746.最小花费爬楼梯</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从<span class="number">0</span>开始)。</span><br><span class="line"></span><br><span class="line">每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</span><br><span class="line"></span><br><span class="line">您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 <span class="number">0</span> 或 <span class="number">1</span> 的元素作为初始阶梯。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]表示能到i号阶梯的所有跳跃方式的集合,但是还没跳上i号阶梯</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size(),<span class="number">0x3f3f3f3f</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>,dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; cost.size();i++)&#123;</span><br><span class="line">            dp[i] = min(dp[i<span class="number">-2</span>] + cost[i<span class="number">-2</span>],dp[i<span class="number">-1</span>] + cost[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = dp[cost.size() - <span class="number">1</span>] + cost[cost.size() - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(n - <span class="number">1</span> &gt;= <span class="number">0</span>) res = min(dp[n<span class="number">-1</span>] + cost[n<span class="number">-1</span>],res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//改进版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="矩阵问题"><a href="#矩阵问题" class="headerlink" title="矩阵问题"></a>矩阵问题</h3><p>矩阵问题的一个特点就是状态的定义，我目前总结了一下常见的意义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.dp[i][j]代表以(i,j)为右下角的整个区域内满足某种条件的子集的集合</span><br><span class="line">2.dp[i][j]代表在1的基础上，所以子集中必须包含(i,j)这个点的集合，相当于在1的基础上缩小了(即固定住(i,j)这个点)。比如221题</span><br></pre></td></tr></table></figure><h4 id="174-地下城游戏"><a href="#174-地下城游戏" class="headerlink" title="174.地下城游戏"></a>174.地下城游戏</h4><img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201220144909804.png" class><p><strong>题意就是让你找到一个最小的HP值使你能走到终点，比如这里，第一个格子就要掉2HP，所以至少要3起步。总之就是勇士的血在路过每一个格子之后都不能低于1</strong></p><p><strong>这题是罕见的从右下向左上推</strong></p><img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201220151413079.png" class><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = d.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(d[<span class="number">0</span>].size()+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        dp[n][d[<span class="number">0</span>].size()] = d[n<span class="number">-1</span>][d[<span class="number">0</span>].size()<span class="number">-1</span>] &lt; <span class="number">0</span> ? -d[n<span class="number">-1</span>][d[<span class="number">0</span>].size()<span class="number">-1</span>] + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = d[<span class="number">0</span>].size()<span class="number">-1</span>;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[n - <span class="number">1</span>][i - <span class="number">1</span>] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(d[n<span class="number">-1</span>][i<span class="number">-1</span>] &gt;= dp[n][i+<span class="number">1</span>]) dp[n][i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[n][i] = dp[n][i+<span class="number">1</span>] - d[n<span class="number">-1</span>][i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> dp[n][i] = dp[n][i+<span class="number">1</span>] - d[n<span class="number">-1</span>][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =n - <span class="number">1</span>;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i - <span class="number">1</span>][d[<span class="number">0</span>].size() - <span class="number">1</span>] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(d[i<span class="number">-1</span>][d[<span class="number">0</span>].size()<span class="number">-1</span>] &gt;= dp[i+<span class="number">1</span>][d[<span class="number">0</span>].size()]) dp[i][d[<span class="number">0</span>].size()] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][d[<span class="number">0</span>].size()] = dp[i+<span class="number">1</span>][d[<span class="number">0</span>].size()] - d[i<span class="number">-1</span>][d[<span class="number">0</span>].size()<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> dp[i][d[<span class="number">0</span>].size()] = dp[i+<span class="number">1</span>][d[<span class="number">0</span>].size()] - d[i<span class="number">-1</span>][d[<span class="number">0</span>].size()<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上面是处理边界，</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = d[<span class="number">0</span>].size()<span class="number">-1</span>;j &gt;= <span class="number">1</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(d[i<span class="number">-1</span>][j<span class="number">-1</span>] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> val = min(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>]);</span><br><span class="line">                    <span class="keyword">if</span>(val &lt;= d[i<span class="number">-1</span>][j<span class="number">-1</span>]) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = val - d[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = min(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>]) - d[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="542-01矩阵"><a href="#542-01矩阵" class="headerlink" title="542.01矩阵"></a>542.01矩阵</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">给定一个由 <span class="number">0</span> 和 <span class="number">1</span> 组成的矩阵，找出每个元素到最近的 <span class="number">0</span> 的距离。</span><br><span class="line"></span><br><span class="line">两个相邻元素间的距离为 <span class="number">1</span> 。</span><br><span class="line">输入：</span><br><span class="line">[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure><p><strong>第一种方式就是BFS：不过我们的BFS是初始化时先将所有的值为0的点入队，并更新dist数组，然后把这所有的0点看作一个超级节点，也可以看成树中的根节点，然后以这个根节点开始DFS，那么第一次遇到的所有非0节点，他们距离0的距离就是dist[x] [y] + 1.然后把这些第一次更新的节点加入到队列，中依次再遍历周围找到新的节点。根据BFS的性质，BFS第一次遇到的点的层数一定是这个点到根节点的最短距离</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; updateMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dist(matrix.size(),<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(matrix[<span class="number">0</span>].size(),<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">using</span> PII = <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;PII&gt; que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; matrix.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; matrix[<span class="number">0</span>].size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!matrix[i][j])&#123;</span><br><span class="line">                    que.push(&#123;i,j&#125;);</span><br><span class="line">                    dist[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dist[i][j] = INT_MAX;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(que.size())&#123;</span><br><span class="line">            <span class="keyword">auto</span> q = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = q.first + dx[i];</span><br><span class="line">                <span class="keyword">int</span> y = q.second + dy[i];</span><br><span class="line">                <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; matrix.size() &amp;&amp; y &lt; matrix[<span class="number">0</span>].size())&#123;</span><br><span class="line">                    <span class="comment">//判断是否入过队列,非INT_MAX一定是访问过的</span></span><br><span class="line">                    <span class="keyword">if</span>(dist[x][y] &amp;&amp; dist[x][y] == INT_MAX)&#123;</span><br><span class="line">                        dist[x][y] = dist[q.first][q.second] + <span class="number">1</span>;</span><br><span class="line">                        que.push(&#123;x,y&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本题使用DP的话对任意一个状态他的集合要分为4类，但是无论是从上到下还是从下到上最多有两个方向也就是两类在计算这个状态之前被算出来了。所以我们选择从上到下一次，然后从下到上一次。两次更新。这样就更新到了所有方向</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; updateMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(matrix.size(),<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(matrix[<span class="number">0</span>].size(),<span class="number">0x3f3f3f3f</span>));</span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; matrix.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; matrix[<span class="number">0</span>].size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!matrix[i][j])&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>;k++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i + dx[k],y = j + dy[k];</span><br><span class="line">                    <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; matrix.size() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; matrix[<span class="number">0</span>].size())&#123;</span><br><span class="line">                        dp[i][j] = min(dp[x][y],dp[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = matrix.size() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = matrix[<span class="number">0</span>].size() - <span class="number">1</span>;j &gt;= <span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!matrix[i][j])&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>;k++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i + dx[k],y = j + dy[k];</span><br><span class="line">                    <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; matrix.size() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; matrix[<span class="number">0</span>].size())&#123;</span><br><span class="line">                        dp[i][j] = min(dp[x][y],dp[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于动态规划为什么只考虑左上和右下就可以了。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_ _ _ 0 _</span><br><span class="line">_ _ _ _ _</span><br><span class="line">_ _ 1 _ _</span><br><span class="line">_ _ _ _ _</span><br></pre></td></tr></table></figure><p>如上图，我们假设某个位置<code>(x,y)</code>离它最近的0只有一个，且是在它的右上角，在它“右1上2”的位置。这意味着距离中心1距离为“3=1+2”的范围内，所有的位置都是1（或者出界，我们暂时不考虑出界的情况，不影响结论）。</p><p>所以这张图一定是（不考虑左下方的出界情况，不影响）:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">? ? ? ?  1  ? ? ? ?</span><br><span class="line">? ? ? 1  1  0 ? ? ?</span><br><span class="line">? ? 1 1  1  1 1 ? ?</span><br><span class="line">? 1 1 1 &quot;1&quot; 1 1 1 ?</span><br><span class="line">? ? 1 1  1  1 1 ? ?</span><br><span class="line">? ? ? 1  1  1 ? ? ?</span><br><span class="line">? ? ? ?  1  ? ? ? ?</span><br></pre></td></tr></table></figure><p>所以我们来考虑它右一处标为X的位置，离这个位置最近的0，一定就是它“上二”方向的0：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">? ? ? ?  1  ? ? ? ?</span><br><span class="line">? ? ? 1  1  0 ? ? ?</span><br><span class="line">? ? 1 1  1  1 1 ? ?</span><br><span class="line">? 1 1 1 &quot;1&quot; X 1 1 ?</span><br><span class="line">? ? 1 1  1  1 1 ? ?</span><br><span class="line">? ? ? 1  1  1 ? ? ?</span><br><span class="line">? ? ? ?  1  ? ? ? ?</span><br></pre></td></tr></table></figure><p>所以在“考虑左上角的时候”，X处的位置可以记录到目标0的信息，X处的最短距离被正确记录了。</p><p>然后在“考虑右下角的时候”，X处的最短信息，正好又能被我们的中心“1”观察到，所以中心1间接地，记录到了目标0的最短距离。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">如图，从左上开始的第一遍会让<span class="number">0</span>为左上角的矩形区域全部记录到</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> / <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> / <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> / <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">从右下向左上遍历时，右下的区域又会把记录到的最短信息更新给左上半部分的区域</span><br></pre></td></tr></table></figure><h4 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221.最大正方形"></a>221.最大正方形</h4><img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20210121142416603.png" class><p><strong>题意就是在给定矩形矩阵中找到全由1构成的最大正方形的面积</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;对于矩阵搜索正方形或者长方形的题目，常见的做法是使用dp&quot;</span>。在这种题目里面一般定义dp[i][j]所代表的集合为以(i,j)为右下角的所有全是<span class="number">1</span>的正方形/矩形</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">状态计算</span><br><span class="line">令dp[i][j] = k</span><br><span class="line">dp[i<span class="number">-1</span>][j] &gt;= k - <span class="number">1</span></span><br><span class="line">dp[i][j<span class="number">-1</span>] &gt;= k - <span class="number">1</span></span><br><span class="line">dp[i<span class="number">-1</span>][j<span class="number">-1</span>] &gt;= k - <span class="number">1</span></span><br><span class="line">如果不满足上面的这个条件，以(i,j)为右下角的长度为k的矩形中绝对不可能全是<span class="number">1</span></span><br><span class="line">又因为dp[i][j]也只能从上说的三个方向的正方形延申过来，所以</span><br><span class="line">dp[i][j] = min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;如果dp[i-1][j],dp[i-1][j-1],dp[i][j-1]至少有一个为0，那么(i,j)的三个方向肯定有一个为0，那么没得大一统了，只能最多为1了。否则，看下图&quot;</span>。</span><br><span class="line">    所以两个条件一结合就是这个递推式了</span><br></pre></td></tr></table></figure><img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20210121161520853.png" class><img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20210121151146533.png" class><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size(),n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//dp一般从下标1开始，申请多一个方便处理边界，但还是要具体问题具体分析</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dp[i][j] = min(min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]),dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxlen = max(maxlen,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen*maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1277-全为1的正方形子矩阵"><a href="#1277-全为1的正方形子矩阵" class="headerlink" title="1277.全为1的正方形子矩阵"></a>1277.全为1的正方形子矩阵</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix =</span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出：<span class="number">15</span></span><br><span class="line">解释： </span><br><span class="line">边长为 <span class="number">1</span> 的正方形有 <span class="number">10</span> 个。</span><br><span class="line">边长为 <span class="number">2</span> 的正方形有 <span class="number">4</span> 个。</span><br><span class="line">边长为 <span class="number">3</span> 的正方形有 <span class="number">1</span> 个。</span><br><span class="line">正方形的总数 = <span class="number">10</span> + <span class="number">4</span> + <span class="number">1</span> = <span class="number">15.</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这一题我们只需要在<span class="number">221</span>题的基础上修改就可以了。dp[i][j]的值是以(i,j)为右下角的正方形的长，那么它<span class="string">&quot;也可以表示以(i,j)为右下角的正方形的个数&quot;</span>.所以最后我们把dp矩阵累加起来就可以了</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSquares</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size(),n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i<span class="number">-1</span>][j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j] = min(dp[i<span class="number">-1</span>][j],min(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>])) + <span class="number">1</span>;</span><br><span class="line">                res += dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="分割类问题"><a href="#分割类问题" class="headerlink" title="分割类问题"></a>分割类问题</h3><ul><li>顾名思义就是把一个数按要求拆分成几个部分，问拆分之后生成的最少部分数是多少。</li><li><strong>拆分类的题目都可以用dp来做，思路就和找零钱差不多</strong></li></ul><h4 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279.完全平方数"></a>279.完全平方数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定正整数 n，找到若干个完全平方数（比如 <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</span><br><span class="line">输入: n = <span class="number">12</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: <span class="number">12</span> = <span class="number">4</span> + <span class="number">4</span> + <span class="number">4.</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路和找零钱差不多，dp[i]表示拆分i需要的最少的完全平方数的个数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0x3f3f3f3f</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>,dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="built_in">sqrt</span>(i);j &gt;= <span class="number">1</span>;j--)&#123;</span><br><span class="line">                dp[i] = min(dp[i - j*j] + <span class="number">1</span>,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91.解码方法"></a>91.解码方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</span><br><span class="line"><span class="string">&#x27;A&#x27;</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="string">&#x27;B&#x27;</span> -&gt; <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;Z&#x27;</span> -&gt; <span class="number">26</span></span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;226&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：它可以解码为 <span class="string">&quot;BZ&quot;</span> (<span class="number">2</span> <span class="number">26</span>), <span class="string">&quot;VF&quot;</span> (<span class="number">22</span> <span class="number">6</span>), 或者 <span class="string">&quot;BBF&quot;</span> (<span class="number">2</span> <span class="number">2</span> <span class="number">6</span>) 。</span><br><span class="line"><span class="comment">//问你数字有多少种解码方式</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp[i]表示前i个字符的解码方式的个数，我们按照第i个字符是否独立编码划分集合(即是否和i-1结合)，一种是独立编码，另一种是与i-1结合编码。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(s.size()+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">//dp[1]和dp[2]是初始值需要特殊处理</span></span><br><span class="line">        dp[<span class="number">1</span>] = s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//看这个组成的两位数符不符合标准</span></span><br><span class="line">                <span class="keyword">if</span>(atoi(s.substr(<span class="number">0</span>,<span class="number">2</span>).c_str()) &lt;= <span class="number">26</span>) dp[<span class="number">2</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>] != <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(atoi(s.substr(<span class="number">0</span>,<span class="number">2</span>).c_str()) &lt;= <span class="number">26</span>) dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;=s.size();i++)&#123;</span><br><span class="line">            <span class="comment">//如果i号字符能单独存在</span></span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>] != <span class="string">&#x27;0&#x27;</span>) dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="comment">//如果i号字符能和i-1号结合</span></span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-2</span>] != <span class="string">&#x27;0&#x27;</span> &amp;&amp; atoi(s.substr(i<span class="number">-2</span>,<span class="number">2</span>).c_str()) &lt;= <span class="number">26</span>) dp[i] += dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a>139.单词拆分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">拆分时可以重复使用字典中的单词。</span><br><span class="line">你可以假设字典中没有重复的单词。</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">&quot;leetcode&quot;</span>, wordDict = [<span class="string">&quot;leet&quot;</span>, <span class="string">&quot;code&quot;</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 返回 <span class="literal">true</span> 因为 <span class="string">&quot;leetcode&quot;</span> 可以被拆分成 <span class="string">&quot;leet code&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这题也可以用dp，dp[i]的集合表示s的前i+<span class="number">1</span>个字符所有的拼接组合方式，值为这些组合方式中是否存在<span class="string">&quot;所有被拆分的部分都在字典中出现&quot;</span>这种情况。我们跟<span class="number">91</span>一样，根据第i号字符是否和i以前的字符组合来划分集合。</span><br></pre></td></tr></table></figure><img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20210121215532477.png" class><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">bool</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c:wordDict) mp[c] = <span class="literal">true</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="comment">//0号是初值</span></span><br><span class="line">        <span class="keyword">if</span>(mp[s.substr(<span class="number">0</span>,<span class="number">1</span>)]) dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; s.size();i++)&#123;</span><br><span class="line">            <span class="comment">//从i开始依次向前结合</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="comment">//如果[i-j+1,i]在字典出现，只需要再检查dp[i-j]是否能被成功拆分就可以了，如果</span></span><br><span class="line">                <span class="keyword">if</span>(mp[s.substr(i-j+<span class="number">1</span>,j)])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i &gt;= j) dp[i] = dp[i - j];</span><br><span class="line">                    <span class="keyword">else</span> dp[i] = <span class="literal">true</span>;<span class="comment">//特判j == i+1这种情况</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i]) <span class="keyword">break</span>;<span class="comment">//如果为true,说明存在某种拆分方式，直接退出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.size() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="背包类问题"><a href="#背包类问题" class="headerlink" title="背包类问题"></a>背包类问题</h3><p>01背包注意点</p><ul><li><strong>未优化的情况下，第二维都要从0开始，如果第i个货物放不下，就等于上一层。优化过后，逆着来，就相当于直接等于上一层，所以到j &gt;= v[i]为止就可以了</strong></li></ul><h4 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416.分割等和子集"></a>416.分割等和子集</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</span><br><span class="line">注意:</span><br><span class="line">每个数组中的元素不会超过 <span class="number">100</span></span><br><span class="line">数组的大小不会超过 <span class="number">200</span></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">5</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 数组可以分割成 [<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>] 和 [<span class="number">11</span>].</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这一题用<span class="number">01</span>背包来做，我们定义dp[i][j]为前i个元素可以选出来的所有集合，他的值就是这些集合中是否存在和为j的这种集合。所以言下之意就是我们能否在前i个元素中找到和为j的目标集合k。<span class="string">&quot;我们根据这些子集中是否有第i个元素来将所有集合划分成两大类，然后我们只需要看这两大类子集中是否有和为j的子集就可以了。这两大类子集，第一类就是i-1个元素组成的所有子集，第二类就是就是第一类的所有集合中加入一个i号元素。如果第一大类有，那第二大类就没有，如果第二大类没有只需要检查第二大类，因为第二大类所有集合都有i，所以他们的和都有i号元素，那么对于第二大类只要检查有没有和为j - nums[i]的值就可以了。&quot;</span></span><br><span class="line">    事实上这样划分的集合也是不重不漏的，前i个元素的所有集合是由所有含i号元素的集合和不含i号元素的集合一起构成的</span><br></pre></td></tr></table></figure><img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20210122124208292.png" class><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.begin(),nums.end(),<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//奇数不可能</span></span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target  = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(nums.size()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(target+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">        <span class="comment">//初始值，后面的边界值处理需要</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= nums.size();i++) dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= nums.size();i++)&#123;</span><br><span class="line">            <span class="comment">//正规01背包未优化的写法，j应该从0开始</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= target;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= nums[i<span class="number">-1</span>]) dp[i][j] = dp[i][j] || dp[i<span class="number">-1</span>][j-nums[i<span class="number">-1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.size()][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.begin(),nums.end(),<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//奇数不可能</span></span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target  = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(nums.size()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(target+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">        <span class="comment">//初始值，后面的边界值处理需要</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= nums.size();i++) dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= nums.size();i++)&#123;</span><br><span class="line">            <span class="comment">//这里也是01背包未优化，但是j不是从0开始也是对的，我不知道为什么</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = nums[i<span class="number">-1</span>];j &lt;= target;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] || dp[i<span class="number">-1</span>][j-nums[i<span class="number">-1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.size()][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化为一维，倒着来</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.begin(),nums.end(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target  = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(target+<span class="number">1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = target;j &gt;= nums[i<span class="number">-1</span>];j--)&#123;</span><br><span class="line">                dp[j] = dp[j] || dp[j-nums[i<span class="number">-1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="474-1和0"><a href="#474-1和0" class="headerlink" title="474.1和0"></a>474.1和0</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</span><br><span class="line">请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 <span class="number">0</span> 和 n 个 <span class="number">1</span> 。</span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：strs = [<span class="string">&quot;10&quot;</span>, <span class="string">&quot;0001&quot;</span>, <span class="string">&quot;111001&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>], m = <span class="number">5</span>, n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最多有 <span class="number">5</span> 个 <span class="number">0</span> 和 <span class="number">3</span> 个 <span class="number">1</span> 的最大子集是 &#123;<span class="string">&quot;10&quot;</span>,<span class="string">&quot;0001&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>&#125; ，因此答案是 <span class="number">4</span> 。</span><br><span class="line">其他满足题意但较小的子集包括 &#123;<span class="string">&quot;0001&quot;</span>,<span class="string">&quot;1&quot;</span>&#125; 和 &#123;<span class="string">&quot;10&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>&#125; 。&#123;<span class="string">&quot;111001&quot;</span>&#125; 不满足题意，因为它含 <span class="number">4</span> 个 <span class="number">1</span> ，大于 n 的值 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01b</span>背包，只不过这次相当于有两个包的限制，所以是多维<span class="number">01</span>背包</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; dp(strs.size()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>)));</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">one</span><span class="params">(strs.size()+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">zero</span><span class="params">(strs.size()+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; strs.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; strs[i].size();k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[i][k] == <span class="string">&#x27;1&#x27;</span>) one[i+<span class="number">1</span>]++;</span><br><span class="line">                <span class="keyword">else</span> zero[i+<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= strs.size();i++)&#123;</span><br><span class="line">            <span class="comment">//01背包未优化都要从0开始</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= m;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= n;k++)&#123;</span><br><span class="line">                    dp[i][j][k] = dp[i<span class="number">-1</span>][j][k];</span><br><span class="line">                    <span class="keyword">if</span>(j &gt;= zero[i] &amp;&amp; k &gt;= one[i])</span><br><span class="line">                        dp[i][j][k] = max(dp[i<span class="number">-1</span>][j-zero[i]][k-one[i]]+<span class="number">1</span>,dp[i][j][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[strs.size()][m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">one</span><span class="params">(strs.size()+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">zero</span><span class="params">(strs.size()+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; strs.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; strs[i].size();k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[i][k] == <span class="string">&#x27;1&#x27;</span>) one[i+<span class="number">1</span>]++;</span><br><span class="line">                <span class="keyword">else</span> zero[i+<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= strs.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m;j &gt;= zero[i];j--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = n;k &gt;= one[i];k--)&#123;</span><br><span class="line">                    dp[j][k] = max(dp[j-zero[i]][k-one[i]]+<span class="number">1</span>,dp[j][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="字符串编辑"><a href="#字符串编辑" class="headerlink" title="字符串编辑"></a>字符串编辑</h3><ul><li>**双字符串题(72 1143 10)**的dp[i] [j]表示第一个字符串的前i个字符和第二个串的前j个字符</li></ul><h4 id="72-编辑距离-1"><a href="#72-编辑距离-1" class="headerlink" title="72.编辑距离"></a>72.编辑距离</h4><h4 id="650-只有两个键的键盘"><a href="#650-只有两个键的键盘" class="headerlink" title="650.只有两个键的键盘"></a>650.只有两个键的键盘</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">最初在一个记事本上只有一个字符 <span class="string">&#x27;A&#x27;</span>。你每次可以对这个记事本进行两种操作：</span><br><span class="line">Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。</span><br><span class="line">Paste (粘贴) : 你可以粘贴你上一次复制的字符。</span><br><span class="line">给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 <span class="string">&#x27;A&#x27;</span>。输出能够打印出 n 个 <span class="string">&#x27;A&#x27;</span> 的最少操作次数。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: <span class="number">3</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释:</span><br><span class="line">最初, 我们只有一个字符 <span class="string">&#x27;A&#x27;</span>。</span><br><span class="line">第 <span class="number">1</span> 步, 我们使用 Copy All 操作。</span><br><span class="line">第 2 步, 我们使用 Paste 操作来获得 &#x27;AA&#x27;。</span><br><span class="line">第 3 步, 我们使用 Paste 操作来获得 &#x27;AAA&#x27;。</span><br></pre></td></tr></table></figure><img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20210122183731787.png" class><p>*<em>主要是考虑合数i = a</em>b表示i个A可以由a个b时的状态粘贴过来，也可以由b个a状态粘贴过来，取最小值**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0x3f3f3f3f</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>,dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j &lt;= <span class="built_in">sqrt</span>(i);j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i] = min(min(dp[i],dp[j] + i / j),dp[i/j]+j);             </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == <span class="number">0x3f3f3f3f</span>) dp[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="10-正则表达式的匹配"><a href="#10-正则表达式的匹配" class="headerlink" title="10.正则表达式的匹配"></a>10.正则表达式的匹配</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 <span class="string">&#x27;.&#x27;</span> 和 <span class="string">&#x27;*&#x27;</span> 的正则表达式匹配。</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;.&#x27;</span> 匹配任意单个字符</span><br><span class="line"><span class="string">&#x27;*&#x27;</span> 匹配零个或多个前面的那一个元素</span><br><span class="line">所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：s = <span class="string">&quot;aa&quot;</span> p = <span class="string">&quot;a&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：<span class="string">&quot;a&quot;</span> 无法匹配 <span class="string">&quot;aa&quot;</span> 整个字符串。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">只要是涉及到双串(无论是匹配或者是其他操作)，dp时他们的状态数组都是同一种方式，dp[i][j]</span><br><span class="line">这题dp[i][j]还是表示S串的前i个字符和P串的前j个字符是否匹配</span><br><span class="line">操作还是类似于LCS，对尾部进行判断</span><br><span class="line">    <span class="number">1.</span>P[j] == S[i] || p[j] == <span class="string">&#x27;.&#x27;</span>，那么dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">    <span class="number">2.</span>P[j] == <span class="string">&#x27;*&#x27;</span></span><br><span class="line">    此时若*前面的字符和S[i]不相等,那么可以把*和其前面的字符一起消掉,即dp[i][j]=dp[i][j]||dp[i][j<span class="number">-2</span>]</span><br><span class="line">    如果*前面的字符x和s[i]相等，但是s[i<span class="number">-1</span>],s[i<span class="number">-2</span>]...可能都与x相等，这个时候就要考虑消去p的几个才能匹配了，所以我们要把所有可能要消去的元素都枚举一遍，看看是否能成功。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(s.size()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(p.size()+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//这里主要是初始化p串不为空，s为空但是也能匹配的这种特殊情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; p.size();i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i] == <span class="string">&#x27;*&#x27;</span>) dp[<span class="number">0</span>][i+<span class="number">1</span>] = dp[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= p.size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">&#x27;.&#x27;</span>) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> k = i;</span><br><span class="line">                    <span class="comment">//这里是*前面的元素和S[i]不相等或者相等时却不消去S[i]的情况</span></span><br><span class="line">                    dp[i][j] = dp[i][j] || dp[i][j<span class="number">-2</span>];</span><br><span class="line">                    <span class="comment">//下面枚举消去连续相等的1、2、3...个</span></span><br><span class="line">                    <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; (s[k<span class="number">-1</span>] == p[j<span class="number">-2</span>] || p[j<span class="number">-2</span>] == <span class="string">&#x27;.&#x27;</span>))&#123;</span><br><span class="line">                        dp[i][j] = dp[i][j] || dp[k<span class="number">-1</span>][j<span class="number">-2</span>];</span><br><span class="line">                        k--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.size()][p.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="股票买卖"><a href="#股票买卖" class="headerlink" title="股票买卖"></a>股票买卖</h3><ul><li><p>给定一支股票的价格数组，问你怎么买卖这支股票利润最该</p></li><li><p>一次买入，接着卖出才算一次交易</p></li><li><p><a href="https://leetcode-cn.com/circle/article/qiAgHn/">https://leetcode-cn.com/circle/article/qiAgHn/</a> 这个非常详细，他介绍的状态模板非常好用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有今天买入股票才会减少最大交易次数</span></span><br><span class="line">T[i][k][<span class="number">0</span>] 表示在第 i 天结束时，最多进行 k 次交易且在进行操作后持有 <span class="number">0</span> 份股票的情况下可以获得的最大收益；</span><br><span class="line">T[i][k][<span class="number">1</span>] 表示在第 i 天结束时，最多进行 k 次交易且在进行操作后持有 <span class="number">1</span> 份股票的情况下可以获得的最大收益。</span><br><span class="line"><span class="comment">//今天不持股，1.昨天也不持股，今天啥也不做(那今天允许的最大交易次数为k,昨天允许的最大交易次数也为) 2.昨天持股，今天卖掉，但是不影响最大交易次数(今天允许的最大交易次数为k，今天只是卖掉，所以昨天允许的最大交易次数也为k)。因为只有今天买入才会影响交易次数</span></span><br><span class="line">T[i][k][<span class="number">0</span>] = max(T[i - <span class="number">1</span>][k][<span class="number">0</span>], T[i - <span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line"><span class="comment">//今天持股，1.昨天就持股，今天啥也不做(那么你最大交易次数为k,昨天最大交易次数还是3) 2.昨天不持股，今天买入，要花掉一次交易次数。(前i天最大只能交易k次，你第i天交易了一次，那么前i-1天最大只能交易k-1次)</span></span><br><span class="line">T[i][k][<span class="number">1</span>] = max(T[i - <span class="number">1</span>][k][<span class="number">1</span>], T[i - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure></li></ul><h4 id="121-股票买卖最佳时机Ⅰ"><a href="#121-股票买卖最佳时机Ⅰ" class="headerlink" title="121.股票买卖最佳时机Ⅰ"></a>121.股票买卖最佳时机Ⅰ</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</span><br><span class="line"></span><br><span class="line">如果你<span class="string">&quot;最多只允许完成一笔交易（即买入和卖出一支股票一次）&quot;</span>，设计一个算法来计算你所能获取的最大利润。</span><br><span class="line">注意：你不能在买入股票前卖出股票。</span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: 在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出，最大利润 = <span class="number">6</span><span class="number">-1</span> = <span class="number">5</span> 。</span><br><span class="line">     注意利润不能是 <span class="number">7</span><span class="number">-1</span> = <span class="number">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line"><span class="comment">//注意本题只能买入卖出股票一次，也就是只能交易一次，而每次交易都是从买入开始的，所以买入股票之后才是减少了一次交易，所以交易一次后的状态就是持有股票</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这一题是最多只卖买一次</span><br><span class="line">推导状态转移方程：</span><br><span class="line"></span><br><span class="line">dp[i][<span class="number">0</span>]：规定了今天不持股，有以下两种情况：</span><br><span class="line">昨天不持股，今天什么都不做；</span><br><span class="line">昨天持股，今天卖出股票（现金数增加），</span><br><span class="line">dp[i][<span class="number">1</span>]：规定了今天持股，有以下两种情况：</span><br><span class="line">昨天持股，今天什么都不做（现金数与昨天一样）；</span><br><span class="line">昨天不持股，今天买入股票（注意：只允许交易一次，因此今天买入股票就是第一次也是最后一次买，所以dp[i][<span class="number">1</span>]就是今天股票价格的相反数）。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(prices.size()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>,dp[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= prices.size();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i<span class="number">-1</span>]);</span><br><span class="line">            <span class="comment">//只有一次交易，所以买入股票也是第一次买入，所以获得利润一定是这次股票金额的相反数</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>],-prices[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.size()][<span class="number">0</span>];<span class="comment">//肯定是最后天不持股前最多，因为只能买入一次，所以今天还有股票，钱一定是负数，还没卖</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//滚动数组优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>,dp[<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= prices.size();i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>] = max(dp[<span class="number">0</span>],dp[<span class="number">1</span>]+prices[i<span class="number">-1</span>]);</span><br><span class="line">            dp[<span class="number">1</span>] = max(dp[<span class="number">1</span>],-prices[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="122-股票买卖最佳时机Ⅱ"><a href="#122-股票买卖最佳时机Ⅱ" class="headerlink" title="122.股票买卖最佳时机Ⅱ"></a>122.股票买卖最佳时机Ⅱ</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本题允许多次交易</span></span><br><span class="line">给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</span><br><span class="line">设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</span><br><span class="line">注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">3</span> 天（股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span><span class="number">-1</span> = <span class="number">4</span> 。</span><br><span class="line">     随后，在第 <span class="number">4</span> 天（股票价格 = <span class="number">3</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">6</span><span class="number">-3</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(prices.size()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>,dp[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= prices.size();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i<span class="number">-1</span>]);</span><br><span class="line">            <span class="comment">//多次交易和一次交易的区别就在这里，多次交易今天买股票就有可能不是第一次交易了</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.size()][<span class="number">0</span>];<span class="comment">//最后一定是没有钱套在股票里面利润高</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空间优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>,dp[<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= prices.size();i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>] = max(dp[<span class="number">0</span>],dp[<span class="number">1</span>]+prices[i<span class="number">-1</span>]);</span><br><span class="line">            dp[<span class="number">1</span>] = max(dp[<span class="number">1</span>],dp[<span class="number">0</span>]-prices[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="123-股票买卖最佳时机Ⅲ"><a href="#123-股票买卖最佳时机Ⅲ" class="headerlink" title="123.股票买卖最佳时机Ⅲ"></a>123.股票买卖最佳时机Ⅲ</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</span><br><span class="line">设计一个算法来计算你所能获取的最大利润。你最多可以完成 <span class="string">&quot;两笔&quot;</span> 交易。</span><br><span class="line">注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里用到的就是k=2时的递推模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; dp(prices.size()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(<span class="number">3</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>)));</span><br><span class="line">        <span class="comment">//这个初始化很重要，无论是最大交易次数为几次，第一天</span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = - prices[<span class="number">0</span>],dp[<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= prices.size();i++)&#123;</span><br><span class="line">            <span class="comment">//其实这里顺着逆着都可以，因为他用到都是昨天的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j &gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">0</span>],dp[i<span class="number">-1</span>][j][<span class="number">1</span>]+prices[i<span class="number">-1</span>]);</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>]-prices[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;zu</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.size()][<span class="number">2</span>][<span class="number">0</span>];<span class="comment">//自然是最后没有钱套在里面钱最多</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空间优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(<span class="number">3</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = - prices[<span class="number">0</span>],dp[<span class="number">2</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= prices.size();i++)&#123;</span><br><span class="line">            <span class="comment">//因为j=2和j=1是独立的空间，所以从后向前和从前向后都一样</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">2</span>;j++)&#123;</span><br><span class="line">                dp[j][<span class="number">0</span>] = max(dp[j][<span class="number">0</span>],dp[j][<span class="number">1</span>]+prices[i<span class="number">-1</span>]);</span><br><span class="line">                dp[j][<span class="number">1</span>] = max(dp[j][<span class="number">1</span>],dp[j<span class="number">-1</span>][<span class="number">0</span>]-prices[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="188-股票买卖最佳时机Ⅳ"><a href="#188-股票买卖最佳时机Ⅳ" class="headerlink" title="188.股票买卖最佳时机Ⅳ"></a>188.股票买卖最佳时机Ⅳ</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</span><br><span class="line">设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</span><br><span class="line">注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这一题就是上面可以2次交易的一般推广版，只要注意k=1时要特殊处理就行了.下面是优化过后的代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">maxProfit1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>,dp[<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= prices.size();i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>] = max(dp[<span class="number">0</span>],dp[<span class="number">1</span>]+prices[i<span class="number">-1</span>]);</span><br><span class="line">            dp[<span class="number">1</span>] = max(dp[<span class="number">1</span>],-prices[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> maxProfit1(prices);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(k+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++) dp[i][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= prices.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= k;j++)&#123;</span><br><span class="line">                dp[j][<span class="number">0</span>] = max(dp[j][<span class="number">0</span>],dp[j][<span class="number">1</span>]+prices[i<span class="number">-1</span>]);</span><br><span class="line">                dp[j][<span class="number">1</span>] = max(dp[j][<span class="number">1</span>],dp[j<span class="number">-1</span>][<span class="number">0</span>]-prices[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a>309. 最佳买卖股票时机含冷冻期</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</span><br><span class="line">设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</span><br><span class="line">你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br><span class="line">卖出股票后，你无法在第二天买入股票 (即冷冻期为 <span class="number">1</span> 天)。</span><br><span class="line">示例:</span><br><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br><span class="line"><span class="comment">//这题还是官方题解比较清晰</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关于冷冻期，只有卖出股票之后才是冷冻期，才会影响股票的购入，所以冷冻期一定之和购入股票有关系，而购入股票只有在持有股票这种状态才有，所有我们要到持有股票态dp[i][1]思考</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty() || prices.size() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(prices.size()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>,dp[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">2</span>][<span class="number">0</span>] = max(dp[<span class="number">1</span>][<span class="number">0</span>],dp[<span class="number">1</span>][<span class="number">1</span>]+prices[<span class="number">1</span>]);</span><br><span class="line">        dp[<span class="number">2</span>][<span class="number">1</span>] = max(dp[<span class="number">1</span>][<span class="number">1</span>],dp[<span class="number">1</span>][<span class="number">0</span>]-prices[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= prices.size();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i<span class="number">-1</span>]);</span><br><span class="line">            <span class="comment">/*现在考虑的是今天结束后你持有股票</span></span><br><span class="line"><span class="comment">            1.昨天结束后你就有股票，今天啥也没干</span></span><br><span class="line"><span class="comment">            2.你昨天结束之后没有，但是今天要买(所以昨天结束后一定未持股)，那么昨天要么是冷冻期，要么就是前天就没有然后昨天又没买。是否有冷冻期取决于前天到底是否卖出了股票，你前天卖出去了，昨天冷冻期，导致未持股。前天你本来就没股票，然后你昨天也没股票，昨天又没买。</span></span><br><span class="line"><span class="comment">            综上，我们只需要保证前天结束之后你没股票，从这个状态过来就可以，所以对于前天而言，我们只需要这一种决策就可以了。因为你前天结束之后没股票，不管他是怎么没的，在我们的要求下昨天都不会买。所以在i-2天没股票的情况下过来，昨天结束之后没股票的钱是等于前天结束之后没股票的钱的。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="string">&quot;最新总结，如果你想第i天买股票，那么i-1天必须没股票，但是如果从i-1天直接过来的话会有问题：因为你i-1天不持股的最大价值dp[i-1][0]可能是由于你第i-1天卖出去导致，也有可能是你第i-1天没股，啥也不动(即i-1天之前就获得了最大值)。如果如果dp[i-1][0]是由于第i-1天卖掉股票得到的，会导致今天冷冻期，结果你还买了，违反了冷冻期。所以我们要让第i天买的时候绝对不是冷冻期，所以冷冻期最多在i-1天。所以如果从i-2天过来就不会有这儿问题。为什么呢？因为i-2天之后就铁没股票的(我们从dp[i-2][0]调过来)，然后第i天要买，不管i-2天是怎么弄得，就算有冷冻期，冷冻期也只在第i-1天，对第i天一定影响都没有。还有就是我们从dp[i-2][0]过来之后，要保证第i买股票，所以i-1天必定没股票，也就是第i-1天什么都不操作。在这两层约束下，dp[i-1][0] = dp[i-2][0]的。所以调过来是没问题的&quot;</span></span><br><span class="line">                <span class="string">&quot;保证i天不是冷冻期且第i天能买&quot;</span>-&gt;第i<span class="number">-1</span>天绝对没卖且第i<span class="number">-1</span>天结束后没股票-&gt;那么i<span class="number">-1</span>天开始就没股票-&gt;那么只能从i<span class="number">-2</span>天后没股票这个状态过来，即dp[i<span class="number">-2</span>][<span class="number">0</span>]。</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-2</span>][<span class="number">0</span>]-prices[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.size()][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="124-二叉树的最大路径和"><a href="#124-二叉树的最大路径和" class="headerlink" title="124.二叉树的最大路径和"></a>124.二叉树的最大路径和</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定一个非空二叉树，返回其最大路径和。</span><br><span class="line"></span><br><span class="line">本题中，路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</span><br><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">       <span class="number">1</span></span><br><span class="line">      / \</span><br><span class="line">     <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure><img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201225003706680.png" class><p><strong>如图，对这样的一棵一般性的树，根的左右孩子都有两条分支。我们只要求A左子树上包括根节点在内最大单侧分支。A右子树的最大单侧分支。再将他们和根节点加起来得到一个值。这三个值最大值就是我们的结果</strong></p><img src="/2021/01/25/leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/image-20201225090815684.png" class><p>我们写一个函数，返回的就是root左孩子两个圈的最大值v1和右孩子两个圈的最大值v2。这样整个树路径最大值。只可能在。v1,v2,v1+v2之间取了。考虑到v1,v2都可能为负数，如果是负数对整个最大路径没有增益，所以可以用0来处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//返回包括root在内的左右斜枝的的路径的最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxOneSide</span><span class="params">(TreeNode* root,<span class="keyword">int</span> &amp;value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = maxOneSide(root-&gt;left,value);</span><br><span class="line">        <span class="keyword">int</span> right = maxOneSide(root-&gt;right,value);</span><br><span class="line">        <span class="keyword">int</span> lmr = max(<span class="number">0</span>,left) + max(<span class="number">0</span>,right) + root-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> ret = max(<span class="number">0</span>,max(left,right)) + root-&gt;val;</span><br><span class="line">        value = max(value,max(ret,lmr));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value =INT_MIN;</span><br><span class="line">        maxOneSide(root,value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
